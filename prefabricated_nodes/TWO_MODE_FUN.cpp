#include "TWO_MODE_FUN.h"#include "GLOBAL_FUN.h"#include "QFog_constants.h"//******************************************TWO_MODE_FUN::TWO_MODE_FUN(const DOUBLE  & 	tau_mag,	//inconst DOUBLE  & 	tau_ang,	//inconst DOUBLE  & 	rho_ang)	//in	:its_tau_mag(tau_mag),	its_tau_ang(tau_ang),	its_rho_ang(rho_ang){	its_tau =  (its_tau_mag)*exp( COMPLEX(0, its_tau_ang*my_pi/180) );	its_rho =  DOUBLE(sqrt(1-pow(its_tau_mag, 2)))*exp( COMPLEX(0, its_rho_ang*my_pi/180) );//its_cos, its_sin and its_theta won't be used	its_cos=0;	its_sin=0;	its_theta=0;}//******************************************TWO_MODE_FUN::TWO_MODE_FUN(const DOUBLE  & 	theta)	//in	:its_theta(theta){	its_cos = cos(its_theta*my_pi/180);	its_sin = sin(its_theta*my_pi/180);		its_tau_mag = abs(its_cos);	its_tau_ang = its_cos>0?0:180;	its_rho_ang = its_sin>0?0:180;	its_tau =  its_cos;	its_rho =  its_sin;}//******************************************COMPLEX		TWO_MODE_FUN::get_bs_amp(USHORT 	n1,		//inUSHORT 	n2,		//inUSHORT 	m1,		//inUSHORT	m2)		//inconst{//calculates beam splitter amp//be very careful when subtracting USHORTs! 0-1 is not -1 for ushorts.// no incomming photons	if( (n1+n2+m1+m2) == 0) {		return COMPLEX(1, 0);	}//zero amp cases  	SHORT	up_lim, lo_lim;    if (n1 <= m1){      up_lim = n1;    }else{      up_lim = m1;    }      if (m1 <= n2){ //m1-n2<=0 will not work! because using USHORTs      lo_lim = 0;    }else{      lo_lim = m1-n2;    }    if (  ((n1+n2) != (m1+m2)) || (lo_lim > up_lim) ) {		return COMPLEX(0, 0);       	}// tau_mag=1 case	SHORT n_dif = SHORT(n1) - SHORT(n2);	if(abs(its_tau_mag-1)<amps_floor){		if(n1==m1 && n2==m2){			return exp( COMPLEX(0, its_tau_ang*my_pi/180*n_dif) ); 		}else{			return COMPLEX(0, 0);		}	}// tau_mag=0 case	if(its_tau_mag<amps_floor){		if(n1==m2 && n2==m1){			return exp( COMPLEX(0, (its_rho_ang/180*n_dif + n2)*my_pi ));		}else{			return COMPLEX(0, 0);		}	}//	SHORT		j, j1;    	COMPLEX		sum(0, 0);  	COMPLEX		term(0, 0);  		for(j1=lo_lim; j1 <= up_lim; j1++){	    term = pow(its_tau, j1)/my_factorial(j1);	    j = SHORT(n2)-SHORT(m1)+j1;	    term = term*pow(conj(its_tau), j)/my_factorial(j);	    j = SHORT(n1)-j1;	    term = term*pow(its_rho, j)/my_factorial(j);	    j = SHORT(m1)-j1;	    term = term*pow(conj(-its_rho), j)/my_factorial(j);	    sum = sum + term;	    	}		return DOUBLE(sqrt(my_factorial(n1)*my_factorial(n2)*my_factorial(m1)*my_factorial(m2)))*sum;	}//******************************************COMPLEX		TWO_MODE_FUN::get_pol_amp(USHORT 	nx,		//inUSHORT 	ny,		//inUSHORT	nloss,	//inUSHORT 	mx,		//inUSHORT	my)		//inconst{	//calculates polarizer amplitude		//signal if used wrong constructor	SignalIf_( pow(its_cos,2) + pow(its_sin,2)<.5);		//its_sin = 0 case	if(abs(its_sin)<amps_floor){		if(nx==mx && ny==0 && nloss==my){			return pow(its_cos, 2*nx + nloss);		}else{			return COMPLEX(0, 0);		}	}	//its_cos = 0 case	if(abs(its_cos)<amps_floor){		if(nx==0 && ny==my && nloss==mx){			return (nloss%2==0?1:-1)*pow(its_sin, 2*ny + nloss);		}else{			return COMPLEX(0, 0);		}	}		COMPLEX		z = get_bs_amp(nx + ny, nloss, mx, my);	if(abs(z)<amps_floor)return COMPLEX(0, 0);	return z*DOUBLE(pow(its_cos, nx)*pow(its_sin, ny)*sqrt(  my_factorial(nx+ny)/(my_factorial(nx)*my_factorial(ny))  ));}