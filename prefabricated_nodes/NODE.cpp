#include "NODE.h"#pragma mark --creation/destruction--//******************************************ST_NAMES_GENERATOR_DATA::ST_NAMES_GENERATOR_DATA()	:its_num_of_comps(1),	its_min_char('0'),	its_max_char('1'),	its_has_commas(false){}//******************************************NODE::NODE()	:its_degen(1),	its_st_names("x", 1),	its_st_name_dict_p(0),	its_num_of_in_sts(1){#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	its_amp_gen_p = 0;#endif //_mac_gui_app \\............................................//	// note that the default TRANS_MAT constructor creates a 1 X 1 zero matrix 	its_active_states.insert(0);}//******************************************NODE::~NODE(){#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	if(its_amp_gen_p!=0){		delete its_amp_gen_p;		its_amp_gen_p = 0;	}#endif //_mac_gui_app \\............................................//}#pragma mark --degen--//******************************************VOID	NODE::set_degen(USHORT degen)	//in{	//I've coded so that this function is never called with degen==0	//ThrowIf_(degen==0);	its_degen = degen;	its_st_names.resize("x", degen);	its_tm_amps.set_num_of_rows(degen);	its_active_states.resize(degen);	its_cum_probs.set_to_default_vec(0, degen);	its_cum_amps.set_to_default_vec(COMPLEX(0, 0), degen);}#pragma mark --state names--//******************************************VOID	NODE::set_st_names_to_monotone_seq(USHORT starting_point)		//in{	USHORT j = starting_point;	for(USHORT row=0; row<its_degen; row++){		its_st_names[row]= j;		j++;	}}//******************************************VOID	 NODE::set_st_names(const ST_NAMES_GENERATOR_DATA  &		v)	//in{		//'0' = 48	//'9' = 57	//'A' = 65	//'Z' = 90	//'a' = 97	//'z' = 122	SHORT	n_0 = '0';	SHORT	n_9 = '9';	SHORT	n_A = 'A';	SHORT	n_Z = 'Z';	SHORT	n_a = 'a';	SHORT	n_z = 'z';		SHORT	n_min_char = v.its_min_char;	SHORT	n_max_char = v.its_max_char;	SHORT	num_of_poss_chars;	if(n_min_char<=n_9){		if(n_max_char<=n_9){			num_of_poss_chars = n_max_char - n_min_char + 1;		}else{			num_of_poss_chars = (n_max_char - n_a + n_9 + 1) - n_min_char + 1;		}	}else{ //n_min_char and n_max_char are both in [n_a, n_z] 		num_of_poss_chars = n_max_char - n_min_char + 1;	}		DOUBLE	x = pow(num_of_poss_chars, DOUBLE(v.its_num_of_comps));	USHORT	num_of_poss_names = (x<=max_ushort? USHORT(x):max_ushort);/*		CHAR	char_set_p[64];	USHORT	j, k=0;	if(n_min_char<=n_9){		if(n_max_char<=n_9){			for(j=n_min_char; j<=n_max_char; j++){				char_set_p[k] = (CHAR)j;				k++;			}		}else{			for(j=n_min_char; j<=n_9; j++){				char_set_p[k] = (CHAR)j;				k++;			}			for(j=n_a; j<=n_max_char; j++){				char_set_p[k] = (CHAR)j;				k++;			}		}	}else{		for(j=n_min_char; j<=n_max_char; j++){			char_set_p[k] = (CHAR)j;			k++;		}	}*/		CHAR  	name_p[32];	USHORT	pos;		ThrowIf_(v.its_num_of_comps>32);	for(pos=0; pos<v.its_num_of_comps; pos++){		name_p[pos] = v.its_min_char;	}	name_p[v.its_num_of_comps] = '\0';	//x prefix if has commas		CHAR 	xname_p[32];	USHORT	xpos;	USHORT	xlen = v.its_num_of_comps*2 + 1; // does not include \0	if(v.its_has_commas){		//last if() is necessary because		//in cases when has_commas=false		//xlen may exceed 32 !!		ThrowIf_(xlen>32);		for(xpos=0; xpos<xlen; xpos++){			xname_p[xpos] = ',';		}		xname_p[0] = '(';		xname_p[xlen -1] = ')';		xname_p[xlen] = '\0';	}	for(USHORT	j=0; j<its_degen && j<num_of_poss_names; j++){		if(!v.its_has_commas){			its_st_names[j] = name_p;		}else{			xpos=1;			for(pos=0; pos<v.its_num_of_comps; pos++){				xname_p[xpos] = name_p[pos];				xpos +=2;			}			its_st_names[j] = xname_p;		}		pos = v.its_num_of_comps-1;		while(name_p[pos]==v.its_max_char && pos!=0){			pos--;		}		if(name_p[pos]=='9'){			name_p[pos] = 'a';		}else{			name_p[pos]++;		}  		while(pos<(v.its_num_of_comps-1)){			pos++;			name_p[pos] = v.its_min_char;		}	}}//******************************************VOID	NODE::create_dict(){	//check that the dict doesn't already exist	if(its_st_name_dict_p==0){		its_st_name_dict_p = new DICTIONARY(&its_st_names);		//delete:	via		//			QB_NET::kill_dictionaries()->		//			QB_NET::kill_nd_st_dictionaries()->NODE::kill_dict()		ThrowIfNil_(its_st_name_dict_p);	}else{		its_st_name_dict_p->add_one_user();	}}//******************************************VOID	NODE::kill_dict(){	if(its_st_name_dict_p->get_num_of_users()<=1){			delete its_st_name_dict_p;		its_st_name_dict_p = 0;	}else{		its_st_name_dict_p->del_one_user();	}}#pragma mark --in nodes--//******************************************VOID	NODE::set_num_of_in_sts(){// note that if its_in_nds has zero length,// this sets its_num_of_in_sts to 1.	its_num_of_in_sts = 1;	for(USHORT i =0; i < its_in_nds.get_len() ; i++){		its_num_of_in_sts *= its_in_nd_degens[i];	}}//******************************************VOID	NODE::add_in_nd(USHORT 		nd_id,		//in	USHORT 		nd_degen)	//in{	its_in_nds.insert_last(nd_id);	its_in_nd_degens.insert_last(nd_degen);	its_in_nd_sof.init(its_in_nd_degens);	set_num_of_in_sts();	its_tm_amps.set_to_zero_mat(its_degen, its_num_of_in_sts);}//******************************************VOID	NODE::del_in_nd(USHORT nd_id)		//in	{	USHORT loc= its_in_nds.loc_of_target(nd_id);	its_in_nds.extract_at(loc);	its_in_nd_degens.extract_at(loc);	its_in_nd_sof.init(its_in_nd_degens);	set_num_of_in_sts();	its_tm_amps.set_to_zero_mat(its_degen, its_num_of_in_sts);}//******************************************VOID	NODE::set_in_nd_degen(USHORT 	nd_id,			//inUSHORT 	new_degen)		//in{// assumes that nd_id is contained in its_in_nds.	USHORT loc = its_in_nds.loc_of_target(nd_id);	if(its_in_nd_degens[loc]==new_degen)return;// we used to try to save some of the trans_mat. Now we just set it to zero.//	VECTOR<USHORT> new_nd_degens = its_in_nd_degens;//	new_nd_degens[loc] =new_degen;//	COL_LABEL_TRANSLATOR  ator(its_in_nd_degens, new_nd_degens);//	its_tm_amps.relabel_cols( ator );	its_in_nd_degens[loc] =new_degen;	its_in_nd_sof.init(its_in_nd_degens);	set_num_of_in_sts();	its_tm_amps.set_to_zero_mat(its_degen, its_num_of_in_sts);}//******************************************VOID	NODE::renumber_in_nds(const UI_MAP  &		map)	//in{	//called by VOID	QB_NET::reorder_nds(()	for(USHORT	i=0; i<its_in_nds.get_len(); i++){		its_in_nds[i] = map.its_newfo[its_in_nds[i]];	}}//******************************************VOID	NODE::reorder_in_nds(const UI_MAP  &		map,		//inBOOLEAN				touch_tm)	//in{	if(map.is_identity_map())return;	USHORT	num_of_in_nds = its_in_nds.get_len();	USHORT	i, old_i;		VECTOR<USHORT>	saved_in_nds(its_in_nds);	VECTOR<USHORT>	saved_in_nd_degens(its_in_nd_degens);	STRETCH_OR_FOLD saved_in_nd_sof(its_in_nd_sof);	for(i=0; i< num_of_in_nds; i++){		old_i = map.its_oldfn[i];		its_in_nds[i] = saved_in_nds[old_i];		its_in_nd_degens[i] = saved_in_nd_degens[old_i];	}		its_in_nd_sof.reorder_degens(map);		if(touch_tm)its_tm_amps.reorder_cols_as_part_of_reordering_in_nds(saved_in_nd_sof, its_in_nd_sof, map);		 }//******************************************VOID	NODE::change_in_nd_to_compatible_one(USHORT		old_nd,				//inUSHORT		new_nd)			//in{	//this function is called by QB_NET::change_source_nd_of_ar()	USHORT loc= its_in_nds.loc_of_target(old_nd);	its_in_nds[loc] =new_nd;	//its_in_nd_degens: no change	//its_in_nd_sof: no change	//its_num_of_in_sts: no change	//its_tm_amps: no change}#pragma mark --out nodes--//******************************************VOID	NODE::renumber_out_nds(const UI_MAP  &		map)	//in{	//called by VOID	QB_NET::reorder_nds(()	for(USHORT	i=0; i<its_out_nds.get_len(); i++){		its_out_nds[i] = map.its_newfo[its_out_nds[i]];	}}#pragma mark --reorder states--//******************************************VOID	NODE::reorder_sts(const UI_MAP  &		map)	//in{	if(map.is_identity_map())return;	USHORT	num_of_rows = its_st_names.get_len();	USHORT	i;	VECTOR<STRINGY>	saved_st_names(its_st_names);	for(i=0; i< num_of_rows; i++){		its_st_names[i] = saved_st_names[map.its_oldfn[i]];	}		//I won't reorder the dictionary since I don't expect it to 	//be around when I call this method.	ThrowIf_(its_st_name_dict_p!=0);	its_tm_amps.reorder_rows(map);		SET		saved_active_states(its_active_states);	its_active_states.empty();	for(i=0; i< num_of_rows; i++){		if(saved_active_states.contains(map.its_oldfn[i])){			its_active_states.insert(i);		}	}			 }//******************************************VOID	NODE::change_tm_as_part_of_reordering_nd_sts_of_a_pa(USHORT		pa_id, 			//inconst UI_MAP  &		map)	//in{	its_tm_amps.reorder_cols_as_part_of_reordering_nd_sts_of_a_pa(		its_in_nds.loc_of_target(pa_id),		its_in_nd_sof,		map);}#pragma mark --active states--//******************************************VOID 		NODE::fill_act_st_set(){	for(USHORT i=0;i<its_degen;i++){		activate_state(i);	}}//******************************************VOID 	NODE::restore_act_st_set(){	its_active_states = its_tempo_active_states;	its_tempo_active_states.clear();}#pragma mark --about dynamics--//******************************************VOID	NODE::set_dyn_st_and_dir_ele_ptr(USHORT 	dyn_st)			//in{	its_dyn_st = dyn_st;	move_dyn_dir_ele_ptr_to_first_col();}//******************************************VOID	NODE::advance_dyn_dir_ele_ptr(){	ThrowIfNil_(its_dyn_dir_ele_p);	its_dyn_dir_ele_p = its_dyn_dir_ele_p->its_next_p;	reset_dyn_in_st();}//******************************************VOID	NODE::move_dyn_dir_ele_ptr_to_first_col(){	its_dyn_dir_ele_p = its_tm_amps.get_row_ptr(its_dyn_st);	reset_dyn_in_st();}//******************************************BOOLEAN 	NODE::has_dyn_in_st()const{	if(its_dyn_dir_ele_p==0){		return false;	}else{		return true;	}}//******************************************VOID 	 NODE::reset_dyn_in_st(){	if(its_dyn_dir_ele_p!=0){		its_dyn_in_st = its_in_nd_sof.vec_label(its_dyn_dir_ele_p->its_col_num);	}else{		its_dyn_in_st.set_to_default_vec(max_ushort, its_in_nds.get_len());	}}//******************************************VOID	NODE::normalize_cum_probs(){	DOUBLE sum=0.;	USHORT st;	for(st=0; st<its_degen; st++){		sum +=its_cum_probs[st];	}	if(sum != 0){		for(st=0; st<its_degen; st++){			its_cum_probs[st] /= sum;		}	}	}//******************************************VOID	NODE::set_cum_info_to_default(){		its_cum_probs.set_to_default_vec(0, its_degen);	its_cum_amps.set_to_default_vec(COMPLEX(0, 0), its_degen); }//******************************************VOID	NODE::prepare_cum_info_for_next_ending(){	for(USHORT state=0; state<its_degen; state++){		its_cum_probs[state] += norm(its_cum_amps[state]);		//norm = modulus**2 = abs**2 = real**2 + imag**2		its_cum_amps[state] = 0;	}}//******************************************//#include 	"NODE(mac).cpp"