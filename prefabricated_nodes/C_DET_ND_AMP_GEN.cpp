#include 	"C_DET_ND_AMP_GEN.h"#include 	"QB_NET.h"#include 	"C_PI_WIND.h"#include 	"EXCEPTIONS.h"//******************************************DET_ND_AMP_GEN_ENTRIES::DET_ND_AMP_GEN_ENTRIES()	:its_nd_type(k_cnot),	its_cnot_pa1_is_control(true),	its_cnot_1fires(true),	its_marg_pos(1),	its_marg_len(1),	its_pshifter_theta(0),	its_pshifter_do_multiples(true){}//******************************************C_DET_ND_AMP_GEN::C_DET_ND_AMP_GEN(DET_ND * 		nd_p,		//inQB_NET * 		net_p,		//inC_PI_WIND * 	pi_wind_p)	//in	:C_AMP_GEN(nd_p, net_p, pi_wind_p),	its_host_view_p(0){}//******************************************VOID		C_DET_ND_AMP_GEN::reset_subpane(const DET_ND_AMP_GEN_ENTRIES &	entries)		//in{	//This method does not check whether	//the new and the old subpanes are the same.	//It's up to you to check this and prevent the method from being called	//when they are the same, if that is what is best.	//SetValue() only works for efields with integer values			ThrowIfNil_(its_host_view_p);	switch(entries.its_nd_type){		case k_cnot:			its_host_view_p->ResetSubPane(cnot_pane_rid, true);			LStdRadioButton  * 	cnot_pa1_radio_p = (LStdRadioButton  *)its_host_view_p->FindPaneByID(cnot_pa1_radio_rid);			LStdRadioButton  * 	cnot_pa2_radio_p = (LStdRadioButton  *)its_host_view_p->FindPaneByID(cnot_pa2_radio_rid);									LStdRadioButton  * 	cnot_0fires_radio_p = (LStdRadioButton  *)its_host_view_p->FindPaneByID(cnot_0fires_radio_rid);			LStdRadioButton  * 	cnot_1fires_radio_p = (LStdRadioButton  *)its_host_view_p->FindPaneByID(cnot_1fires_radio_rid);									if(entries.its_cnot_pa1_is_control){				cnot_pa1_radio_p->SetValue(1);			}else{				cnot_pa2_radio_p->SetValue(1);			}			if(entries.its_cnot_1fires){				cnot_1fires_radio_p->SetValue(1);			}else{				cnot_0fires_radio_p->SetValue(1);			}			break;		case k_marg:			its_host_view_p->ResetSubPane(marg_pane_rid, true);			LEditField  * 	marg_pos_efield_p = (LEditField  *)its_host_view_p->FindPaneByID(marg_pos_efield_rid);			LEditField  * 	marg_len_efield_p = (LEditField  *)its_host_view_p->FindPaneByID(marg_len_efield_rid);			marg_pos_efield_p->SetValue(entries.its_marg_pos);			marg_len_efield_p->SetValue(entries.its_marg_len);			break;		case k_pshifter:			its_host_view_p->ResetSubPane(pshifter_pane_rid, true);			LEditField  * 	pshifter_theta_efield_p = (LEditField  *)its_host_view_p->FindPaneByID(pshifter_theta_efield_rid);			LStdCheckBox  *  pshifter_check_box_p = (LStdCheckBox  *)its_host_view_p->FindPaneByID(pshifter_check_box_rid);			LStr255		x_str;			x_str.Assign( entries.its_pshifter_theta, FIXEDDECIMAL, 6);				pshifter_theta_efield_p->SetDescriptor(x_str);			pshifter_check_box_p->SetValue(entries.its_pshifter_do_multiples?1:0);			break;	}}//******************************************BOOLEAN		C_DET_ND_AMP_GEN::parents_are_canonical(DET_ND_TYPE		nd_type){	switch(nd_type){		case k_cnot:					return its_pi_wind_p->focus_nd_has_this_many_parents(2) && 				its_pi_wind_p->focus_nd_parents_are_binary();			break;		case k_marg:			return its_pi_wind_p->focus_nd_has_this_many_parents(1);			break;		case k_pshifter:			//will check that names are ushort when do_multiples is true			//in C_DET_ND_AMP_GEN::det_nd_dialog_entries_are_legal()			return its_pi_wind_p->focus_nd_has_this_many_parents(1);			break;	}	return false;}//******************************************BOOLEAN		C_DET_ND_AMP_GEN::get_wind_entries(DET_ND_AMP_GEN_ENTRIES	 &		entries)	//out{	USHORT 		in_nd, in_nd_degen, j;	NODE  * 	in_nd_p ;	STRINGY 	sgy;	ThrowIfNil_(its_host_view_p);	switch(entries.its_nd_type){		case k_cnot:			LStdRadioButton  * 	cnot_pa1_radio_p = (LStdRadioButton  *)its_host_view_p->FindPaneByID(cnot_pa1_radio_rid);			LStdRadioButton  * 	cnot_1fires_radio_p = (LStdRadioButton  *)its_host_view_p->FindPaneByID(cnot_1fires_radio_rid);									entries.its_cnot_pa1_is_control = cnot_pa1_radio_p->GetValue();			entries.its_cnot_1fires = cnot_1fires_radio_p->GetValue();			break;										case k_marg:			LEditField  * 	marg_pos_efield_p = (LEditField  *)its_host_view_p->FindPaneByID(marg_pos_efield_rid);			LEditField  * 	marg_len_efield_p = (LEditField  *)its_host_view_p->FindPaneByID(marg_len_efield_rid);			entries.its_marg_pos = marg_pos_efield_p->GetValue();			entries.its_marg_len = marg_len_efield_p->GetValue();			if(entries.its_marg_pos==0){				my_gen_alert("Must have (position of first projected character) >=1.");				return false;			}			if(entries.its_marg_len==0){				my_gen_alert("Must have (length of projected sub-string) >=1.");				return false;			}			in_nd = its_nd_p->get_in_nds()[0];			in_nd_p = its_net_p->get_nd_ptr(in_nd);			in_nd_degen = in_nd_p->get_degen();			USHORT	avail_len = max_ushort;			for(j=0; j<in_nd_degen; j++){				sgy = in_nd_p->get_st_name(j);					if(sgy.get_len()<avail_len){					avail_len = sgy.get_len();				}			}			USHORT	avail_len_plus_1 = avail_len + 1;			if(entries.its_marg_pos + entries.its_marg_len> avail_len_plus_1){				sgy = STRINGY("Must have (position of first projected character) + (length of projected sub-string) <= ") && avail_len_plus_1 && " .";				my_gen_alert(sgy);				return false;			}			break;		case k_pshifter:			LEditField  * 		pshifter_theta_efield_p = (LEditField  *)its_host_view_p->FindPaneByID(pshifter_theta_efield_rid);			LStdCheckBox  *  	pshifter_check_box_p = (LStdCheckBox  *)its_host_view_p->FindPaneByID(pshifter_check_box_rid);			LStr255		pshifter_theta_pstr;			pshifter_theta_efield_p->GetDescriptor(pshifter_theta_pstr);			if(!STRINGY(pshifter_theta_pstr).is_double()){				my_gen_alert("Your entry for theta must be a real number.");				return false;			}			entries.its_pshifter_theta = double_t(pshifter_theta_pstr);			limited_degrees(entries.its_pshifter_theta);			entries.its_pshifter_do_multiples = pshifter_check_box_p->GetValue();			if(entries.its_pshifter_do_multiples){				in_nd = its_nd_p->get_in_nds()[0];				in_nd_p = its_net_p->get_nd_ptr(in_nd);				in_nd_degen = in_nd_p->get_degen();				for(j=0; j<in_nd_degen; j++){					sgy = in_nd_p->get_st_name(j);					if(!sgy.is_ushort()){						my_gen_alert("Inadmissible parents. When the \"Multiply Theta by occupation number\" option is set to Yes, the states of the parent node must be non-negative integers.");						return false;					}				}					}			break;	}//switch	return true;}//******************************************VOID	C_DET_ND_AMP_GEN::fill_trans_mat_and_st_names_of_nd(){	its_nd_p->empty_trans_mat();	switch(its_entries.its_nd_type){		case k_cnot:{			its_net_p->set_degen_of_a_nd(its_pi_wind_p->get_nd(), 4);						its_nd_p->set_st_name(0, "00");			its_nd_p->set_st_name(1, "01");			its_nd_p->set_st_name(2, "10");			its_nd_p->set_st_name(3, "11");			enum {k_00=0, k_01, k_10, k_11};						USHORT	in_st, control_st, flipper_st, nd_st;			VECTOR<USHORT>		vec(2,2);			STRETCH_OR_FOLD 	sof_in(vec);				for(in_st=0; in_st<4; in_st++){				if(its_entries.its_cnot_pa1_is_control){					control_st = sof_in.vec_label(in_st)[0];					flipper_st = sof_in.vec_label(in_st)[1];					if(its_entries.its_cnot_1fires){						if(control_st==0 && flipper_st==0){							nd_st=k_00;						}else if(control_st==0 && flipper_st==1){							nd_st=k_01;						}else if(control_st==1 && flipper_st==0){							nd_st=k_11;						}else if(control_st==1 && flipper_st==1){							nd_st=k_10;						}					}else{//0fires						if(control_st==0 && flipper_st==0){							nd_st=k_01;						}else if(control_st==0 && flipper_st==1){							nd_st=k_00;						}else if(control_st==1 && flipper_st==0){							nd_st=k_10;						}else if(control_st==1 && flipper_st==1){							nd_st=k_11;						}					}				}else{//pa2 is control					control_st = sof_in.vec_label(in_st)[1];					flipper_st = sof_in.vec_label(in_st)[0];					if(its_entries.its_cnot_1fires){						if(flipper_st==0 && control_st==0){							nd_st=k_00;						}else if(flipper_st==0 && control_st==1){							nd_st=k_11;						}else if(flipper_st==1 && control_st==0){							nd_st=k_10;						}else if(flipper_st==1 && control_st==1){							nd_st=k_01;						}					}else{//0fires						if(flipper_st==0 && control_st==0){							nd_st=k_10;						}else if(flipper_st==0 && control_st==1){							nd_st=k_01;						}else if(flipper_st==1 && control_st==0){							nd_st=k_00;						}else if(flipper_st==1 && control_st==1){							nd_st=k_11;						}					}												}				its_nd_p->set_tm_amp(nd_st, in_st, 1);	//row, col, amp			}			break;}		case k_marg:{			USHORT		in_nd = its_nd_p->get_in_nds()[0];			NODE  * 	in_nd_p = its_net_p->get_nd_ptr(in_nd); 			USHORT		in_nd_degen = in_nd_p->get_degen();			VECTOR<USHORT>	sub_sgy_ids(max_ushort, in_nd_degen);//default_value, len			SET			prev_sub_sgy_ids_set(in_nd_degen);			STRINGY		sub_sgy;			USHORT		max_id=0;			USHORT		in_st, prev_in_st;			for(in_st=0; in_st<in_nd_degen; in_st++){				sub_sgy = in_nd_p->get_st_name(in_st).get_sub_stringy(its_entries.its_marg_pos-1, its_entries.its_marg_len);				prev_sub_sgy_ids_set.empty();				for(prev_in_st=0; prev_in_st<in_st; prev_in_st++){					if(!prev_sub_sgy_ids_set.contains(sub_sgy_ids[prev_in_st])){						prev_sub_sgy_ids_set.insert(sub_sgy_ids[prev_in_st]);						if(sub_sgy==in_nd_p->get_st_name(prev_in_st).get_sub_stringy(its_entries.its_marg_pos-1, its_entries.its_marg_len)){							sub_sgy_ids[in_st] = sub_sgy_ids[prev_in_st];							goto next_in_st;						}										}				}				sub_sgy_ids[in_st] = max_id;				max_id++;				next_in_st:;			}			its_net_p->set_degen_of_a_nd(its_pi_wind_p->get_nd(), max_id);						SET		named_set(max_id);			for(in_st=0; in_st<in_nd_degen; in_st++){				its_nd_p->set_tm_amp(sub_sgy_ids[in_st], in_st, 1);	//row, col, amp				if(!named_set.contains(sub_sgy_ids[in_st])){					its_nd_p->set_st_name(sub_sgy_ids[in_st], in_nd_p->get_st_name(in_st).get_sub_stringy(its_entries.its_marg_pos-1, its_entries.its_marg_len));					named_set.insert(sub_sgy_ids[in_st]);				}			}			break;}		 case k_pshifter:{						USHORT		in_nd = its_nd_p->get_in_nds()[0];			NODE  * 	in_nd_p = its_net_p->get_nd_ptr(in_nd);			USHORT		in_nd_degen = in_nd_p->get_degen();						its_net_p->set_degen_of_a_nd(its_pi_wind_p->get_nd(), in_nd_degen);							STRINGY		sgy;			USHORT		in_st, num;			DOUBLE		ang;			for(in_st=0; in_st<in_nd_degen; in_st++){				sgy = in_nd_p->get_st_name(in_st);				if(its_entries.its_pshifter_do_multiples){					sgy.is_ushort(num);				}else{					num=1;				}				its_nd_p->set_st_name(in_st, sgy);				ang = num*its_entries.its_pshifter_theta;				limited_degrees(ang);				ang *= my_pi/180;				its_nd_p->set_tm_amp(in_st, in_st, COMPLEX(cos(ang), sin(ang)));			}			break;}	}//switch}//******************************************BOOLEAN		C_DET_ND_AMP_GEN::talk(){//This is a trivial generalization of UModalDialogs::AskForOneNumber	StDialogHandlerPlus		d_handler(det_wind_rid, (LCommander *)its_pi_wind_p);//SuperCommander declared	LWindow  *				dialog_p = d_handler.GetDialog();	its_host_view_p = (C_HOST_VIEW  *)dialog_p->FindPaneByID(det_host_view_rid);		LPopupButton  * 		popup_p = (LPopupButton  *)dialog_p->FindPaneByID(det_nd_type_popup_rid);	DET_ND_AMP_GEN_ENTRIES 	entries;	DET_ND_TYPE				nd_type;	popup_p->StopBroadcasting();	popup_p->SetValue(its_entries.its_nd_type);	popup_p->StartBroadcasting();	reset_subpane(its_entries);	entries = its_entries;	while(true){		MessageT	hit_message;		SInt32  	param;		d_handler.DoDialogPlus(hit_message, param);		switch(hit_message){			case msg_det_nd_type_popup:				nd_type = (DET_ND_TYPE)param;				if(entries.its_nd_type != nd_type){					entries.its_nd_type = nd_type;					reset_subpane(entries);				}				// don't return yet				break;			case msg_Cancel:				return false;				break;			case msg_OK:				if(!parents_are_canonical(entries.its_nd_type)){					// don't return yet					break;				}				if(!get_wind_entries(entries)){					// don't return yet					break;				}				its_entries = entries;				UCursor::SetTheCursor(watchCursor);				fill_trans_mat_and_st_names_of_nd();				UCursor::InitTheCursor();												its_pi_wind_p->ListenToMessage(msg_pi_all_act_but, nil);				its_pi_wind_p->set_nd_always(its_pi_wind_p->get_nd());				return true;				break;		}	}}	