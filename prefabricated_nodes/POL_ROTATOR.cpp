#include "POL_ROTATOR.h"#include "GLOBAL_FUN.h"#include "TWO_MODE_FUN.h"#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	#include "StCPTstate.h"	#include "C_PHASOR_YZER_AMP_GEN.h"#endif //_mac_gui_app \\............................................//#pragma mark --creation/destruction--//******************************************POL_ROTATOR::POL_ROTATOR(){}//******************************************POL_ROTATOR::~POL_ROTATOR(){}#pragma mark ----used only with macgui----#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.#pragma mark --creation/destruction--//******************************************POL_ROTATOR::POL_ROTATOR(const Point  &  	m_down_pt)		//in	:NODE(m_down_pt){ }#pragma mark --drawing--//******************************************VOID	POL_ROTATOR::draw(){ //drawer	its_efield_p->Draw(0);	if(!its_efield_p->GetSuperView()->FocusDraw())return;	if(its_state_num_for_cap!=max_ushort) draw_state_cap();		StCPTstate		saved_st(true, true, false);	saved_st.Normalize();	 	//first fill circular region with pattern: 	Rect r; 	::SetRect(&r, 	its_center.h -default_mask_rad, its_center.v -default_mask_rad, 					its_center.h +default_mask_rad, its_center.v +default_mask_rad);		PixPatHandle 	pat_h = ::GetPixPat(pol_rot_pat_rid);	//destroy_h: in this method	ThrowIfNil_(pat_h);	::FillCOval(&r, pat_h );		::DisposePixPat(pat_h);		//now draw black rim:	::RGBForeColor(&C_COLORS::its_black);	::FrameOval(&r);}#pragma mark --amp gen--//******************************************VOID	POL_ROTATOR::call_amp_gen(QB_NET *  net_p, 		//inC_PI_WIND * pi_wind_p)	//in{	if(its_amp_gen_p==0){//set to nil in NODE::NODE() and NODE::NODE(const Point  & center)		its_amp_gen_p = new C_PHASOR_YZER_AMP_GEN(k_pol_rot, this, net_p, pi_wind_p);		//delete:	by NODE::~NODE()							ThrowIfNil_(its_amp_gen_p );		//Created first time it is used,	}	its_amp_gen_p->talk();}//******************************************VOID	POL_ROTATOR::obey_amp_gen(const DOUBLE & 	theta,		//inUSHORT 			max_m_sum,	//inconst USHORT  * 	mx_p,	//inconst USHORT  * 	my_p)	//in{	empty_trans_mat();		TWO_MODE_FUN  two_fun(theta);		SHORT 	row = -1;	COMPLEX	z(0, 0);	BOOLEAN 	tm_row_starting;	for(USHORT 	n_sum=0; n_sum<=max_m_sum ; n_sum++){ //n_sum = nx + ny	for(USHORT  ny=0; ny<= n_sum ; ny++){		USHORT nx = n_sum - ny;		tm_row_starting = true;		for(TM_COL_NUM in_st=0; in_st<its_num_of_in_sts; in_st++){						z = two_fun.get_bs_amp(nx, ny, mx_p[in_st], my_p[in_st]);			if(abs(z)>=amps_floor){				if(tm_row_starting){					row++;					its_st_names[row] =  STRINGY("(" ) &&  nx  && "," && ny && ")";					tm_row_starting=false;				}				its_tm_amps.set_ele( row, in_st, z);			}		}	}}}// *********************************************#endif //_mac_gui_app \\............................................//