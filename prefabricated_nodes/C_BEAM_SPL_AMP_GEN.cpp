#include 	"C_BEAM_SPL_AMP_GEN.h"#include 	"QB_NET.h"#include 	"C_PI_WIND.h"#include 	"EXCEPTIONS.h"//******************************************C_BEAM_SPL_AMP_GEN::C_BEAM_SPL_AMP_GEN(BEAM_SPL * 		nd_p,		//inQB_NET * 		net_p,		//inC_PI_WIND * 	pi_wind_p)	//in	:C_AMP_GEN(nd_p, net_p, pi_wind_p),	its_tau_mag(1),	its_tau_ang(0),	its_rho_ang(0),	its_max_n_sum(1),	its_type(scalar_bs){}//******************************************VOID   C_BEAM_SPL_AMP_GEN::set_tau_ang(const DOUBLE  &  ang)	//in{	its_tau_ang = ang;	limited_degrees(its_tau_ang);}//******************************************VOID   C_BEAM_SPL_AMP_GEN::set_rho_ang(const DOUBLE  &		ang)	//in{	its_rho_ang = ang;	limited_degrees(its_rho_ang);}//******************************************USHORT	C_BEAM_SPL_AMP_GEN::get_expected_degen(const USHORT  * 	m1x_p,		//inconst USHORT  *		m2x_p,		//inconst USHORT  * 	m1y_p,		//inconst USHORT  *		m2y_p)		//in{		TWO_MODE_FUN  two_fun(its_tau_mag, its_tau_ang, its_rho_ang);	USHORT	num_of_in_sts = its_nd_p->get_num_of_in_sts();		USHORT	degen = 0;	COMPLEX	zx(0, 0);	COMPLEX	zy(0, 0);	USHORT	n1x, n2x, n1y, n2y;	TM_COL_NUM	in_st;	if(m1y_p==0){ //scalar field case		for(n1x=0; n1x<= its_max_n_sum; n1x++){		for(n2x=0; n2x<= its_max_n_sum - n1x; n2x++){			for(in_st=0; in_st<num_of_in_sts; in_st++){							zx = two_fun.get_bs_amp(n1x, n2x, m1x_p[in_st], m2x_p[in_st]);				if(abs(zx)>=amps_floor){					degen++;					goto next_n1_n2_pair;							}			}			next_n1_n2_pair:;		}}	}else{ //vector field case		for(n1x=0; n1x<= its_max_n_sum; n1x++){		for(n1y=0; n1y<= its_max_n_sum - n1x; n1y++){		for(n2x=0; n2x<= (its_max_n_sum - n1y) - n1x; n2x++){		for(n2y=0; n2y<= ((its_max_n_sum - n2x) - n1y) - n1x; n2y++){			for(in_st=0; in_st<num_of_in_sts; in_st++){							zx = two_fun.get_bs_amp(n1x, n2x, m1x_p[in_st], m2x_p[in_st]);				if(abs(zx)>=amps_floor){					zy = two_fun.get_bs_amp(n1y, n2y, m1y_p[in_st], m2y_p[in_st]);  					if(abs(zy)>=amps_floor){						degen++;						goto next_n_set;					}							}			}			next_n_set:;		}}}}	}		return degen;}//******************************************BOOLEAN		C_BEAM_SPL_AMP_GEN::parents_are_canonical(){	if(!its_pi_wind_p->focus_nd_has_this_many_parents(2))return false;		enum {enter_st=0, likes1_st, likes2_st, reject_st};		//finite state machine for each in_nd 	//    likes1_st <---enter_st--->likes2_st	//						|	//						V	//					reject_st		STRINGY 	stringy;	USHORT		state = enter_st;	for(USHORT r=0; r<2; r++){		USHORT 		in_nd = its_nd_p->get_in_nds()[r];		NODE  * 	in_nd_p = its_net_p->get_nd_ptr(in_nd);			for(USHORT s=0; s<in_nd_p->get_degen(); s++){			stringy = in_nd_p->get_st_name(s);			switch(state){				case enter_st:					if(stringy.is_ushort()){						state = likes1_st;					}else if(stringy.is_ushort_pair()){						state = likes2_st;					}else{						state = reject_st;						goto stop_looking;					}					break;				case likes1_st:					if(stringy.is_ushort()){						//state = likes1_st;					}else{						state = reject_st;						goto stop_looking;					}					break;				case likes2_st:					if(stringy.is_ushort_pair()){						//state = likes2_st;					}else{						state = reject_st;						goto stop_looking;					}					break;			}		}		stop_looking:;		if(state==reject_st){			//my_gen_alert can take a string of at most 255 characters!!!!			my_gen_alert("Inadmissible parents. This button works only if parents of focus node are all of Type_1 or all of Type_2. If n1 and n2 are non-neg. integers, Type_1 nodes have states n1, Type_2 have states (n1, n2).");		 	return false;					}			}	its_type = (state==likes1_st?scalar_bs:vector_bs);	return true;		}//******************************************BOOLEAN		C_BEAM_SPL_AMP_GEN::dialog_entries_are_legal(Str255 tau_mag_sq_pstr,		//inStr255 tau_ang_pstr,		//inStr255 rho_ang_pstr,		//inStr255 max_n_sum_pstr)		//in{	DOUBLE 	db;	if(!STRINGY(tau_mag_sq_pstr).is_double(db)){		//couldn't get the character ^ to print		my_gen_alert("Your entry for |t| must be a real number.");		return false;	}else{		if(db>1 || db<0){			my_gen_alert("Must have 0 <= |t| <= 1.");			return false;		}	}		if(!STRINGY(tau_ang_pstr).is_double()){		my_gen_alert("Your entry for phase(t) must be a real number.");		return false;	}		if(!STRINGY(rho_ang_pstr).is_double()){		my_gen_alert("Your entry for phase(r) must be a real number.");		return false;	}	if(!STRINGY(max_n_sum_pstr).is_ushort()){		my_gen_alert("Your entry for maximum output number must be a non-negative integer.");		return false;	}		return true;}//******************************************VOID	C_BEAM_SPL_AMP_GEN::fill_trans_mat_and_st_names_of_nd(){	/*	notation: transition element < n1, n2 || m1, m2>  	where n1 scalar or n1 = (n1x, n1y), etc.		m1->/--\->n2		|  |		m2->\--/->n1  		counter-clockwise: n1, n2, m1, m2		mnemonic: 	n1 and n2 are the new beams, hence the n.		 0     1         nw    ne		  m2  m1		  |   |		  V   V		 /-----\	    |   X   |	     \-----/		  |   |		  V   V		 n1   n2		 sw   se		 3     2 */  	USHORT 	in_row, port;	USHORT  in_row_of_port[2];	for(in_row=0; in_row<2; in_row++){		for(port=0; port<2; port++){			if(((BEAM_SPL *)its_nd_p)->get_port_guest(port)==its_nd_p->get_in_nds()[in_row]){				in_row_of_port[port] = in_row;			}		}	}	  	TM_COL_NUM 		in_st, num_of_in_sts;           	USHORT  		in_nd, nd_st;	STRINGY			sgy;	USHORT			m1x, m2x, m1y, m2y;	STRETCH_OR_FOLD 	sof_in(its_nd_p->get_in_nd_degens());	//can't use VECTOR class for next vectors 	//because VECTOR can have at most max_ushort elements.	num_of_in_sts = its_nd_p->get_num_of_in_sts();	ThrowIf_(num_of_in_sts==0);	USHORT  * 	m1x_p = new USHORT[num_of_in_sts];//new[]	//delete: in this method	ThrowIfNil_(m1x_p);	USHORT  * 	m2x_p = new USHORT[num_of_in_sts];//new[]	//delete: in this method	ThrowIfNil_(m2x_p);		USHORT  * 	m1y_p = 0;	USHORT  *   m2y_p = 0;	if(its_type==vector_bs){		m1y_p = new USHORT[num_of_in_sts];//new[]		//delete: in this method		ThrowIfNil_(m1y_p);		m2y_p = new USHORT[num_of_in_sts];//new[]		//delete: in this method		ThrowIfNil_(m2y_p);	}			for(in_st = 0; in_st< its_nd_p->get_num_of_in_sts(); in_st++){		for(in_row=0; in_row<2; in_row++){			in_nd = its_nd_p->get_in_nds()[in_row];			nd_st = sof_in.vec_label(in_st)[in_row];			sgy = its_net_p->get_nd_ptr(in_nd)->get_st_name(nd_st);			if(its_type==scalar_bs){				if(in_row==in_row_of_port[1]){					sgy.is_ushort(m1x);					m1x_p[in_st] = m1x;				}else{					sgy.is_ushort(m2x);					m2x_p[in_st] = m2x;				}			}else{				if(in_row==in_row_of_port[1]){					sgy.is_ushort_pair(m1x, m1y);					m1x_p[in_st] = m1x;					m1y_p[in_st] = m1y;				}else{					sgy.is_ushort_pair(m2x, m2y);					m2x_p[in_st] = m2x;					m2y_p[in_st] = m2y;				}			}							}	}		USHORT	expected_degen = get_expected_degen(m1x_p, m2x_p, m1y_p, m2y_p);	if(expected_degen!=0){		its_net_p->set_degen_of_a_nd(its_pi_wind_p->get_nd(), expected_degen);		TWO_MODE_FUN  	two_fun(its_tau_mag, its_tau_ang, its_rho_ang);		((BEAM_SPL *)its_nd_p)->obey_amp_gen(its_max_n_sum, two_fun, m1x_p, m2x_p, m1y_p, m2y_p);	}else{		amp_generator_found_no_states_alert();	}		delete [] m1x_p;	m1x_p=0;	delete [] m2x_p;	m2x_p=0;	if(its_type==vector_bs){		delete [] m1y_p;		m1y_p=0;		delete [] m2y_p;		m2y_p=0;	}		}//******************************************BOOLEAN		C_BEAM_SPL_AMP_GEN::talk(){// this is a trivial generalization of UModalDialogs::AskForOneNumber	if(!parents_are_canonical()){		return false;	}			StDialogHandler		d_handler(bs_window_rid, its_pi_wind_p);//SuperCommander declared	LWindow  *			dialog_p = d_handler.GetDialog();		LEditField  * 	tau_mag_sq_efield_p = 		(LEditField  *)dialog_p->FindPaneByID(bs_tau_mag_sq_efield_rid);	LEditField  * 	tau_ang_efield_p = 		(LEditField  *)dialog_p->FindPaneByID(bs_tau_ang_efield_rid);			LEditField  * 	rho_ang_efield_p = 		(LEditField  *)dialog_p->FindPaneByID(bs_rho_ang_efield_rid);	LEditField  * 	max_n_sum_efield_p = 		(LEditField  *)dialog_p->FindPaneByID(bs_max_n_sum_efield_rid);			//SetValue() only works for efields with integer values		LStr255 	x_str;		x_str.Assign( pow( get_tau_mag(), 2), FIXEDDECIMAL, 6);	tau_mag_sq_efield_p->SetDescriptor(x_str);	x_str.Assign( get_tau_ang(), FIXEDDECIMAL, 6);		tau_ang_efield_p->SetDescriptor(x_str);		x_str.Assign( get_rho_ang(), FIXEDDECIMAL, 6);		rho_ang_efield_p->SetDescriptor(x_str);	max_n_sum_efield_p->SetValue(get_max_n_sum());			tau_mag_sq_efield_p->SelectAll();	dialog_p->SetLatentSub(tau_mag_sq_efield_p);	dialog_p->Show();		while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_Cancel:				return false;				break;			case msg_OK:				LStr255  	tau_mag_sq_str;				LStr255		tau_ang_str;				LStr255	 	rho_ang_str;				LStr255		max_n_sum_str; 				tau_mag_sq_efield_p->GetDescriptor(tau_mag_sq_str);				tau_ang_efield_p->GetDescriptor(tau_ang_str);				rho_ang_efield_p->GetDescriptor(rho_ang_str);				//It's important to check max_n_sum_str.				//Something illegal could be pasted into the max_n_sum field.				//Key filters won't prevent this, but				//checking max_n_sum_str can detect it.				max_n_sum_efield_p->GetDescriptor(max_n_sum_str);				if(!dialog_entries_are_legal(tau_mag_sq_str, tau_ang_str, rho_ang_str, max_n_sum_str)){					// don't return yet					break;				}										set_tau_mag(sqrt(double_t(tau_mag_sq_str)));				set_tau_ang(double_t(tau_ang_str));				set_rho_ang(double_t(rho_ang_str));				set_max_n_sum(SInt32(max_n_sum_str));				UCursor::SetTheCursor(watchCursor);								fill_trans_mat_and_st_names_of_nd();				UCursor::InitTheCursor();								its_pi_wind_p->ListenToMessage(msg_pi_all_act_but, nil);				its_pi_wind_p->set_nd_always(its_pi_wind_p->get_nd());				return true;				break;		}	}}	