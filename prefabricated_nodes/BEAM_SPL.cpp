#include "BEAM_SPL.h"#include "GLOBAL_FUN.h"#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	#include "C_BEAM_SPL_AMP_GEN.h"	#include "StCPTstate.h"#endif //_mac_gui_app \\............................................//#pragma mark --creation/destruction--//******************************************BEAM_SPL::BEAM_SPL(){}//******************************************BEAM_SPL::~BEAM_SPL(){}#pragma mark ----used only with macgui----#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.#pragma mark --creation/destruction--//******************************************VOID	BEAM_SPL::init_port_locs(){	DOUBLE  dd = default_mask_rad/sqrt(2.);	its_port_locs_p[0].v = its_port_locs_p[1].v = its_center.v - dd;	its_port_locs_p[2].v = its_port_locs_p[3].v = its_center.v + dd;	its_port_locs_p[0].h = its_port_locs_p[3].h = its_center.h - dd;	its_port_locs_p[1].h = its_port_locs_p[2].h = its_center.h + dd;}//******************************************BEAM_SPL::BEAM_SPL(const Point  &  	m_down_pt)		//in	:NODE(m_down_pt),	its_icon_dir(0){ 	init_port_locs();	for(USHORT i=0; i<4 ;i++){ 		its_port_guests_p[i]= -1;			} }#pragma mark --port related--//******************************************BOOLEAN 	BEAM_SPL::pt_is_in_greeting_cir_of_avail_d_port(const Point  &  	pt,			//inUSHORT  &  			sub_nd_id)	//out{ 	C_CIRCLE 	greeting_cir;	greeting_cir.its_radius =  port_greeting_rad;	for(USHORT i=0; i<2; i++){		greeting_cir.its_center= its_port_locs_p[i];		if((its_port_guests_p[i]<0) && greeting_cir.pt_is_in(pt)){			sub_nd_id = i;			return true;		}	}	return false;}//******************************************BOOLEAN 	BEAM_SPL::pt_is_in_greeting_cir_of_avail_s_port(const Point  &  	pt,			//in	USHORT  &  			sub_nd_id)	//out	{ 	C_CIRCLE 	greeting_cir;	greeting_cir.its_radius =  port_greeting_rad;	for(USHORT i=2; i<4; i++){		greeting_cir.its_center= its_port_locs_p[i];		if( (its_port_guests_p[i]<0) && greeting_cir.pt_is_in(pt) ){			sub_nd_id = i;			return true;		}	}	return false;}//******************************************VOID 	BEAM_SPL::remove_nd_from_all_port_glists(USHORT 	g_nd_id)		//in{	for(USHORT i=0; i<4; i++){		if(its_port_guests_p[i] == g_nd_id)its_port_guests_p[i]=-1;	} }//******************************************VOID  	BEAM_SPL::renumber_nds_of_port_glists(const UI_MAP  &		map)	//in{	for(USHORT i=0; i<4; i++){		if(its_port_guests_p[i] != -1){			its_port_guests_p[i]=map.its_newfo[its_port_guests_p[i]];		}	} }#pragma mark --drawing--//******************************************VOID	BEAM_SPL::draw(){//drawer	its_efield_p->Draw(0);	if(!its_efield_p->GetSuperView()->FocusDraw())return;	if(its_state_num_for_cap!=max_ushort) draw_state_cap();		StCPTstate		saved_st(true, true, false);	saved_st.Normalize();		Rect r;	::SetRect(&r, 	its_center.h -default_mask_rad, its_center.v -default_mask_rad, 					its_center.h +default_mask_rad, its_center.v +default_mask_rad);					 	//first paint yellow mask if there is color: 	if(UEnvironment::HasFeature(env_SupportsColor)){			::RGBForeColor(&C_COLORS::its_yellow);		::PaintOval(&r);		::RGBForeColor(&C_COLORS::its_black);	}		//now draw black rim:		::FrameOval(&r);	//finally, draw crossed arrows and bisecting line		C_ARROW_DRAWER   cupid(its_efield_p->GetSuperView(), 6, 30); //(view, arrowhead's length, halfwidth)		limited_degrees(its_icon_dir);	    DOUBLE theta= my_pi/180 * its_icon_dir; //theta gives icon_dir in radians	DOUBLE rad = default_mask_rad-2;// minus two to avoid glitch (stepping-beyond-boundary)	        SInt16 ssr= nearest_int16(rad*sin(my_pi/4 +theta));    SInt16 ccr= nearest_int16(rad*cos(my_pi/4 +theta));        SInt16 ssm= nearest_int16(rad*sin(theta));     SInt16 ccm= nearest_int16(rad*cos(theta));    SInt16 ssl= nearest_int16(rad*sin(my_pi/4 -theta));    SInt16 ccl= nearest_int16(rad*cos(my_pi/4 -theta));	Point  init_pt, fin_pt;	    	::MoveTo(its_center.h + ssm , its_center.v  -ccm );	::LineTo(its_center.h - ssm , its_center.v  +ccm );	::SetPt(&init_pt, its_center.h - ssl , its_center.v - ccl );	::SetPt(&fin_pt,  its_center.h + ssl , its_center.v + ccl );     cupid.sketch(init_pt, fin_pt);    	::SetPt(&init_pt, its_center.h + ssr , its_center.v - ccr );	::SetPt(&fin_pt,  its_center.h - ssr , its_center.v + ccr );     cupid.sketch(init_pt, fin_pt);}#pragma mark --move--//******************************************VOID	BEAM_SPL::move_by(const Point  &  	delta)		//in{	undraw();	if(its_is_selected) undraw_sel_handles();			its_center.h += delta.h;	its_center.v += delta.v;	its_efield_p->MoveBy(SInt32(delta.h), SInt32(delta.v), false);		for(USHORT i=0; i<4; i++){		its_port_locs_p[i].h += delta.h;			its_port_locs_p[i].v += delta.v;	}		draw();	if(its_is_selected) draw_sel_handles();}#pragma mark --rotate--/* This function no good because the errors feedback and each time you use it//******************************************VOID	BEAM_SPL::rotate_rim_pt(Point  &  	pt,			//i-oSInt16 		ang)		//in{//pt is  both input and output	DOUBLE	 cc = cos(my_pi/180 * ang);	DOUBLE	 ss = sin(my_pi/180 * ang);	DOUBLE  x, y;	x = its_center.h + cc*(pt.h -its_center.h) - ss*(pt.v -its_center.v);	y = its_center.v + ss*(pt.h -its_center.h) + cc*(pt.v -its_center.v);	pt.h = nearest_int16(x);	pt.v = nearest_int16(y);}*///******************************************VOID	BEAM_SPL::refresh_port_locs(){    DOUBLE theta= my_pi/180 * its_icon_dir; //theta gives icon_dir in radians	DOUBLE rad = default_mask_rad;        SInt16	ssr= nearest_int16(rad*sin(my_pi/4 +theta));    SInt16	ccr= nearest_int16(rad*cos(my_pi/4 +theta));    SInt16	ssl= nearest_int16(rad*sin(my_pi/4 -theta));    SInt16	ccl= nearest_int16(rad*cos(my_pi/4 -theta));	::SetPt(&its_port_locs_p[0], its_center.h - ssl , its_center.v - ccl );	::SetPt(&its_port_locs_p[2], its_center.h + ssl , its_center.v + ccl ); 	::SetPt(&its_port_locs_p[1], its_center.h + ssr , its_center.v - ccr );	::SetPt(&its_port_locs_p[3], its_center.h - ssr , its_center.v + ccr ); }//******************************************VOID	BEAM_SPL::rotate(){	its_icon_dir += the_rot_ang;	limited_degrees(its_icon_dir);/*	for(USHORT i=0; i<4; i++){		rotate_rim_pt(its_port_locs_p[i], the_rot_ang);	}*/	refresh_port_locs();	draw();		}//******************************************VOID	BEAM_SPL::set_icon_dir(SInt16	icon_dir)		//in{	SInt16  ang= icon_dir;	limited_degrees(ang);	USHORT  count = ang/the_rot_ang; // remainder is thrown away		its_icon_dir = count*the_rot_ang;		refresh_port_locs();	}#pragma mark --amp gen--//******************************************VOID	BEAM_SPL::call_amp_gen(QB_NET *  net_p, 		//inC_PI_WIND * pi_wind_p)	//in{	if(its_amp_gen_p==0){//set to nil in NODE::NODE() and NODE::NODE(const Point  & center)		its_amp_gen_p = new C_BEAM_SPL_AMP_GEN(this, net_p, pi_wind_p);		//delete:  by NODE::~NODE()						//Created first time it is used		ThrowIfNil_(its_amp_gen_p );	}	its_amp_gen_p->talk();}//******************************************VOID	BEAM_SPL::obey_amp_gen(USHORT	max_n_sum,					//inconst TWO_MODE_FUN  & two_fun,	//inconst USHORT  * 	m1x_p,			//inconst USHORT  *		m2x_p,			//inconst USHORT  * 	m1y_p,			//inconst USHORT  *		m2y_p)			//in{	empty_trans_mat();		SHORT 			row = -1;	COMPLEX			zx(0, 0);	COMPLEX			zy(0, 0);	USHORT			n1x, n2x, n1y, n2y;	USHORT			nx_sum, n1_sum, n2_sum;	TM_COL_NUM		in_st;	BOOLEAN 		tm_row_starting;	if(m1y_p==0){//scalar field case		for(nx_sum=0; nx_sum<=max_n_sum; nx_sum++){ // nx_sum = n1x + n2x		for(n2x=0; n2x<= nx_sum; n2x++){			n1x = nx_sum - n2x;			tm_row_starting = true;			for(in_st=0; in_st<its_num_of_in_sts; in_st++){							zx = two_fun.get_bs_amp(n1x, n2x, m1x_p[in_st], m2x_p[in_st]);				if(abs(zx)>=amps_floor){					if(tm_row_starting){						row++;						its_st_names[row] =  STRINGY("(" ) &&  n1x  && "," && n2x && ")";						tm_row_starting=false;					}					its_tm_amps.set_ele(row, in_st, zx);				}			}		}}	}else{//vector field case		for(n1_sum=0; n1_sum<= max_n_sum; n1_sum++){//n1_sum = n1x + n1y		for(n1y=0; n1y<= n1_sum; n1y++){			n1x = n1_sum - n1y;			for(n2_sum=0; n2_sum<= max_n_sum - n1_sum; n2_sum++){		for(n2y=0; n2y<= n2_sum; n2y++){			n2x = n2_sum - n2y;			tm_row_starting = true;			for(in_st=0; in_st<its_num_of_in_sts; in_st++){							zx = two_fun.get_bs_amp(n1x, n2x, m1x_p[in_st], m2x_p[in_st]);				if(abs(zx)>=amps_floor){					zy = two_fun.get_bs_amp(n1y, n2y, m1y_p[in_st], m2y_p[in_st]);  					if(abs(zy)>=amps_floor){						if(tm_row_starting){							row++;							its_st_names[row] =  STRINGY("((" ) &&  n1x  && "," && n1y && "),(" &&  n2x  && "," && n2y && "))";							tm_row_starting=false;						}						its_tm_amps.set_ele(row, in_st, zx*zy);					}							}			}		}}}}	}}// *********************************************#endif //_mac_gui_app \\............................................//