#include 	"C_PHASOR_YZER_AMP_GEN.h"#include 	"QB_NET.h"#include 	"C_PI_WIND.h"#include 	"EXCEPTIONS.h"//******************************************C_PHASOR_YZER_AMP_GEN::C_PHASOR_YZER_AMP_GEN(PHASOR_ANALYZER	type,		//inNODE * 			nd_p,		//inQB_NET * 		net_p,		//inC_PI_WIND * 	pi_wind_p)	//in	:C_AMP_GEN(nd_p, net_p, pi_wind_p),	its_type(type),	its_theta(0),	its_max_m_sum(0){}//******************************************VOID   C_PHASOR_YZER_AMP_GEN::set_theta(const DOUBLE  &		theta)	//in{		its_theta = theta;	limited_degrees(its_theta);}//******************************************USHORT	C_PHASOR_YZER_AMP_GEN::get_expected_degen(const USHORT  * 	mx_p,		//inconst USHORT  *		my_p)		//in{	USHORT	num_of_in_sts = its_nd_p->get_num_of_in_sts();		TWO_MODE_FUN  two_fun(its_theta);			TM_COL_NUM	in_st;	USHORT	sum, nx, ny;	its_max_m_sum=0;	USHORT	degen = 0;	COMPLEX	z(0, 0);		switch(its_type){			case k_pol:				for(in_st=0; in_st<num_of_in_sts; in_st++){					sum = mx_p[in_st] + my_p[in_st];						if(sum > its_max_m_sum) its_max_m_sum = sum;				}														for(nx=0; nx<= its_max_m_sum; nx++){				for(ny=0; ny<= its_max_m_sum - nx; ny++){				for(USHORT  nloss=0; nloss<= its_max_m_sum - nx - ny; nloss++){					for(in_st=0; in_st<num_of_in_sts; in_st++){									z = two_fun.get_pol_amp(nx, ny, nloss, mx_p[in_st], my_p[in_st]);						if(abs(z)>=amps_floor){							degen++;							break;									}					}				}}}				break;			case k_pol_rot:				for(in_st=0; in_st<num_of_in_sts; in_st++){					sum = mx_p[in_st] + my_p[in_st];						if(sum > its_max_m_sum) its_max_m_sum = sum;				}								for(nx=0; nx<= its_max_m_sum; nx++){				for(ny=0; ny<= its_max_m_sum - nx; ny++){					for(in_st=0; in_st<num_of_in_sts; in_st++){									z = two_fun.get_bs_amp(nx, ny, mx_p[in_st], my_p[in_st]);						if(abs(z)>=amps_floor){							degen++;							break;									}					}				}}				break;		}//switch				return degen;}//******************************************BOOLEAN		C_PHASOR_YZER_AMP_GEN::parents_are_canonical(){	if(!its_pi_wind_p->focus_nd_has_this_many_parents(1))return false;				USHORT 		in_nd = its_nd_p->get_in_nds()[0];	NODE  * 	in_nd_p = its_net_p->get_nd_ptr(in_nd);	for(USHORT s=0; s<in_nd_p->get_degen(); s++){		if(!in_nd_p->get_st_name(s).is_ushort_pair()){			my_gen_alert("Inadmissible parents. This button works only if parents of focus node are all of Type_2. If nx and ny are non-negative integers, Type_2 nodes have states (nx, ny).");		 	return false;					}	}		return true;}//******************************************BOOLEAN		C_PHASOR_YZER_AMP_GEN::dialog_entries_are_legal(Str255 	theta)		//in{	DOUBLE 	db;	if(!STRINGY(theta).is_double(db)){		my_gen_alert("Your entry for theta must be a real number.");		return false;	}			return true;}//******************************************VOID	C_PHASOR_YZER_AMP_GEN::fill_trans_mat_and_st_names_of_nd(){/*	notation: transition element < nx, ny, nloss || mx, my>	*/  	USHORT 			in_nd = its_nd_p->get_in_nds()[0]; 	NODE  * 		in_nd_p = its_net_p->get_nd_ptr(in_nd); 	USHORT			in_nd_degen = in_nd_p->get_degen();           	USHORT			in_nd_st;	ThrowIf_(in_nd_degen==0);	USHORT  * 	mx_p = new USHORT[in_nd_degen];//new[]	//delete: in this method	ThrowIfNil_(mx_p);	USHORT  * 	my_p = new USHORT[in_nd_degen];//new[]	//delete: in this method		ThrowIfNil_(my_p);	for(in_nd_st = 0; in_nd_st< in_nd_degen; in_nd_st++){		in_nd_p->get_st_name(in_nd_st).is_ushort_pair(mx_p[in_nd_st], my_p[in_nd_st]);	}		USHORT	expected_degen = get_expected_degen(mx_p, my_p);	if(expected_degen!=0){		its_net_p->set_degen_of_a_nd(its_pi_wind_p->get_nd(), expected_degen);		switch(its_type){			case k_pol:				((POLARIZER *)its_nd_p)->obey_amp_gen(its_theta, its_max_m_sum, mx_p, my_p);				break;			case k_pol_rot:				((POL_ROTATOR *)its_nd_p)->obey_amp_gen(its_theta, its_max_m_sum, mx_p, my_p);				break;		}	}else{		amp_generator_found_no_states_alert();	}		delete [] mx_p;	delete [] my_p;}//******************************************BOOLEAN		C_PHASOR_YZER_AMP_GEN::talk(){// this is a trivial generalization of UModalDialogs::AskForOneNumber	if(!parents_are_canonical()){		return false;	}	ResIDT	wind_rid, efield_rid;	switch(its_type){		case k_pol_rot:			wind_rid = pol_rot_window_rid;			efield_rid = pol_rot_efield_rid;			break;		case k_pol:			wind_rid = pol_window_rid;			efield_rid = pol_efield_rid;			break;	}	 			StDialogHandler		d_handler(wind_rid, its_pi_wind_p);//SuperCommander declared	LWindow  *			dialog_p = d_handler.GetDialog();		LEditField  * 	efield_p = 		(LEditField  *)dialog_p->FindPaneByID(efield_rid);			//SetValue() only works for efields with integer values		LStr255 	x_str;		x_str.Assign( its_theta, FIXEDDECIMAL, 6);	efield_p->SetDescriptor(x_str);			efield_p->SelectAll();	dialog_p->SetLatentSub(efield_p);	dialog_p->Show();		while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_Cancel:				return false;				break;			case msg_OK:				LStr255	 	theta_str; 				efield_p->GetDescriptor(theta_str);				if(!dialog_entries_are_legal(theta_str)){					// don't return yet					break;				}				set_theta(double_t(theta_str));				UCursor::SetTheCursor(watchCursor);				fill_trans_mat_and_st_names_of_nd();				UCursor::InitTheCursor();								its_pi_wind_p->ListenToMessage(msg_pi_all_act_but, nil);				its_pi_wind_p->set_nd_always(its_pi_wind_p->get_nd());				return true;				break;		}	}}	