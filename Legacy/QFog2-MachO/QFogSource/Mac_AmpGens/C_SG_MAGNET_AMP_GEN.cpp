#include 	"C_SG_MAGNET_AMP_GEN.h"#include 	"C_SG_MAGNET_TABLE.h"#include 	"QB_NET.h"#include 	"C_PI_WIND.h"#include 	"EXCEPTIONS.h"//******************************************C_SG_MAGNET_AMP_GEN::C_SG_MAGNET_AMP_GEN(SG_MAGNET * 	nd_p,		//inQB_NET *		net_p,		//in		C_PI_WIND * 	pi_wind_p)	//in	:C_AMP_GEN(nd_p, net_p, pi_wind_p),	its_magnetic_theta(0),	its_magnetic_phi(0){}//******************************************C_SG_MAGNET_AMP_GEN::~C_SG_MAGNET_AMP_GEN(){}//******************************************VOID 	C_SG_MAGNET_AMP_GEN::set_magnetic_theta(const DOUBLE  &		theta)	//in{	its_magnetic_theta=theta;	limited_degrees(its_magnetic_theta);}//******************************************VOID 	C_SG_MAGNET_AMP_GEN::set_magnetic_phi(const DOUBLE  &		phi)	//in{	its_magnetic_phi=phi;	limited_degrees(its_magnetic_phi);}//******************************************VOID	C_SG_MAGNET_AMP_GEN::resize(USHORT  len){	its_spins.resize(0, len); 	its_thetas.resize(0, len); 	its_phis.resize(0, len);}//******************************************VOID 	C_SG_MAGNET_AMP_GEN::resize(const VECTOR<USHORT>  & 	in_nd_types)	//in{	USHORT len = in_nd_types.get_len();	its_spins.resize(0, len);	//spins +1, -1 are only possible for type 1 nodes	//and spin 0 is only possible for type 2 nodes. 	for(USHORT in_row=0; in_row<len; in_row++){		if(in_nd_types[in_row]==1 && its_spins[in_row]==0)its_spins[in_row]=-1;		if(in_nd_types[in_row]==2 && its_spins[in_row]!=0)its_spins[in_row]=0;	}	 	its_thetas.resize(0, len); 	its_phis.resize(0, len);}//******************************************VOID	C_SG_MAGNET_AMP_GEN::extract_at(USHORT  loc){	its_spins.extract_at(loc);	its_thetas.extract_at(loc);	its_phis.extract_at(loc);}//******************************************VOID	C_SG_MAGNET_AMP_GEN::reorder(const UI_MAP  &		map)		//in{	USHORT	num_of_in_nds = its_spins.get_len();	if(num_of_in_nds==0)return;	ThrowIf_(num_of_in_nds!=map.its_oldfn.get_len());		if(map.is_identity_map())return;	USHORT	i, old_i;	VECTOR<SHORT>	saved_spins(its_spins);	VECTOR<DOUBLE>	saved_thetas(its_thetas);	VECTOR<DOUBLE> 	saved_phis(its_phis);	for(i=0; i< num_of_in_nds; i++){		old_i = map.its_oldfn[i];		its_spins[i] = saved_spins[old_i];		its_thetas[i] = saved_thetas[old_i];		its_phis[i] = saved_phis[old_i];	}}	//******************************************COMPLEX		C_SG_MAGNET_AMP_GEN::sg_magnet_amp(USHORT 	n_neg,		//inUSHORT 	n_pos,		//inUSHORT 	in_sum,		//inUSHORT 	in_row,		//inSHORT 	in_spin)	//in{	//notation: transition element < (n_neg, n_pos) | in_sum, in_row, in_spin>	//in_sum = the number of incoming particles.	//Only matrix elements with in_sum=1 are non-zero.	//in_row = when in_sum=1, the row of the in node with the particle.	//in_spin = when in_sum=1, the spin (+1 or -1) of the  particle.		//The outgoing arrow has 2 occupation numbers:  n_neg and n_pos	//All occupation numbers are either 0 or 1.	//States with n_neg + n_pos>1  are given zero amplitude.	//The outgoing states are (n-, n+) = (0, 0), (0, 1), (1, 0) 	if( (n_pos + n_neg==0)&&(in_sum==0) ) return COMPLEX(1, 0);	if( (n_pos + n_neg==1)&&(in_sum==1) ){		SHORT 	out_spin=(n_pos==1?1:-1);		DOUBLE	cp = cos(my_pi/180*its_magnetic_theta/2);		DOUBLE	sp = sin(my_pi/180*its_magnetic_theta/2);		DOUBLE	c = cos(my_pi/180*its_thetas[in_row]/2);		DOUBLE	s = sin(my_pi/180*its_thetas[in_row]/2);				DOUBLE	delta_phi = my_pi/180*(its_magnetic_phi - its_phis[in_row]);		COMPLEX	ph_fac = exp(COMPLEX(0, delta_phi/2) );		if(out_spin==1 && in_spin==1){			return cp*c*ph_fac + sp*s*conj(ph_fac);		}else if(out_spin==-1 && in_spin==-1){			return sp*s*ph_fac + cp*c*conj(ph_fac);		}else if(out_spin==1 && in_spin==-1){			return -cp*s*ph_fac + sp*c*conj(ph_fac);		}else if(out_spin==-1 && in_spin==1){			return -sp*c*ph_fac + cp*s*conj(ph_fac);		}	}	return COMPLEX(0, 0);}//******************************************USHORT	C_SG_MAGNET_AMP_GEN::get_expected_degen(const USHORT  * 	in_sums_p,		//inconst USHORT  * 	in_rows_p,		//inconst SHORT  * 		in_spins_p)		//in{	USHORT	num_of_in_sts = its_nd_p->get_num_of_in_sts();	USHORT	degen = 0;	COMPLEX	z(0, 0);	for(USHORT  n1=0; n1<= 1; n1++){ // n1 = n_neg, n2 = n_pos		for(USHORT  n2=0; n2<= 1 - n1; n2++){			for(TM_COL_NUM in_st=0; in_st<num_of_in_sts; in_st++){							z = sg_magnet_amp(n1, n2, in_sums_p[in_st], in_rows_p[in_st], in_spins_p[in_st]);				if(abs(z)>=amps_floor){					degen++;					goto next_n1_n2_pair;							}			}			next_n1_n2_pair:;		}	}	return degen;}//******************************************BOOLEAN		C_SG_MAGNET_AMP_GEN::parents_are_canonical(VECTOR<USHORT>  &	in_nd_types)		//out{	if(!its_pi_wind_p->focus_nd_has_this_many_parents(max_ushort))return false;		enum {enter_st=0, likes1_st, likes2_st, reject_st};		//finite state machine for each in_nd 	//    likes1_st <---enter_st--->likes2_st	//						|	//						V	//					reject_st	//can also go from 	//likes1_st -> reject_st	//likes2_st -> reject_st 		STRINGY 	stringy;	for(USHORT r=0; r<its_nd_p->get_num_of_in_nds(); r++){		USHORT 		in_nd = its_nd_p->get_in_nds()[r];		NODE  * 	in_nd_p = its_net_p->get_nd_ptr(in_nd);		USHORT		state = enter_st;		USHORT		n1, n2;		USHORT		in_nd_degen = in_nd_p->get_degen();		for(USHORT s=0; s<in_nd_degen; s++){			stringy = in_nd_p->get_st_name(s);			switch(state){				case enter_st:					if(stringy=="0" || stringy=="1"){						state = likes1_st;					}else if(stringy.is_ushort_pair(n1, n2) && (n1+n2)<=1){						state = likes2_st;					}else{						state = reject_st;						goto stop_looking;					}					break;				case likes1_st:					if(stringy=="0" || stringy=="1"){						//state = likes1_st;					}else{						state = reject_st;						goto stop_looking;					}					break;				case likes2_st:					if(stringy.is_ushort_pair(n1, n2) && (n1+n2)<=1){						//state = likes2_st;					}else{						state = reject_st;						goto stop_looking;					}					break;			}		}		in_nd_types[r]= (state==likes1_st?1:2);		stop_looking:;		if(state==reject_st){			my_gen_alert("Inadmissible parents. This button works only if each parent node of the magnet is of Type_1 or Type_2. Type_1 nodes have 2 states: 0, 1. Type_2 nodes have 3 states: (0, 0), (0, 1), (1, 0).");		 	return false;					}			}	return true;}//******************************************BOOLEAN		C_SG_MAGNET_AMP_GEN::dialog_entries_are_legal(Str255 	theta,		//inStr255  phi)		//in{	DOUBLE 	db;	if(!STRINGY(theta).is_double(db)){		my_gen_alert("Your entry for theta must be a real number.");		return false;	}	if(!STRINGY(phi).is_double(db)){		my_gen_alert("Your entry for phi must be a real number.");		return false;	}			return true;}//******************************************VOID	C_SG_MAGNET_AMP_GEN::fill_trans_mat_and_st_names_of_nd(){	TM_COL_NUM 	num_of_in_sts = its_nd_p->get_num_of_in_sts();	USHORT	num_of_in_nds = its_nd_p->get_num_of_in_nds();	STRETCH_OR_FOLD 	sof_in(its_nd_p->get_in_nd_degens());	TM_COL_NUM	in_st;	USHORT	 	in_row;           	USHORT  	in_nd, nd_st;	STRINGY		stringy;	USHORT 		m1, m2;		//can't use VECTOR class for next vectors 	//because VECTOR can have at most max_ushort elements.	ThrowIf_(num_of_in_sts==0);		USHORT	 *   in_sums_p = new USHORT [num_of_in_sts];//new[]	//delete: in this method	ThrowIfNil_(in_sums_p);	USHORT	 *   in_rows_p = new USHORT [num_of_in_sts];//new[]	//delete: in this method	ThrowIfNil_(in_rows_p);	SHORT	 *   in_spins_p = new SHORT [num_of_in_sts];//new[]	//delete: in this method	ThrowIfNil_(in_spins_p);	for(in_st = 0; in_st<num_of_in_sts; in_st++){		in_sums_p[in_st] = 0;		in_rows_p[in_st] = 0;		in_spins_p[in_st] = 0;		for(in_row=0; in_row<num_of_in_nds; in_row++){			in_nd = its_nd_p->get_in_nds()[in_row];			nd_st = sof_in.vec_label(in_st)[in_row];			stringy = its_net_p->get_nd_ptr(in_nd)->get_st_name(nd_st);			if(stringy.is_ushort(m1)){				in_sums_p[in_st] += m1;				if(m1==1){					in_rows_p[in_st]=in_row;					in_spins_p[in_st] = get_spin(in_row);				}			}			if(stringy.is_ushort_pair(m1, m2)){				in_sums_p[in_st] += (m1+m2);				if( (m1+m2)==1){					in_rows_p[in_st]=in_row;					in_spins_p[in_st] = (m2==1?1:-1);				}			}						}	}	USHORT	expected_degen = get_expected_degen(in_sums_p, in_rows_p, in_spins_p);	if(expected_degen!=0){		its_net_p->set_degen_of_a_nd(its_pi_wind_p->get_nd(), expected_degen);		((SG_MAGNET *)its_nd_p)->obey_amp_gen(in_sums_p, in_rows_p, in_spins_p);	}else{		amp_generator_found_no_states_alert();	}			delete [] in_sums_p;	in_sums_p=0;	delete [] in_rows_p;	in_rows_p=0;	delete [] in_spins_p;	in_spins_p=0;}//******************************************BOOLEAN		C_SG_MAGNET_AMP_GEN::talk(){// this is a trivial generalization of UModalDialogs::AskForOneNumber	VECTOR<USHORT>	in_nd_types(0, its_nd_p->get_num_of_in_nds());	if(!parents_are_canonical(in_nd_types)){				return false;	}	resize(in_nd_types);			StDialogHandler		d_handler(sg_magnet_window_rid, its_pi_wind_p);//SuperCommander declared	LWindow  *		dialog_p = d_handler.GetDialog();	LEditField  * 	theta_efield_p = 		(LEditField  *)dialog_p->FindPaneByID(sg_magnet_theta_efield_rid);	LEditField  * 	phi_efield_p = 		(LEditField  *)dialog_p->FindPaneByID(sg_magnet_phi_efield_rid);		C_SG_MAGNET_TABLE  * 	sg_magnet_table_p = 		(C_SG_MAGNET_TABLE  *)dialog_p->FindPaneByID(sg_magnet_table_rid);		//SetValue() only works for efields with integer values		LStr255 	x_str;		x_str.Assign( its_magnetic_theta, FIXEDDECIMAL, 6);		theta_efield_p->SetDescriptor(x_str);	x_str.Assign( its_magnetic_phi, FIXEDDECIMAL, 6);		phi_efield_p->SetDescriptor(x_str);	sg_magnet_table_p->init(its_pi_wind_p->get_nd(), its_net_p, this);				dialog_p->Show();		while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_Cancel:				return false;				break;			case msg_OK:				LStr255  	theta_str;				LStr255		phi_str;				theta_efield_p->GetDescriptor(theta_str);				phi_efield_p->GetDescriptor(phi_str);				if(!dialog_entries_are_legal(theta_str, phi_str))break;								if(!sg_magnet_table_p->unload_editor())break;								its_magnetic_theta = double_t(theta_str);				its_magnetic_phi = double_t(phi_str);								sg_magnet_table_p->get_spin_theta_phi_vecs(its_spins, its_thetas, its_phis);								//step too quick to put up watch cursor				//UCursor::SetTheCursor(watchCursor);				fill_trans_mat_and_st_names_of_nd();				//UCursor::InitTheCursor();							its_pi_wind_p->ListenToMessage(msg_pi_all_act_but, nil);				its_pi_wind_p->set_nd_always(its_pi_wind_p->get_nd());				return true;				break;		}	}	}