#include 	"C_QBIT_ROT_AMP_GEN.h"#include 	"QB_NET.h"#include 	"EXCEPTIONS.h"//notation: transition element <n | m>//******************************************C_QBIT_ROT_AMP_GEN::C_QBIT_ROT_AMP_GEN(QBIT_ROT * 		nd_p,		//inQB_NET * 		net_p,		//inC_PI_WIND * 	pi_wind_p)	//in	:C_AMP_GEN(nd_p, net_p, pi_wind_p){	for(USHORT j=0; j<4; j++){		its_thetas[j] = 0;	}}//******************************************VOID 	C_QBIT_ROT_AMP_GEN::set_theta(USHORT				j,		//inconst DOUBLE  &		theta)	//in{	its_thetas[j]=theta;	limited_degrees(its_thetas[j]);}//******************************************COMPLEX		C_QBIT_ROT_AMP_GEN::qbit_rot_amp(USHORT 	n,		//inUSHORT 	m)		//in{// notation <n || m>	USHORT	j;	DOUBLE	theta_mag = 0;	for(j=1; j<4; j++){ //note: j=0 not included!!		theta_mag += pow(its_thetas[j], 2);	}	theta_mag = sqrt(theta_mag)*my_pi/180;	//theta_mag in rads		DOUBLE	theta_hat[4];	if( theta_mag>amps_floor){		for(j=1; j<4; j++){ //note: j=0 not included!!			theta_hat[j] = (its_thetas[j]*my_pi/180)/theta_mag;		}	}else{		for(j=1; j<4; j++){ //note: j=0 not included!!			theta_hat[j] = 0;		}	}	//theta_hat[j] in rads.	//theta_hat[0] will never be used	DOUBLE	x, y;	DOUBLE	s = sin(theta_mag);	DOUBLE	c = cos(theta_mag);		if(n==0 && m==0){		x = c;		y = theta_hat[3]*s;	}else if(n==1 && m==1){		x = c;		y = -theta_hat[3]*s;	}else if(n==0 && m==1){		x = theta_hat[2]*s;		y = theta_hat[1]*s;	}else if(n==1 && m==0){		x = -theta_hat[2]*s;		y = theta_hat[1]*s;	}else{		x = 0;		y = 0;	}		s = sin(its_thetas[0]*my_pi/180);	c = cos(its_thetas[0]*my_pi/180);		return COMPLEX(c*x - s*y, c*y + s*x);}//******************************************BOOLEAN		C_QBIT_ROT_AMP_GEN::parents_are_canonical(){	return its_pi_wind_p->focus_nd_has_this_many_parents(1) 			&& its_pi_wind_p->focus_nd_parents_are_binary();}//******************************************BOOLEAN		C_QBIT_ROT_AMP_GEN::dialog_entries_are_legal(Str255		theta_p_p[])	//in{	DOUBLE 	db;	for(USHORT	j=0; j<4; j++){		if(!STRINGY(theta_p_p[j]).is_double(db)){			my_gen_alert("One of your theta entries is not a real number.");			return false;		}	}			return true;}//******************************************VOID	C_QBIT_ROT_AMP_GEN::fill_trans_mat_and_st_names_of_nd()	//in{	its_net_p->set_degen_of_a_nd(its_pi_wind_p->get_nd(), 2);	((QBIT_ROT *)its_nd_p)->obey_amp_gen();}//******************************************BOOLEAN		C_QBIT_ROT_AMP_GEN::talk(){// this is a trivial generalization of UModalDialogs::AskForOneNumber	if(!parents_are_canonical()){				return false;	}			StDialogHandler		d_handler(qbit_rot_window_rid, its_pi_wind_p);//SuperCommander declared	LWindow  *			dialog_p = d_handler.GetDialog();	LEditField  * 	theta_efield_p[4];		theta_efield_p[0] = (LEditField  *)dialog_p->FindPaneByID(qbit_rot_theta0_efield_rid);	theta_efield_p[1] = (LEditField  *)dialog_p->FindPaneByID(qbit_rot_theta1_efield_rid);	theta_efield_p[2] = (LEditField  *)dialog_p->FindPaneByID(qbit_rot_theta2_efield_rid);	theta_efield_p[3] = (LEditField  *)dialog_p->FindPaneByID(qbit_rot_theta3_efield_rid);	//SetValue() only works for efields with integer values		Str255 		str_p_p[4];	LStr255		x_str;	USHORT		j;		for(j=0; j<4; j++){		x_str.Assign(get_theta(j), FIXEDDECIMAL, 6);			theta_efield_p[j]->SetDescriptor(x_str);	}	theta_efield_p[0]->SelectAll();	dialog_p->SetLatentSub(theta_efield_p[0]);		dialog_p->Show();		while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_Cancel:				return false;				break;			case msg_OK:				for(j=0; j<4; j++){					theta_efield_p[j]->GetDescriptor(str_p_p[j]);				}				if(!dialog_entries_are_legal(str_p_p))break;				for(j=0; j<4; j++){					x_str = str_p_p[j];					set_theta(j, double_t(x_str));				}				//step too quick to put up watch cursor				//UCursor::SetTheCursor(watchCursor);								fill_trans_mat_and_st_names_of_nd();				//UCursor::InitTheCursor();							its_pi_wind_p->ListenToMessage(msg_pi_all_act_but, nil);				its_pi_wind_p->set_nd_always(its_pi_wind_p->get_nd());				return true;				break;		}	}}	