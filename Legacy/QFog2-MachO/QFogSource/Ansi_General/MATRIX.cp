#include "MATRIX.h"#pragma mark --creation/destruction--//******************************************template<class TYPE>VOID	MATRIX<TYPE>::clear(){	for(USHORT row=0;row<its_num_of_rows;row++){			delete [] its_elements_p_p[row];		its_elements_p_p[row] = 0;	}	delete [] its_elements_p_p;	its_elements_p_p = 0;	its_num_of_rows = 0;	its_num_of_cols = 0;}//******************************************template<class TYPE>VOID	MATRIX<TYPE>::copy(const MATRIX<TYPE>  & 	s)		//in{	its_num_of_rows = s.its_num_of_rows;	its_num_of_cols = s.its_num_of_cols;	if(its_num_of_rows==0){		its_elements_p_p=0;	}else{		its_elements_p_p = new TYPE  * [its_num_of_rows];//new[]		//delete:	via ~MATRIX()->MATRIX::clear()		ThrowIfNil_(its_elements_p_p);		for(USHORT row=0;row<its_num_of_rows;row++){			if(its_num_of_cols==0){				its_elements_p_p[row] = 0;			}else{				its_elements_p_p[row] = new TYPE [its_num_of_cols];//new[]				//delete:	in ~MATRIX()->MATRIX::clear()				ThrowIfNil_(its_elements_p_p[row]);				for(USHORT col=0; col<its_num_of_cols; col++){					its_elements_p_p[row][col] =  s.its_elements_p_p[row][col];				}			}		}	}}//******************************************template<class TYPE>VOID	MATRIX<TYPE>::set_to_default_mat(const TYPE  & 	default_value,		//inUSHORT 		num_of_rows,			//inUSHORT 		num_of_cols)			//in{	if(its_num_of_rows==num_of_rows && its_num_of_cols==num_of_cols){		for(USHORT row=0;row<its_num_of_rows;row++){			for(USHORT col=0; col<its_num_of_cols; col++){				its_elements_p_p[row][col]= default_value;			}		}	}else{		clear();		if(num_of_rows==0)return;		its_elements_p_p = new TYPE  * [num_of_rows];//new[]		//delete:	substitution (delete-new) pair.		ThrowIfNil_(its_elements_p_p);		for(USHORT row=0;row<num_of_rows;row++){			if(num_of_cols==0){				its_elements_p_p[row] = 0;			}else{					its_elements_p_p[row] = new TYPE [num_of_cols];//new[]				//delete:	substitution (delete-new) pair.				ThrowIfNil_(its_elements_p_p[row]);				for(USHORT col=0; col<num_of_cols; col++){					its_elements_p_p[row][col]= default_value;				}			}		}		its_num_of_rows = num_of_rows;		its_num_of_cols = num_of_cols;	}}//******************************************template<class TYPE>MATRIX<TYPE>::MATRIX()	:its_elements_p_p(0),	its_num_of_rows(0),	its_num_of_cols(0){}//******************************************template<class TYPE>MATRIX<TYPE>::MATRIX(const TYPE  &	default_value,	//inUSHORT			num_of_rows,	//inUSHORT			num_of_cols)	//in	:its_elements_p_p(0),	its_num_of_rows(0),	its_num_of_cols(0){	set_to_default_mat(default_value, num_of_rows, num_of_cols);}//******************************************template<class TYPE>MATRIX<TYPE>::MATRIX(const  MATRIX<TYPE>  &	s)	//in{	copy(s);}//******************************************template<class TYPE>MATRIX<TYPE>  & 	MATRIX<TYPE>::operator=(const MATRIX<TYPE>  &	rhs)	//in{	//rhs = right hand side 	if(this != &rhs){		clear();		copy(rhs);	}		return *this;}//******************************************template<class TYPE>MATRIX<TYPE>::~MATRIX() {	clear();}#pragma mark --const functions--//******************************************template<class TYPE>USHORT  MATRIX<TYPE>::get_num_of_rows() const{	return  its_num_of_rows;}//******************************************template<class TYPE>USHORT  MATRIX<TYPE>::get_num_of_cols() const{	return  its_num_of_cols;}				//******************************************template<class TYPE>TYPE  &  MATRIX<TYPE>::entry(USHORT	row,	//inUSHORT	col)	//inconst{	return its_elements_p_p[row][col];}		