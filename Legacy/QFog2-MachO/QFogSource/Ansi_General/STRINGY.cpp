#include "STRINGY.h"//The following is an exerpt from LString.cp //dpo#ifdef __NOEXTENSIONS__extern "C" {	#define	SIGDIGLEN		36  	#define	DECSTROUTLEN	80			// max length for dec2str output	struct decimal {		char		sgn;				// sign 0 for +, 1 for -		char		unused;		short		exp;				// decimal exponent		struct {			unsigned char	length;			unsigned char	text[SIGDIGLEN];	// significant digits			unsigned char	unused;		} sig;	};	typedef struct decimal decimal;	struct decform {		char	style;					// FLOATDECIMAL or FIXEDDECIMAL		char	unused;		short	digits;	};	typedef struct decform decform;	extern void		num2dec( const decform *f, double_t x, decimal *d );	extern void		dec2str( const decform *f, const decimal *d, char *s );	extern double	x80tod( const extended80 * x80 );	extern void		dtox80( const double *x, extended80 *x80 );	extern void  str2dec(const char *s, short *ix, decimal *d, short *vp);	extern double_t  dec2num(const decimal * d);}#endif#pragma mark --creation/destruction--//******************************************VOID	STRINGY::clear(){	delete [] its_cstr;	its_cstr = 0;	its_len = 0;	}//******************************************VOID	STRINGY::copy(const STRINGY  &	s)		//in{	//s = source	if(s.its_cstr == 0){		its_len=0;		its_cstr = 0;	}else{		its_len = s.its_len;		its_cstr = new CHAR [its_len+1];//new[]		//delete: I delete its_cstr via ~STRINGY()->STRINGY::clear().		ThrowIfNil_(its_cstr);			strcpy(its_cstr, s.its_cstr);				/*  alternative to using strcpy():				for (USHORT i =0; i<its_len; i++){				its_cstr[i] = s[i]; 				// right-hand-side uses subscripting of stringies.			}			its_cstr[its_len] = '\0';		*/	}}//******************************************STRINGY::STRINGY()	:its_len(0){//Default constructor. Creates a zero length stringy.	its_cstr = new  CHAR [1];//new[]	//delete: I delete its_cstr via ~STRINGY()->STRINGY::clear().	ThrowIfNil_(its_cstr);	its_cstr[0] = '\0';}//******************************************STRINGY::STRINGY(CHAR ch,			//inUSHORT len)			//in	:its_len(len){//Constructor. Creates a ch-filled stringy of length len.//See below, where this constructor is used to define + for stringies.	its_cstr = new  CHAR [len+1];//new[]	//delete: I delete its_cstr via ~STRINGY()->STRINGY::clear().	ThrowIfNil_(its_cstr);	for( USHORT i=0; i< len; i++){		its_cstr[i] = ch;	}	its_cstr[len]='\0';}//******************************************STRINGY::STRINGY(const CHAR  *	cstr)	//in{// Constructor. Converts a character array into a stringy.	if(cstr==0){		its_len=0;		its_cstr=0;	}else{		its_len = strlen(cstr);		its_cstr = new CHAR [its_len +1];//new[]		//delete: I delete its_cstr via ~STRINGY()->STRINGY::clear().		ThrowIfNil_(its_cstr);		strcpy(its_cstr, cstr);	}}//******************************************STRINGY::STRINGY(SHORT i)		//in{// Constructor that converts shorts into stringies.	CHAR 	cstr[80];	sprintf(cstr, "%i", i);	its_len = strlen(cstr);	its_cstr = new CHAR [its_len +1];//new[]	//delete: I delete its_cstr via ~STRINGY()->STRINGY::clear().	ThrowIfNil_(its_cstr);	strcpy(its_cstr, cstr);}//******************************************STRINGY::STRINGY(USHORT i)		//in{// Constructor that converts ushorts into stringies.	CHAR 	cstr[80];	sprintf(cstr, "%i", i);	its_len = strlen(cstr);	its_cstr = new CHAR [its_len +1];//new[]	//delete: I delete its_cstr via ~STRINGY()->STRINGY::clear().	ThrowIfNil_(its_cstr);	strcpy(its_cstr, cstr);}//******************************************STRINGY::STRINGY(LONG i)		//in{// Constructor that converts longs into stringies.	CHAR 	cstr[80];	sprintf(cstr, "%i", i);	its_len = strlen(cstr);	its_cstr = new CHAR [its_len +1];//new[]	//delete: I delete its_cstr via ~STRINGY()->STRINGY::clear().	ThrowIfNil_(its_cstr);	strcpy(its_cstr, cstr);}//******************************************STRINGY::STRINGY(DOUBLE x)		//in{// Constructor that converts doubles into stringies.	CHAR 	cstr[80];	sprintf(cstr, "%f", x);	its_len = strlen(cstr);	its_cstr = new CHAR [its_len +1];//new[]	//delete: I delete its_cstr via ~STRINGY()->STRINGY::clear().	ThrowIfNil_(its_cstr);	strcpy(its_cstr, cstr);}//******************************************STRINGY::STRINGY(const STRINGY  &	s) 		//in{	copy(s);}//******************************************STRINGY  & 	STRINGY::operator= (const STRINGY  &	rhs)	//in{	if(this != &rhs){		if(its_len == rhs.its_len){			if(rhs.its_len==0){				clear();			}else{				strcpy(its_cstr, rhs.its_cstr);			}		}else{			clear();			copy(rhs);		}	}	return *this;}//******************************************STRINGY::~STRINGY() {	clear();}#pragma mark --cstr, len (const functions)--//******************************************STRINGY		STRINGY::get_sub_stringy(USHORT	starting_pos,	//inUSHORT	sub_str_len)	//inconst {	//starting_pos is zero based	ThrowIf_(starting_pos + sub_str_len > its_len);	STRINGY  sub_sgy('x', sub_str_len);	for (USHORT i =0; i<sub_str_len; i++){		sub_sgy[i] = its_cstr[i + starting_pos]; 	}	return sub_sgy;}#pragma mark --what type (const functions)--//******************************************BOOLEAN		STRINGY::is_legal_name()const{	CHAR ch;	if(its_len>31)return false;	for(USHORT i=0; i<its_len; i++){		ch = its_cstr[i];		if (			(ch <= 0x20) || //0x20 = blank		  	(ch >= 0x7F) || //0x7F = delete			(ch =='#')  ){			return false;		}	}	return true;}#pragma mark --comparison (const functions)--//******************************************BOOLEAN		operator==(const STRINGY  &	s1,		//in	const STRINGY  & 	s2)		//in{	if(s1.its_cstr == s2.its_cstr){		 return true;	}else{ //if they are not equal:		if( (s1.its_cstr==0)||(s2.its_cstr==0) ){			return false;		}else{			return ( strcmp(s1.its_cstr, s2.its_cstr)==0 );		}	}}//******************************************BOOLEAN		operator==(const STRINGY  &	s,	//inconst CHAR  *	cstr)	//in{	if(s.its_cstr == cstr){		 return true;	}else{ //if they are not equal:		if( (s.its_cstr==0)||(cstr==0) ){			return false;		}else{			return ( strcmp(s.its_cstr, cstr)==0 );		}	}}//******************************************BOOLEAN		operator==(const CHAR  *	cstr,		//in		const STRINGY  &	s)		//in{	if(cstr == s.its_cstr){		 return true;	}else{ //if they are not equal:		if( (cstr==0)||(s.its_cstr==0) ){			return false;		}else{			return ( strcmp(cstr, s.its_cstr)==0 );		}	}}//******************************************BOOLEAN		operator<(const STRINGY  &	s1,		//inconst STRINGY  &	s2)		//in{	if(s1.its_cstr == s2.its_cstr){		return false;	}else if(s1.its_cstr == 0){		return true;	}else if(s2.its_cstr == 0){		return false;	}else{		return ( strcmp(s1.its_cstr , s2.its_cstr) < 0 );	}}#pragma mark --concatenation--//******************************************STRINGY		STRINGY::operator &&(const STRINGY  &	rhs)		//in{// concatenates two stringies.	if(its_cstr==0){		return rhs;	}else{ // if its_cstr!=0:		if(rhs==0){			return *this;		}else{//if its_cstr and rhs are both non-zero:			USHORT tot_len = its_len + rhs.its_len;			STRINGY temp('a', tot_len);	// temp = temporary			strcpy(temp.its_cstr, its_cstr);			strcat(temp.its_cstr, rhs.its_cstr);			/* alternative to using strcpy and strcat:				for (USHORT i=0; i<its_len; i++){					temp[i]= its_cstr[i];				}				for (USHORT j=0; j<rhs.its_len; i++, j++){					temp[i]= rhs[j];				}			*/			return temp;		}	}}#pragma mark --i/o--//******************************************OSTREAM  &		operator<<(OSTREAM  &		out_bd,		//i-oconst STRINGY  &	s)		//in{//out_bd= out bound, headed out of cpu//Stream output. This also works for a file, //since an fstream is-an ostream. 	out_bd << s.its_cstr;	return out_bd;}//******************************************ISTREAM  &		operator>> (ISTREAM  &	in_bd,		//i-oSTRINGY  &	s) 			//in{ //Stream input. This works also for a file, //since an fstream is-an istream. 	CHAR 	cstr[STRINGY::stringy_max_len + 1];	in_bd >> cstr; 	delete []  s.its_cstr;	s.its_len= strlen(cstr);	s.its_cstr = new CHAR [s.its_len +1];//new[]	//delete: substitution of delete-new pair	ThrowIfNil_(s.its_cstr);	strcpy(s.its_cstr, cstr);	return in_bd;}//******************************************ISTREAM  &		STRINGY::copy_line(ISTREAM  &	in_bd,		//i-oUSHORT	max_len,		//inCHAR	stop_char)		//in{// usually stop_char = my_endline// This member function for STRINGY acts like // the "getline" member function for ISTREAM.// Both transfer a string from an istream object to something else// ( a stringy and a character array, respectively).// This also works for a file, as an fstream is-an istream.	CHAR 	cstr[stringy_max_len + 1];	in_bd.getline(		cstr,		(stringy_max_len < max_len)? stringy_max_len : max_len,		stop_char	);	delete [] its_cstr;	its_len=strlen(cstr);	its_cstr = new CHAR [its_len +1];//new[]	//delete: substitution of delete-new pair	ThrowIfNil_(its_cstr);	strcpy(its_cstr, cstr);	return in_bd;}//******************************************#pragma mark ----used only with macgui----#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.#pragma mark --creation/destruction--//******************************************VOID	STRINGY::fill_LStr255(LStr255 & pstr)		//outconst{//to go from STRINGY to Str255 (which is an unsigned char[256])//both STRINGY and Str255 have a max length of 255 characters	pstr[0] = its_len;	for(USHORT i=1; i<=its_len; i++){		pstr[i]=its_cstr[i-1];	}}//******************************************STRINGY::STRINGY(const LStr255 & pstr)		//in{ // to go from LStr255 to a STRINGY		if(pstr[0]==0){		its_len=0;		its_cstr=0;	}else{		its_len = pstr[0];		its_cstr = new CHAR [its_len +1];//new[]		//delete: I delete its_cstr via ~STRINGY()->STRINGY::clear().		ThrowIfNil_(its_cstr);		for(int i=0; i<its_len; i++){			its_cstr[i]=pstr[i+1];		}		its_cstr[its_len] = '\0';	}}#pragma mark --what type (const functions)--//******************************************BOOLEAN		STRINGY::is_double()const{ 	//Refs: 	//fp.h header, under Binary to decimal conversions  	//LString class, under LString::operator double_t() const	decimal	dec_num;	//in: ix is the position at which start reading str	//out:ix is the position at which ended reading str	//ix should be zero for c-string, 1 for pascal string 	SInt16 	ix=0;	//out: vp=0 if conversion was unsuccessful, 1 otherwise	SInt16 	vp;		//VOID	str2dec (	//const char *	s,		//in	//short *		ix,		//in	//decimal *		d,		//out	//short *		vp);	//out		::str2dec(its_cstr, &ix, &dec_num, &vp);	return vp;	}//******************************************BOOLEAN		STRINGY::is_double(DOUBLE  &  db)		//outconst{ 	//Refs: 	//fp.h header, under Binary to decimal conversions  	//LString class, under LString::operator double_t() const	decimal	dec_num;	//in: ix is the position at which start reading str	//out:ix is the position at which ended reading str	//ix should be zero for c-string, 1 for pascal string 	SInt16 	ix=0;	//out: vp=0 if conversion was unsuccessful, 1 otherwise	SInt16 	vp;		//VOID	str2dec (	//const char *	s,		//in	//short *		ix,		//in	//decimal *		d,		//out	//short *		vp);	//out		::str2dec(its_cstr, &ix, &dec_num, &vp);	if (vp) {						// Conversion was successful		//double_t dec2num ( const decimal *d ); 		db = ::dec2num(&dec_num);	}	return vp;	}//******************************************BOOLEAN		STRINGY::is_ushort()const{	if(its_len==0)return false;	for(USHORT c=0; c< its_len; c++){		if(its_cstr[c]<'0' || its_cstr[c]>'9' ){		 	return false;		}	}		return true;}//******************************************BOOLEAN		STRINGY::is_ushort(USHORT  &	n)		//outconst{	if(its_len==0)return false;	for(USHORT c=0; c< its_len; c++){		if(its_cstr[c]<'0' || its_cstr[c]>'9' ){		 	return false;		}	}	LStr255  pstr;	this->fill_LStr255(pstr);	SInt32	nn;	::StringToNum(pstr, &nn);	n = nn;	return true;}//******************************************BOOLEAN		STRINGY::is_ushort_pair()const{	//This function recognizes a stringy of the form (ushort, ushort)	//If it finds such a pair it returns true.	if(its_len<5)return false;	if(  its_cstr[0]!='(' || its_cstr[its_len-1]!=')' )return false;	USHORT num_of_commas=0;	USHORT i;	for(i=1; i<=its_len-2; i++){		if(its_cstr[i]==','){			num_of_commas++;			if(num_of_commas>1)return false;		}else if('0'<= its_cstr[i] &&  its_cstr[i]<='9'){			//do nothing		}else{			return false;		}	}		return true;}	//******************************************BOOLEAN		STRINGY::is_ushort_pair(USHORT  &	n1,		//out	USHORT  &	n2)		//outconst{	//This function recognizes a stringy of the form (ushort, ushort)	//If it finds such a pair it returns true 	//and places the components in n1 and n2.	if(its_len<5)return false;	if(  its_cstr[0]!='(' || its_cstr[its_len-1]!=')' )return false;	USHORT num_of_commas=0;	USHORT comma_pos=0;	USHORT i;	for(i=1; i<its_len-2; i++){		if(its_cstr[i]==','){			comma_pos=i;			num_of_commas++;			if(num_of_commas>1)return false;		}else if('0'<= its_cstr[i] &&  its_cstr[i]<='9'){			//do nothing		}else{			return false;		}	}	//example (12,456)	//its_len = 8	//comma_pos= 3	//comma_pos-1 = 2	//its_len - comma_pos - 2 = 8-3-2 = 3		LStr255 	pstr;	LONG 	num;		STRINGY  str1('1', comma_pos-1);	for(i=1; i< comma_pos; i++){		str1[i-1] = its_cstr[i];	}		str1.fill_LStr255(pstr);		::StringToNum(pstr, &num);	n1 = num;			STRINGY  str2('1', its_len-comma_pos-2);	for(i=comma_pos + 1; i< its_len-1; i++){		str2[i- comma_pos -1] = its_cstr[i];	}		str2.fill_LStr255(pstr);		::StringToNum(pstr, &num);	n2 = num;		return true;}	#pragma mark --i/o--//******************************************LStream  &		operator<<(LStream  &		out_bd,		//i-oconst STRINGY  &	s)		//in{	out_bd << s.its_cstr;	return out_bd;}//******************************************LStream  &		operator>>(LStream  &		in_bd,		//i-oSTRINGY  &		s)			//in { 	CHAR 	cstr[STRINGY::stringy_max_len + 1];	in_bd >> cstr; 	delete []  s.its_cstr;	s.its_len= strlen(cstr);	s.its_cstr = new CHAR [s.its_len +1];//new[]	//delete:	substitution of delete-new pair	ThrowIfNil_(s.its_cstr);	strcpy(s.its_cstr, cstr);	return in_bd;}#endif //_mac_gui_app \\............................................//		 			 	      