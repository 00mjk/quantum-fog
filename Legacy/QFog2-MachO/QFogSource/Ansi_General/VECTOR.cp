#include "VECTOR.h"#include "QFog_constants.h"#pragma mark --creation/destruction--//******************************************template<class TYPE>VOID   VECTOR<TYPE>::clear( ){	delete [] its_array_p;	its_array_p=0;	its_len=0;}//******************************************template<class TYPE>VOID   VECTOR<TYPE>::copy(const VECTOR<TYPE>  &  s)		//in{	 // s = source	its_len = s.its_len;	if(its_len==0){		its_array_p = 0;	}else{		its_array_p = new TYPE [its_len];//new[]		//delete:	in ~VECTOR().		ThrowIfNil_(its_array_p);				for(USHORT i=0; i<its_len; i++){			its_array_p[i] = s[i];		}	}}//******************************************template<class TYPE>VOID   VECTOR<TYPE>::set_to_default_vec(const TYPE  & default_value,		//inUSHORT len )						//in{	if(its_len == len){		for(USHORT i=0; i<len; i++){			its_array_p[i] = default_value;		}	}else{				delete [] its_array_p;		if(len==0){			its_array_p = 0;		}else{			its_array_p= new TYPE [len];//new[]			//delete:	substitution of delete-new pair.					ThrowIfNil_(its_array_p);			for(USHORT i=0; i<len; i++){				its_array_p[i] = default_value;			}		}				its_len = len;	}}//******************************************template<class TYPE>VOID   VECTOR<TYPE>::resize(const TYPE  & default_value,	//inUSHORT new_len )				//in{	if(new_len == its_len)return;	if(new_len==0){		clear();		return;	}	TYPE  * new_array_p = new TYPE [new_len];//new[]	//delete:	substitution of delete-new pair.	ThrowIfNil_(new_array_p);	USHORT i;	if(its_len < new_len){		for(i=0; i<its_len; i++){			new_array_p[i] = its_array_p[i];		}		for(i=its_len; i < new_len; i++){			new_array_p[i] = default_value;		}	}else{		for(i=0; i<new_len; i++){			new_array_p[i] = its_array_p[i];		}	}	delete [] its_array_p;	its_array_p =new_array_p;	its_len =new_len;}//******************************************template<class TYPE>VECTOR<TYPE>::VECTOR()	:its_array_p(0),	its_len(0){}//******************************************template<class TYPE>VECTOR<TYPE>::VECTOR(const TYPE  &	default_value,	//inUSHORT		len)				//in	:its_array_p(0),	its_len(0){	set_to_default_vec(default_value, len);}//******************************************template<class TYPE>VECTOR<TYPE>::VECTOR(const  VECTOR<TYPE>  &		s)		//in	{	copy(s);}//******************************************template<class TYPE>VECTOR<TYPE>  & 	VECTOR<TYPE>::operator=(const VECTOR<TYPE>  &	rhs)	//in {	//rhs = right hand side 	if(this != &rhs){		if(its_len == rhs.its_len){			for(USHORT i= 0; i<its_len; i++){				its_array_p[i] = rhs[i];			}				}else{				clear();			copy(rhs);		}	}	return *this;}//******************************************template<class TYPE>VECTOR<TYPE>::~VECTOR(){	clear();}#pragma mark --const functions--//******************************************template<class TYPE>USHORT  VECTOR<TYPE>::get_len() const{	return  its_len;}		//******************************************template<class TYPE>USHORT   VECTOR<TYPE>::loc_of_target(const TYPE  &  tar)		//inconst {	if(its_len == 0) return max_ushort;	USHORT loc = max_ushort; 	for(USHORT i=0; i< its_len; i++){		if( its_array_p[i] == tar){			loc=i;			break;		}	}	return loc;}//******************************************template<class TYPE>TYPE  &  VECTOR<TYPE>::operator[](USHORT i)		//inconst{	ThrowIf_(i>=its_len);	return its_array_p[i];}#pragma mark --insert an element--//******************************************template<class TYPE>VOID   VECTOR<TYPE>::insert_last(const TYPE  & data)		//in{	TYPE  *  new_array_p = new TYPE [its_len+1];//new[]	//delete:	substitution of delete-new pair.	ThrowIfNil_(new_array_p);	for(USHORT j=0; j<its_len; j++){		new_array_p[j] = its_array_p[j];	}	new_array_p[its_len] = data;	delete [] its_array_p;	its_array_p =new_array_p;	++its_len;}//******************************************template<class TYPE>VOID   VECTOR<TYPE>::insert_ptr_last(TYPE data)		//in{	TYPE  *  new_array_p = new TYPE [its_len+1];//new[]	//delete:	substitution of delete-new pair.	ThrowIfNil_(new_array_p);		for(USHORT j=0; j<its_len; j++){		new_array_p[j] = its_array_p[j];	}	new_array_p[its_len] = data;	delete [] its_array_p;	its_array_p =new_array_p;	++its_len;}#pragma mark --extract an element--//******************************************template<class TYPE>VOID	VECTOR<TYPE>::extract_at(USHORT loc)		//in{	if(loc >= its_len)return;	USHORT new_len = its_len - 1;	TYPE  *  new_array_p = 0;	if(new_len!=0){		new_array_p = new TYPE [new_len];//new[]		//delete:	substitution of delete-new pair.		ThrowIfNil_(new_array_p);		USHORT i;		for(i=0; i<loc ; i++){				new_array_p[i] = its_array_p[i];		}		for(i=loc;i<new_len ; i++){				new_array_p[i] = its_array_p[i+1];		}	}	delete [] its_array_p;	its_array_p =new_array_p;	--its_len;}//CW likes "VECTOR_FRIENDS.h" in header file//gcc likes "VECTOR_FRIENDS.h" in implemetation file//#include "VECTOR_FRIENDS.h"