//******************************************// Purpose: To define a singly-linked list.// The list will dwell in the heap.//******************************************#pragma once//******************************************template<class TYPE>class DIR_DATA  //dir_data = directed data{public:	// data	TYPE				its_data;	DIR_DATA<TYPE>  * 	its_next_p;		DIR_DATA(); 	DIR_DATA( const TYPE  & data, DIR_DATA<TYPE>  * next_p) 	{its_data = data; its_next_p=next_p;}	DIR_DATA(const DIR_DATA<TYPE>  & source);		};// The class DIR_DATA, which will be used only by the class L_LIST,// has only some of the four horsemen, only those that will be used// by the class L_LIST. In particular, the assigner will not be used.// Also, there is no need for an explicit destructor as // DIR_DATA never calls "new".	//******************************************template<class TYPE>class L_LIST{   private:	DIR_DATA<TYPE>  * 	its_first_p;  	DIR_DATA<TYPE>  * 	its_last_p;  	USHORT 				its_len;  // len = lengthpublic:	VOID clear();	VOID copy(const L_LIST<TYPE>  &  prev_list);		L_LIST();	L_LIST(  const  L_LIST<TYPE>  &  s );	L_LIST<TYPE>  &  operator=( const L_LIST<TYPE>  & rhs);	virtual ~L_LIST();	DIR_DATA<TYPE>  *   get_first_p() const;	DIR_DATA<TYPE>  *   get_last_p() const;	const USHORT		get_len() const;		BOOLEAN  has_this( const TYPE  & target) const;	TYPE  &   operator[] (USHORT loc) const;	VOID	insert_first(const TYPE  & data);	VOID	insert_last(const TYPE  & data);		BOOLEAN		extract_first( TYPE  & data);	BOOLEAN		extract_first();		BOOLEAN		extract_last();	BOOLEAN		extract_target( const TYPE  & target);	BOOLEAN		extract_target( DIR_DATA<TYPE>  * target_p);		};