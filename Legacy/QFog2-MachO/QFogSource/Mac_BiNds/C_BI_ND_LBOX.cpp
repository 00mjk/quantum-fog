#include "C_BI_ND_LBOX.h"#include "C_BI_ND_WIND.h"#include "C_DOC.h"#include "QB_NET.h"#pragma mark --creation/destruction--//******************************************C_BI_ND_LBOX::C_BI_ND_LBOX(LStream  *		inStream)	//in	:LListBox(inStream),	its_occupancy_of_last_row(2),	its_num_of_rows(0){	//create_h:		PP creates mMacListH with call to ::LNew().	//throwif_h:	PP does not call throwif immediately after creation. 	ThrowIfNil_(mMacListH);	::LAddColumn(1, 0, mMacListH);}//******************************************C_BI_ND_LBOX::~C_BI_ND_LBOX(){}#pragma mark --change rows--//******************************************VOID	C_BI_ND_LBOX::refresh_a_row(USHORT row,					//inStr255 new_name_pstr)		//in{//drawer	FocusDraw();//this makes it use the correct font		Cell	dest_cell = {0, 0};	dest_cell.v = row;	::LClrCell(dest_cell,  mMacListH);		::LSetCell(	new_name_pstr + 1, new_name_pstr[0], dest_cell, mMacListH);}//******************************************VOID	C_BI_ND_LBOX::fill_first(const STRINGY  &  namey)		//in{//drawer	FocusDraw();//this makes it use the correct font		::LAddRow(1, its_num_of_rows, mMacListH);		LStr255  name_pstr;	namey.fill_LStr255(name_pstr);	LString::AppendPStr(name_pstr, "\p \\ ");		Cell	dest_cell = {0, 0};	dest_cell.v = its_num_of_rows;		::LSetCell(	StringPtr(name_pstr) + 1, name_pstr[0], dest_cell, mMacListH);	its_num_of_rows++;		its_occupancy_of_last_row=1;	}//******************************************VOID	C_BI_ND_LBOX::fill_second(const STRINGY  &  namey)		//in{//drawer		FocusDraw();//this makes it use the correct font		LStr255  name_pstr;	namey.fill_LStr255(name_pstr);		Cell	dest_cell = {0, 0};	dest_cell.v = its_num_of_rows-1;		::LAddToCell(StringPtr(name_pstr) + 1, name_pstr[0], dest_cell, mMacListH);			its_occupancy_of_last_row=2;	}//******************************************VOID	C_BI_ND_LBOX::refill() 	{	delete_all_rows();	USHORT  num_of_bi_nds = its_net_p->get_num_of_bi_nds();	USHORT nd1, nd2;	for(USHORT loc =0; loc <num_of_bi_nds; loc++){		its_net_p->get_bi_nd(loc, nd1, nd2);		fill_first(its_net_p->get_nd_ptr(nd1)->get_name());		fill_second(its_net_p->get_nd_ptr(nd2)->get_name());	}}	//******************************************VOID	C_BI_ND_LBOX::delete_row_and_tell_net_about_it(USHORT  xed_row)		//in{	if(its_num_of_rows==0)return;	::LDelRow(1, xed_row, mMacListH);	if(xed_row != its_num_of_rows-1){		its_net_p->del_bi_nd(xed_row);	}else{ //xed_row == its_num_of_rows-1		if(its_occupancy_of_last_row==1){			its_occupancy_of_last_row=2;		}else{//its_occupancy_of_last_row==2			its_net_p->del_bi_nd(xed_row);		}	}	its_num_of_rows--;}//******************************************VOID	C_BI_ND_LBOX::delete_all_rows(){	if(its_num_of_rows==0)return;	::LDelRow(0, 1, mMacListH);//deletes all rows	its_occupancy_of_last_row = 2;	its_num_of_rows = 0;}#pragma mark --command center--//******************************************VOID	C_BI_ND_LBOX::Click(SMouseDownEvent	 &	inMouseDown)		//in{	//MONITOR_THE_CHANGE_HERE	its_doc_p->SetModified(true);		LListBox::Click(inMouseDown);									}//******************************************BOOLEAN   C_BI_ND_LBOX::HandleKeyPress(const EventRecord  & in_key_event)		//in{	//MONITOR_THE_CHANGE_HERE	//doc: see below	if( ((in_key_event.message &keyCodeMask)>>8) == 0x33){//delete key was pressed		//This is like a combination of ObeyCommand() and FindCommandStatus()		if(GetValue()!=-1){			//doc: marked modified in C_BI_ND_LBOX::ObeyCommand()			return ProcessCommand(cmd_Clear);		}else{			return true;		}	}else{		return LListBox::HandleKeyPress(in_key_event);	}}//******************************************BOOLEAN		C_BI_ND_LBOX::ObeyCommand(CommandT	inCommand,		//in	VOID	 *	ioParam)		//i-o{	//MONITOR_THE_CHANGE_HERE	//doc: see below		BOOLEAN				obeyed = true;	BOOLEAN				needs_refresh = true;	switch (inCommand) {		case cmd_Clear:			its_doc_p->SetModified(true);			SInt16 row_num = GetValue();			if(row_num!=-1)delete_row_and_tell_net_about_it(row_num);			break;		default:							obeyed = LListBox::ObeyCommand(inCommand, ioParam);			needs_refresh = false;			break;	}		if (needs_refresh)		Refresh();	return obeyed;}//******************************************VOID	C_BI_ND_LBOX::FindCommandStatus(CommandT		inCommand,		//inBOOLEAN		&	outEnabled,		//outBOOLEAN		&	outUsesMark,	//outUInt16		&	outMark,		//outStr255			outName_pstr)	//out{	outEnabled = false;			outUsesMark = false;	outMark = noMark;		switch (inCommand) {		case cmd_Clear:			if(GetValue()!=-1)outEnabled = true;			break;		default:							LListBox::FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName_pstr);			break;	}	}