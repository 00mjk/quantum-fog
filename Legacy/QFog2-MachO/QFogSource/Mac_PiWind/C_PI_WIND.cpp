#include 	"EXCEPTIONS.h"#include 	"C_DOC.h"#include 	"C_PI_WIND.h"#include 	"C_EFIELD_PASTE_ATMENT.h"#include 	"C_MAIN_VIEW.h"#include 	"C_KEYS.h"#include	"C_NET_QTABLE.h"#include 	"MY_FSTREAMS.h"#include 	"STRINGY.h"#include 	"TRANS_MAT.h"#include 	<typeinfo.h>#include "BEAM_SPL.h"#include "CUSTOM_ND.h"#include "DET_ND.h"#include "POL_ROTATOR.h"#include "POLARIZER.h"#include "SG_MAGNET.h"#pragma mark --creation/destruction--//******************************************C_PI_WIND::C_PI_WIND(LStream  *		inStream)	//in	:LWindow(inStream), 	its_coord_sys(rect_cs){}//******************************************C_PI_WIND::C_PI_WIND(){}//******************************************C_PI_WIND::~C_PI_WIND(){	its_mview_p->finish_pi_wind_closing();}//******************************************VOID	C_PI_WIND::show_owner(const LStr255  &  file_name)	//in{	LStr255  cap = "\pProject: ";	cap += (LStr255)file_name;	its_owner_cap_p->SetDescriptor(cap);}//******************************************VOID	C_PI_WIND::special_finish_create(const LStr255  & 	file_name,		//inUSHORT	 sel_nd)					//in{	its_owner_cap_p = (LCaption  *)FindPaneByID(pi_owner_cap_rid);	its_nd_efield_p = (C_PI_ND_EFIELD  *)FindPaneByID(pi_nd_efield_rid);	its_nd_popup_p  = (C_PI_ND_POPUP  *)FindPaneByID(pi_nd_popup_rid);		its_first_nd_but_p = (LStdButton  *)FindPaneByID(pi_first_nd_but_rid);	its_next_nd_but_p = (LStdButton  *)FindPaneByID(pi_next_nd_but_rid);	//in_st = incoming state = parent state	its_first_in_st_but_p = (LStdButton  *)FindPaneByID(pi_first_in_st_but_rid);	its_prev_in_st_but_p = (LStdButton  *)FindPaneByID(pi_prev_in_st_but_rid);	its_next_in_st_but_p = (LStdButton  *)FindPaneByID(pi_next_in_st_but_rid);		its_parents_table_p = (C_PI_PARENTS_TABLE  *)FindPaneByID(pi_parents_table_rid);			its_all_act_but_p = (LStdButton  *)FindPaneByID(pi_all_act_but_rid);	its_none_act_but_p = (LStdButton  *)FindPaneByID(pi_none_act_but_rid);		its_polar_radio_p = (LStdRadioButton  *)FindPaneByID(pi_polar_radio_rid);	its_rect_radio_p = (LStdRadioButton  *)FindPaneByID(pi_rect_radio_rid);		its_rad_re_cap_p = (LCaption  *)FindPaneByID(pi_rad_re_cap_rid);	its_ang_im_cap_p = (LCaption  *)FindPaneByID(pi_ang_im_cap_rid);		its_amps_table_p = (C_PI_AMPS_TABLE  *)FindPaneByID(pi_amps_table_rid);		its_num_of_rows_cap_p = (LCaption  *)FindPaneByID(pi_num_of_rows_cap_rid);	its_num_of_rows_but_p = (LStdButton  *)FindPaneByID(pi_num_of_rows_but_rid);	its_total_prob_but_p = (LStdButton  *)FindPaneByID(pi_total_prob_but_rid);	its_total_prob_cap_p = (LCaption  *)FindPaneByID(pi_total_prob_cap_rid);		its_gen_amps_but_p = (LStdButton  *)FindPaneByID(pi_gen_amps_but_rid);		its_nd_efield_p->AddAttachment(new C_ND_NAME_PASTE_ATMENT());//= new	//delete:	 	// Activate RidL resource.   	UReanimator::LinkListenerToControls(this, this, pi_wind_ridl);	//its_nd_efield is a broadcaster but not a control. 	   	its_nd_efield_p->AddListener(this); 	//its_amps_table is a broadcaster but not a control. 	its_amps_table_p->AddListener(this);  	 	//its SuperCommander defined in C_MAIN_VIEW::create_pi_wind() 	((C_MAIN_VIEW  *)GetSuperCommander())->get_top_ptrs(its_doc_p, its_mview_p, its_net_p); 	its_nd_popup_p->set_top_ptrs(its_doc_p, its_mview_p, its_net_p); 	its_parents_table_p->set_top_ptrs(its_doc_p, its_mview_p, its_net_p); 	its_amps_table_p->set_top_ptrs(its_doc_p, its_mview_p, its_net_p);   	show_owner(file_name);  	 	//use set_nd_always() instead of set_nd_if_diff() to avoid checking		set_nd_always(sel_nd);	Show();//necessary!}//******************************************VOID	C_PI_WIND::AttemptClose(){	if(!its_amps_table_p->unload_editor())return;	//calls delete this	LWindow::AttemptClose();}//******************************************VOID	C_PI_WIND::DoClose(){	//DoClose() is called iff user closes window directly.	//AttemptClose() is called at other times. For example, if	//window closes as a result of a quit.							if(!its_amps_table_p->unload_editor())return;	//calls delete this	LWindow::DoClose();	}#pragma mark --focus node and in state--//******************************************VOID	C_PI_WIND::set_nd_always(USHORT  new_nd) 	//in{	its_amps_table_p->set_is_modified(true);			its_nd =new_nd;	its_in_st = 0;		its_nd_efield_p->set_nd_always(new_nd);		LStr255	descriptor_pstr;	its_net_p->get_nd_ptr(new_nd)->get_name().fill_LStr255(descriptor_pstr);	its_nd_efield_p->SetDescriptor(descriptor_pstr);		its_parents_table_p->set_nd_always(new_nd);	its_amps_table_p->set_nd_always(new_nd);	refresh_num_of_rows_cap();	refresh_total_prob_cap();	ND_CLASS_ID	  cid = its_net_p->get_nd_class_id(new_nd);	if(cid==CUSTOM_ND_id){		its_gen_amps_but_p->Disable();	}else{		its_gen_amps_but_p->Enable();	}}//******************************************VOID	C_PI_WIND::set_in_st(TM_COL_NUM  new_in_st)	//in {	its_amps_table_p->set_is_modified(true);		its_in_st =new_in_st;			its_parents_table_p->set_in_st(new_in_st);	its_amps_table_p->set_in_st(new_in_st);	refresh_total_prob_cap();}#pragma mark --button:	coord sys--//******************************************VOID	C_PI_WIND::toggle_coord_sys(){	its_amps_table_p->set_is_modified(true);			if(its_coord_sys==rect_cs){		its_coord_sys = polar_cs;		its_amps_table_p->set_coord_sys(polar_cs);		its_rad_re_cap_p->SetDescriptor("\pRadius       ");		its_ang_im_cap_p->SetDescriptor("\pAngle(degs.) ");	}else{		its_coord_sys = rect_cs;		its_amps_table_p->set_coord_sys(rect_cs);		its_rad_re_cap_p->SetDescriptor("\pReal  Part   ");		its_ang_im_cap_p->SetDescriptor("\pImag. Part   ");	}}#pragma mark --button:	total prob--//******************************************VOID 	C_PI_WIND::refresh_total_prob_cap(){	DOUBLE  tot_prob = its_net_p->get_nd_ptr(its_nd)->get_col_prob(its_in_st);	LStr255	str;	str.Assign(tot_prob, FIXEDDECIMAL, 6);	its_total_prob_cap_p->SetDescriptor(str);}#pragma mark --button:	num_of_rows--//******************************************VOID 	C_PI_WIND::refresh_num_of_rows_cap(){	NODE  * 	nd_p = its_net_p->get_nd_ptr(its_nd);	USHORT		num_of_rows = nd_p->get_degen();	USHORT		num_of_act_sts = nd_p->get_num_of_active_states();	SignalIf_(num_of_act_sts > num_of_rows);		LStr255   num_of_rows_str;	::NumToString(num_of_rows, num_of_rows_str);		LStr255   num_of_act_sts_str;	::NumToString(num_of_act_sts, num_of_act_sts_str);		LStr255 	descriptor =		num_of_rows_str +		"\p Rows (" +		num_of_act_sts_str +		"\p active)";	its_num_of_rows_cap_p->SetDescriptor(descriptor);}//******************************************BOOLEAN	 C_PI_WIND::handle_num_of_rows_dialog(){//This is a trivial generalization of UModalDialogs::AskForOneNumber//We don't use AskForOneNumber because we want to check //that illegal an entry has not been been pasted into efield.//I am allowing a maximum of 4 characters ->max number of rows is 9,999.//This is smaller than max_ushort = 2^16 - 1  = 65,535	StDialogHandler		d_handler(rows_wind_rid, this);//SuperCommander declared	LWindow  *			dialog_p = d_handler.GetDialog();		LEditField  * 	efield_p = 		(LEditField  *)dialog_p->FindPaneByID(rows_wind_efield_rid);	USHORT  degen = its_net_p->get_degen_of_a_nd(its_nd);	USHORT 	new_degen = degen;	efield_p->SetValue(degen);			efield_p->SelectAll();	dialog_p->SetLatentSub(efield_p);	dialog_p->Show();	Str255  pstr;	while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_Cancel:				return false;				break;			case msg_OK:				efield_p->GetDescriptor(pstr);					if(!STRINGY(pstr).is_ushort(new_degen)|| new_degen==0){					my_gen_alert("Your entry for the number of rows must be a positive integer.");					break;				}				if(new_degen!=degen && new_degen!=0){					its_net_p->set_degen_of_a_nd(its_nd, new_degen);					its_amps_table_p->activate_all_states();					its_amps_table_p->set_nd_always(its_nd);					refresh_num_of_rows_cap();					refresh_total_prob_cap();				}				return true;				break;		}	}	}/*same as above, but without checking for pasting induced errors://******************************************VOID	C_PI_WIND::handle_num_of_rows_dialog(){	USHORT  degen = its_net_p->get_degen_of_a_nd(its_nd);	SInt32 	new_degen = degen;	UModalDialogs::AskForOneNumber(		this,					//in, ptr to supercommander		rows_wind_rid,			//in, dialog window rid		rows_wind_efield_rid,	//in, efield rid		new_degen);				//i-o,  efield value	if(new_degen!=degen && new_degen!=0){		its_net_p->set_degen_of_a_nd(its_nd, new_degen);		its_amps_table_p->set_nd_always(its_nd);		refresh_num_of_rows_cap();		refresh_total_prob_cap();	}		}*/#pragma mark --button:	gen_st_names--//******************************************BOOLEAN		C_PI_WIND::gen_st_names_dialog_entries_are_legal(ST_NAMES_GENERATOR_DATA  &		v)	//i-o{	//num_of_comps >=1 and <=31	//min_char: 0 to 9 and a to z	//max_char: 0 to 9 and a to z, must have min_char<=max_char.	//if v.its_has_commas=true, check that 2*num_of_comps + 1 <=31		if(v.its_num_of_comps==0 || v.its_num_of_comps>31){		my_gen_alert("Must have: 1 <= Number Of Components <= 31.");		return false;	}		if(v.its_min_char>v.its_max_char){		my_gen_alert("Must have: Smallest <= Largest.");		return false;	}	if(v.its_has_commas && (2*v.its_num_of_comps + 1 >31)){		//my_gen_alert("To include commas and parentheses, must have \(Number Of Components\) <= 15.");// dpo		my_gen_alert("To include commas and parentheses, must have (Number Of Components) <= 15.");		return false;	}	//key filters make sure that v.its_min_char and v.its_max_char 	//are alpha-numeric.		//Change upper case to lower case.	SHORT	n_A = 'A';	SHORT	n_a = 'a';	if('A'<=v.its_min_char && v.its_min_char<='Z'){		v.its_min_char += n_a - n_A;	}	if('A'<=v.its_max_char && v.its_max_char<='Z'){			v.its_max_char += n_a - n_A;	}	return true;}//******************************************BOOLEAN	 C_PI_WIND::handle_gen_st_names_dialog(){//This is a trivial generalization of UModalDialogs::AskForOneNumber	StDialogHandler		d_handler(gn_wind_rid, this);//SuperCommander declared	LWindow  *			dialog_p = d_handler.GetDialog();		LEditField  * 	num_of_comps_efield_p = (LEditField  *)dialog_p->FindPaneByID(gn_num_of_comps_efield_rid);	LEditField  * 	min_char_efield_p = (LEditField  *)dialog_p->FindPaneByID(gn_min_char_efield_rid);	LEditField  * 	max_char_efield_p = (LEditField  *)dialog_p->FindPaneByID(gn_max_char_efield_rid);	LStdCheckBox  *		commas_check_box_p = (LStdCheckBox  *)dialog_p->FindPaneByID(gn_commas_check_box_rid);	NODE  *  nd_p = its_net_p->get_nd_ptr(its_nd);		//SetValue() only works for efields with integer values			LStr255		x_str;	ST_NAMES_GENERATOR_DATA	v(its_st_names_gen_data);	num_of_comps_efield_p->SetValue(v.its_num_of_comps);	x_str = v.its_min_char;	min_char_efield_p->SetDescriptor(x_str);	x_str = v.its_max_char;	max_char_efield_p->SetDescriptor(x_str);	commas_check_box_p->SetValue(v.its_has_commas?1:0);			num_of_comps_efield_p->SelectAll();	dialog_p->SetLatentSub(num_of_comps_efield_p);	dialog_p->Show();	while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_Cancel:				return false;				break;			case msg_OK:				v.its_num_of_comps = num_of_comps_efield_p->GetValue();								min_char_efield_p->GetDescriptor(x_str);				v.its_min_char = x_str[1];								max_char_efield_p->GetDescriptor(x_str);				v.its_max_char = x_str[1];								v.its_has_commas = (commas_check_box_p->GetValue());								if(!gen_st_names_dialog_entries_are_legal(v)){					// don't return yet					break;				}				its_st_names_gen_data = v;																nd_p->set_st_names(v);												set_nd_always(its_nd);				return true;				break;		}	}	}#pragma mark --buttons: reordering:	nds, parent nds, nd_amps--//******************************************BOOLEAN		C_PI_WIND::handle_reorder_nds_dialog(){			//pi wind won't open unless there is at least one node	ThrowIf_(its_net_p->get_num_of_nds()==0);		//this is a trivial generalization of UModalDialogs::AskForOneNumber	StDialogHandler		d_handler(q_wind_rid, this);//SuperCommander declared	LWindow  *			dialog_p = d_handler.GetDialog();	dialog_p->SetDescriptor("\pReorder Nodes"); 	C_NET_QTABLE  * 	table_p = 		(C_NET_QTABLE  *)dialog_p->FindPaneByID(qtable_rid);	table_p->finish_create(		its_net_p->get_num_of_nds(),		its_nd, nd_qttype, its_doc_p, its_mview_p, its_net_p);		while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_Cancel:				return false;				break;			case msg_q_abc_but:				table_p->alphabetize_q();				//don't return yet				break;			case msg_OK:				its_net_p->reorder_nds(table_p->get_map());				set_nd_always(table_p->get_map().its_newfo[its_nd]);				return true;				break;		}	}	}//******************************************BOOLEAN		C_PI_WIND::handle_reorder_in_nds_dialog(){	if(its_net_p->get_nd_ptr(its_nd)->get_num_of_in_nds()==0)return true;		//this is a trivial generalization of UModalDialogs::AskForOneNumber	StDialogHandler		d_handler(q_wind_rid, this);//SuperCommander declared	LWindow  *			dialog_p = d_handler.GetDialog();	dialog_p->SetDescriptor("\pReorder Parent Nodes"); 	C_NET_QTABLE  * 	table_p = 		(C_NET_QTABLE  *)dialog_p->FindPaneByID(qtable_rid);	table_p->finish_create(		its_net_p->get_nd_ptr(its_nd)->get_num_of_in_nds(),		its_nd, parent_qttype, its_doc_p, its_mview_p, its_net_p);		while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_Cancel:				return false;				break;			case msg_q_abc_but:				table_p->alphabetize_q();				//don't return yet				break;			case msg_OK:				its_net_p->get_nd_ptr(its_nd)->reorder_in_nds(table_p->get_map(), true);				set_nd_always(its_nd);				return true;				break;		}	}	}//******************************************BOOLEAN		C_PI_WIND::handle_reorder_nd_sts_dialog(){	if(its_net_p->get_nd_ptr(its_nd)->get_degen()==0)return true;		// this is a trivial generalization of UModalDialogs::AskForOneNumber	StDialogHandler		d_handler(q_wind_rid, this);//SuperCommander declared	LWindow  *			dialog_p = d_handler.GetDialog();	dialog_p->SetDescriptor("\pReorder Node States"); 	C_NET_QTABLE  * 	table_p = 		(C_NET_QTABLE  *)dialog_p->FindPaneByID(qtable_rid);	table_p->finish_create(		its_net_p->get_nd_ptr(its_nd)->get_degen(),		its_nd, nd_state_qttype, its_doc_p, its_mview_p, its_net_p);		while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_Cancel:				return false;				break;			case msg_q_abc_but:				table_p->alphabetize_q();				//don't return yet				break;			case msg_OK:				its_net_p->reorder_nd_sts(its_nd, table_p->get_map());				its_amps_table_p->Refresh();				return true;				break;		}	}	}#pragma mark --button: gen_amps: check_parents--//******************************************BOOLEAN		C_PI_WIND::focus_nd_has_this_many_parents(USHORT	num)	//in{	//if num = max_ushort, just checks that num_of_in_nds>0	NODE  *  	nd_p = its_net_p->get_nd_ptr(its_nd);	STRINGY		sgy;	if(num==max_ushort){		if(nd_p->get_num_of_in_nds()==0){			my_gen_alert("Inadmissible parents. This button works only if focus node has at least one parent.");		 	return false;		}	}else{			if(nd_p->get_num_of_in_nds()!=num){			sgy = STRINGY("Inadmissible parents. This button works only if the focus node has exactly ") && num;			if(num==1){				sgy = sgy && " parent.";			}else{				sgy = sgy && " parents.";			}			my_gen_alert(sgy);		 	return false;		}	}	return true;}//******************************************BOOLEAN		C_PI_WIND::focus_nd_parents_are_binary(){	BOOLEAN		is_ok = true;	NODE  *  	nd_p = its_net_p->get_nd_ptr(its_nd);	USHORT		num_of_in_nds = nd_p->get_num_of_in_nds();				USHORT		j;	STRINGY		stringy0, stringy1;	for(j=0; j<num_of_in_nds; j++){			USHORT 		in_nd = nd_p->get_in_nds()[j];		NODE  * 	in_nd_p = its_net_p->get_nd_ptr(in_nd);		if(in_nd_p->get_degen()!=2){			 is_ok = false;			 goto ending;		}		stringy0 = in_nd_p->get_st_name(0);		stringy1 = in_nd_p->get_st_name(1);			if(!(stringy0=="0" && stringy1=="1")){			is_ok = false;			goto ending;		}	}	ending:;		if(!is_ok){		my_gen_alert("Inadmissible parents. This button works only if the states of each parent are precisely 0, 1, in that order.");	}		return is_ok;}#pragma mark --buttons:	response center--//******************************************VOID	C_PI_WIND::ListenToMessage(MessageT  	inMessage,		//inVOID  * 	ioParam )		//i-o{		//MONITOR_THE_CHANGE_HERE	//doc: marked modified in C_PI_WIND::Click()	BOOLEAN 	tell_mview_uaction = false;//mview = main view	BOOLEAN		tell_table_uaction = false;//table = amplitudes table		switch (inMessage){		case msg_pi_nd_efield:			//let the main view handle it			its_mview_p->ListenToMessage(inMessage, ioParam);			break;		case msg_pi_nd_popup:			// for nd_popup: inMessage = pane id, *ioParam = current item 			USHORT   item = *((SInt32  *)ioParam);						set_nd_if_diff(item - 1); 			break;		case msg_pi_first_nd_but:			set_nd_if_diff(0);					break;		case msg_pi_next_nd_but:			if(its_nd + 1 <its_net_p->get_num_of_nds() ){				set_nd_if_diff(its_nd + 1);			}else{				::SysBeep(0);			}			break;		case msg_pi_reorder_nds_but:			tell_mview_uaction = true;			handle_reorder_nds_dialog();			break;		case msg_pi_reorder_in_nds_but:			tell_mview_uaction = true;			handle_reorder_in_nds_dialog();			break;		case msg_pi_reorder_nd_sts_but:			tell_mview_uaction = true;						handle_reorder_nd_sts_dialog();			break;		case msg_pi_first_in_st_but:			set_in_st_if_diff( 0);			break;		case msg_pi_prev_in_st_but:			if(its_in_st > 0 ){				set_in_st_if_diff(its_in_st - 1);			}else{				::SysBeep(0);			}			break;		case msg_pi_next_in_st_but:			if(its_in_st + 1 <its_net_p->get_nd_ptr(its_nd)->get_num_of_in_sts() ){				set_in_st_if_diff(its_in_st + 1);			}else{				::SysBeep(0);			}			break;		case msg_pi_all_act_but:			its_amps_table_p->activate_all_states();			refresh_num_of_rows_cap();			break;		case msg_pi_none_act_but:			its_amps_table_p->deactivate_all_states();			refresh_num_of_rows_cap();			break;		case msg_pi_polar_radio:			tell_table_uaction = true;			toggle_coord_sys();			break;		case msg_pi_refresh_num_of_rows_cap:			refresh_num_of_rows_cap();			break;		case msg_pi_total_prob_but:			refresh_total_prob_cap();			break;		case msg_pi_clear_total_prob_cap:			clear_total_prob_cap();			break;		case msg_pi_num_of_rows_but:			tell_mview_uaction = true;			tell_table_uaction = true;			handle_num_of_rows_dialog();			break;		case msg_pi_gen_st_names_but:			tell_mview_uaction = true;			tell_table_uaction = true;			handle_gen_st_names_dialog();			break;		case msg_pi_gen_amps_but:			tell_mview_uaction = true;			tell_table_uaction = true;			(its_net_p->get_nd_ptr(its_nd))->call_amp_gen(its_net_p, this);			break;					default:			//handle parent states popups here			TableIndexT		num_of_rows, num_of_cols;			its_parents_table_p->GetTableSize(num_of_rows, num_of_cols);			SInt32	broadcasting_row = inMessage - first_pi_pa_st_popup_PPob_rid + 1; 			if(	broadcasting_row>=1 && broadcasting_row<=num_of_rows){				// for popup: inMessage = pane id, *ioParam = current item 				USHORT	item = *((SInt32  *)ioParam);				NODE  *  	nd_p = its_net_p->get_nd_ptr(its_nd);				STRETCH_OR_FOLD 	sof_in(nd_p->get_in_nd_degens());				VECTOR<USHORT>		in_st_vec(sof_in.vec_label(its_in_st));				in_st_vec[broadcasting_row-1] = item-1;				set_in_st(sof_in.int_label(in_st_vec));			}						break;				}	if(tell_mview_uaction)	its_mview_p->set_is_modified(true, mview_del);	if(tell_table_uaction) its_amps_table_p->set_is_modified(true);}#pragma mark --other--//******************************************VOID	C_PI_WIND::Click(SMouseDownEvent	 &	inMouseDown)		//in{	//MONITOR_THE_CHANGE_HERE	its_doc_p->SetModified(true);	its_mview_p->set_is_modified(true, mview_del);	//Superview of amps table is its scroller.	LScroller	*  scr_p = dynamic_cast<LScroller *>(its_amps_table_p->GetSuperView());				if(!scr_p->IsHitBy(inMouseDown.wherePort.h, inMouseDown.wherePort.v)){		//If click outside of amps table scroller, 		//unload editor and unselect all cells.		if(!its_amps_table_p->unload_editor())return;		its_amps_table_p->nullify_editor();		its_amps_table_p->UnselectAllCells();				//Make pi_wind the target.		//Do this only if 		//click outside amps table scroller		//or will loose selection.		//This stops focus node efield from		//repeating (if it was repeating).		//Despite this call to SwitchTarget(),		//if click inside subpane		//that is a commander, she will become 		//target when we call LWindow::Click(). 		SwitchTarget(this);			}		//If I don't do this, reorder node states dialog 	//may show different names than amps table.	LButton 	*	reorder_nd_sts_but_p = 						dynamic_cast<LButton *>(scr_p->FindPaneByID(pi_reorder_nd_sts_but_rid));	if(reorder_nd_sts_but_p->IsHitBy(inMouseDown.wherePort.h, inMouseDown.wherePort.v)){		if(!its_amps_table_p->unload_editor())return;		its_amps_table_p->nullify_editor();		its_amps_table_p->UnselectAllCells();			}			//This scrolls the node name efield to the home position.	if(!its_nd_efield_p->IsHitBy(inMouseDown.wherePort.h, inMouseDown.wherePort.v)){		its_nd_efield_p->scroll_to_home();	}	LWindow::Click(inMouseDown);									}//******************************************VOID   C_PI_WIND::ClickSelf(const SMouseDownEvent  &  in_mouse_down)	//in{#pragma unused(in_mouse_down)	//MONITOR_THE_CHANGE_HERE	//doc marked modified in C_PI_WIND::Click()		//overrrides empty method LPane::ClickSelf(in_mouse_down)}//******************************************VOID	C_PI_WIND::rename_a_nd(USHORT nd,				//inStr255 new_name_pstr)	//in {	if(its_nd == nd){			its_nd_efield_p->SetDescriptor(new_name_pstr);	}else{		its_parents_table_p->rename_a_nd(nd);	}}#pragma mark --command center--/*command owner conflicts: when one or more commanders can handle (own)a command with the same name. This is specially true for:cmd_Undocmd_Cutcmd_Copycmd_Pastecmd_Clear (both as menu item and delete key)cmd_SelectAllIn such cases the active window should take precedence.					 --amps table					|mview--pi_wind--					|					 --focus node efieldTo prevent the above commands from trickling down to mview when pi_wind is active, must disable them in a FindCommandStatus() for the pi_wind *///******************************************BOOLEAN   C_PI_WIND::HandleKeyPress(const EventRecord  & in_key_event)		//in{	//MONITOR_THE_CHANGE_HERE	//doc: no change		if( ((in_key_event.message &keyCodeMask)>>8) == 0x33){//delete key was pressed		//This is like a combination of ObeyCommand() and FindCommandStatus()		//always do nothing		return true;	}else{		return LWindow::HandleKeyPress(in_key_event);	}}//******************************************BOOLEAN		C_PI_WIND::ObeyCommand(CommandT	inCommand,		//inVOID  *		ioParam)		//i-o{	//MONITOR_THE_CHANGE_HERE	//doc: no change		BOOLEAN				obeyed = true;	BOOLEAN				needs_refresh = true;	switch (inCommand){		default:			obeyed = LWindow::ObeyCommand(inCommand, ioParam);			needs_refresh = false;			break;	}			if (needs_refresh) Refresh();	return obeyed;}//******************************************VOID	C_PI_WIND::FindCommandStatus(CommandT		inCommand,		//inBOOLEAN		&	outEnabled,		//outBOOLEAN		&	outUsesMark,	//outUInt16		&	outMark,		//outStr255			outName_pstr)	//out{	outEnabled = false;			outUsesMark = false;	outMark = noMark;	switch (inCommand) {		case cmd_Undo:		case cmd_Cut:		case cmd_Copy:		case cmd_Paste:		case cmd_Clear:		case cmd_SelectAll:			outEnabled = false;			break;		default:							LWindow::FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName_pstr);			break;	}	}