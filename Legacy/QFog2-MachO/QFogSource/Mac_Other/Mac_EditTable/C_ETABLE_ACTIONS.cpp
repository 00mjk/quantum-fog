#include 	"C_ETABLE_ACTIONS.h"#include	"C_EDIT_TABLE.h"#include	"C_ETABLE_MULTI_SEL.h"#include 	"QFog_constants.h"/*	LAction(			ResIDT		inStringResID = STRx_RedoEdit,			SInt16		inStringIndex = str_RedoUndo,			Boolean		inAlreadyDone = false);*/#pragma mark --C_ETABLE_DEL_OR_CUT_ACTION--#define _act_type	etable_del//******************************************C_ETABLE_DEL_OR_CUT_ACTION::C_ETABLE_DEL_OR_CUT_ACTION(C_EDIT_TABLE  *			etable_p,		//inC_ETABLE_MULTI_SEL  *	selector_p,		//inUSHORT				copy_to_scrap)		//in	:LAction(my_redo_rid, undel_ind + copy_to_scrap, false),	its_etable_p(etable_p),	its_selector_p(selector_p),	its_copy_to_scrap(copy_to_scrap){	//IMP: we assume that string index for redo_cut is 1 more than that for redo_del	its_etable_p->resize_and_anchor_sub_mat_like_sel(its_undel_reco);	its_etable_p->write_sub_mat(its_undel_reco);	if(its_copy_to_scrap==1)its_etable_p->copy_selection(its_undel_reco, false);	its_saved_sel_rect = its_selector_p->get_sel_rect();	its_etable_p->set_is_modified(false, _act_type);	}//******************************************C_ETABLE_DEL_OR_CUT_ACTION::~C_ETABLE_DEL_OR_CUT_ACTION(){}//******************************************BOOLEAN		C_ETABLE_DEL_OR_CUT_ACTION::CanRedo() const{	BOOLEAN		can_redo = false;	if(		mIsDone==false &&		its_etable_p->IsOnDuty() &&		!its_etable_p->is_modified(_act_type)	){		can_redo = true;	}	return can_redo;}//******************************************BOOLEAN		C_ETABLE_DEL_OR_CUT_ACTION::CanUndo() const{	BOOLEAN		can_undo = false;	if(		mIsDone==true &&		its_etable_p->IsOnDuty() &&		!its_etable_p->is_modified(_act_type)	){		can_undo = true;	}	return can_undo;}//******************************************VOID	C_ETABLE_DEL_OR_CUT_ACTION::RedoSelf(){	if(!its_etable_p->unload_editor())return;	its_etable_p->nullify_editor();	its_selector_p->set_sel_rect(its_saved_sel_rect);	its_etable_p->delete_selection();//calls Refresh() for main view	its_etable_p->set_is_modified(false, _act_type);}	//******************************************VOID	C_ETABLE_DEL_OR_CUT_ACTION::UndoSelf(){//if(its_copy_to_scrap==1)ThrowIfOSErr_(::ZeroScrap());//better to zero scrap only immediately before writing new stuff to it.	if(!its_etable_p->unload_editor())return;	its_etable_p->nullify_editor();	//this unselects all cells and selects changed ones	its_etable_p->read_sub_mat(its_undel_reco);	its_etable_p->set_is_modified(false, _act_type);}#pragma mark --C_ETABLE_PASTE_ACTION--#undef	_act_type#define _act_type	etable_paste//******************************************C_ETABLE_PASTE_ACTION::C_ETABLE_PASTE_ACTION(C_EDIT_TABLE  *		etable_p,			//inC_SUB_MATRIX  *  aft_paste_reco_p)		//in	:LAction(my_redo_rid, unpaste_ind, false),	its_etable_p(etable_p){	//swap info in case *aft_paste_reco_p 	//goes out of scope before this action does	aft_paste_reco_p->swap_info(its_aft_paste_reco);		its_bef_paste_reco.its_num_of_cols = its_aft_paste_reco.its_num_of_cols;	its_bef_paste_reco.its_num_of_rows = its_aft_paste_reco.its_num_of_rows;	its_bef_paste_reco.its_anchor = its_aft_paste_reco.its_anchor;	its_etable_p->write_sub_mat(its_bef_paste_reco);		its_etable_p->set_is_modified(false, _act_type);	}//******************************************C_ETABLE_PASTE_ACTION::~C_ETABLE_PASTE_ACTION(){}//******************************************BOOLEAN		C_ETABLE_PASTE_ACTION::CanRedo() const{	BOOLEAN		can_redo = false;	if(		mIsDone==false &&		its_etable_p->IsOnDuty() &&		!its_etable_p->is_modified(_act_type)	){		can_redo = true;	}	return can_redo;}//******************************************BOOLEAN		C_ETABLE_PASTE_ACTION::CanUndo() const{	BOOLEAN		can_undo = false;	if(		mIsDone==true &&		its_etable_p->IsOnDuty() &&		!its_etable_p->is_modified(_act_type)	){		can_undo = true;	}	return can_undo;}//******************************************VOID	C_ETABLE_PASTE_ACTION::RedoSelf(){	if(!its_etable_p->unload_editor())return;	its_etable_p->nullify_editor();	//this unselects all cells and selects changed ones	its_etable_p->read_sub_mat(its_aft_paste_reco);	its_etable_p->set_is_modified(false, _act_type);}	//******************************************VOID	C_ETABLE_PASTE_ACTION::UndoSelf(){	//if(its_copy_to_scrap==1)ThrowIfOSErr_(::ZeroScrap());//better to zero scrap only immediately before writing new stuff to it.	if(!its_etable_p->unload_editor())return;	its_etable_p->nullify_editor();	//this unselects all cells and selects changed ones	its_etable_p->read_sub_mat(its_bef_paste_reco);	its_etable_p->set_is_modified(false, _act_type);}#undef _act_type