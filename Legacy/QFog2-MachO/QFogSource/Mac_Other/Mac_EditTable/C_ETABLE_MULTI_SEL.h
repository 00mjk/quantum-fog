#pragma once//******************************************class	C_ETABLE_MULTI_SEL : public LTableMultiSelector{protected:	USHORT	its_first_selectable_col;	USHORT	its_first_selectable_row;public:			C_ETABLE_MULTI_SEL(LTableView  *  tv_p, USHORT first_scol, USHORT first_srow);			virtual   ~C_ETABLE_MULTI_SEL();			VOID		set_anchor_cell(const STableCell  &  cell);BOOLEAN 	is_selectable_cell(const STableCell  & inCell);USHORT		get_sel_size() const;Rect 		get_sel_rect() const;VOID		set_sel_rect(const Rect  &	rect);VOID		SelectAllCells();VOID		ClickSelect(const STableCell  & inCell, const SMouseDownEvent  & inMouseDown);BOOLEAN		DragSelect(const STableCell  & inCell, const SMouseDownEvent  & inMouseDown);};#pragma mark -//******************************************inlineVOID	C_ETABLE_MULTI_SEL::set_anchor_cell(const STableCell  &  cell)	//in{	mAnchorCell = cell;	}//******************************************inlineBOOLEAN	 C_ETABLE_MULTI_SEL::is_selectable_cell(const STableCell  &   cell)			//in{	//I assume that first N rows and first M columns can be unselectable.	//Selectable cells are a subset of valid cells.	return 	mTableView->IsValidCell(cell) &&			cell.row>=its_first_selectable_row &&			cell.col>=its_first_selectable_col;}//******************************************inlineRect  C_ETABLE_MULTI_SEL::get_sel_rect()const{	return mSelectionRgn.Bounds();}