#include "C_CELL_EDITOR.h"#include "C_CELL_EDITOR_UNDOER.h"#include "C_EDIT_TABLE.h"#include "C_SUB_MATRIX.h"#include "C_KEYS.h"#pragma mark --creation/destruction--//******************************************C_CELL_EDITOR::C_CELL_EDITOR(LView  * 		super_view_p,			//inLCommander  * 	super_comm_p)			//in 	:LEditField(){	//the constructor LEditField() without arguments gives it only 	//the has_box feature. I also want the autoscroll feature 	::TEFeatureFlag(teFAutoScroll, teBitSet, mTextEditH);	//this is a sort of limbo; there is no physical zero row, or col	its_cell.row = 0; 	its_cell.col = 0;		SetPaneID(0); //default		//size will be set as needed		Enable();	SBooleanRect  bindings;		bindings.left = bindings.top = bindings.right = bindings.bottom = false;	SetFrameBinding(bindings);		//position will be set as needed		PutInside( super_view_p );		//text_traits will be set from edit table		SetMaxChars(31);//default		DrawBox();	UseWordWrap(false);			SetKeyFilter(C_KEYS::my_PrintingCharField);//default		SetSuperCommander(super_comm_p);	/*	SPaneInfo  pane_info;		paneInfo.paneID =cellEditorRid;		paneInfo.width = 0; // size will be set as needed		paneInfo.height = 0;		paneInfo.enabled = true;				paneInfo.bindings.left = false;		paneInfo.bindings.top = false;		paneInfo.bindings.right = false;		paneInfo.bindings.bottom = false;			paneInfo.left = 0; // position will be set as needed		paneInfo.top = 0;		paneInfo.superView = superView_p;	LEditField(		pane_info,//pane_info		"\pBooo!!",//initial caption		table_txt_rid,// 'Txtr' resource id		31,// maximum number of characters		true,// has box		false,// has word wrap		UKeyFilters::PrintingCharField,// key filter function		super_comm_p);// super commander*/	FinishCreate();	Hide();	C_CELL_EDITOR_UNDOER  * 	undoer_p = new C_CELL_EDITOR_UNDOER(this);	//delete:	PP deletes undoer_p via 	//			~C_CELL_EDITOR()->~LEditfield()->~LPane()	//			->~LAttachable()->LAttachable::RemoveAllAttachments().	ThrowIfNil_(undoer_p);	AddAttachment(undoer_p);}//******************************************C_CELL_EDITOR::~C_CELL_EDITOR(){}#pragma mark --location--//******************************************VOID	C_CELL_EDITOR::move_to(SInt16  horz,		//inSInt16  vert)		//in{	Rect	rect;	CalcLocalFrameRect(rect);	MoveBy( SInt32(horz-rect.left), SInt32(vert-rect.top), false);}#pragma mark --command center--//******************************************BOOLEAN   C_CELL_EDITOR::HandleKeyPress(const EventRecord  & 	in_key_event)		//in{	//MONITOR_THE_CHANGE_HERE		//its SuperCommander defined in C_EDIT_TABLE::init()	C_EDIT_TABLE  *   table_p = (C_EDIT_TABLE  *)GetSuperCommander();		SEL_MANAGER	sel_mgr = table_p->get_sel_mgr();	if(sel_mgr==editor_mgr){		//LEditField already knows how to handle the delete key,		//which is the key that concerns us most		return LEditField::HandleKeyPress(in_key_event);	}else{//sel_mgr==table_mgr		return table_p->HandleKeyPress(in_key_event);	}				}//******************************************BOOLEAN		C_CELL_EDITOR::ObeyCommand(CommandT	inCommand,		//inVOID  *		ioParam)		//i-o{	//MONITOR_THE_CHANGE_HERE		BOOLEAN				obeyed = true;	BOOLEAN				needs_refresh = true;	//its SuperCommander defined in C_EDIT_TABLE::init()	C_EDIT_TABLE  *   	table_p = (C_EDIT_TABLE  *)GetSuperCommander();		SEL_MANAGER			sel_mgr = table_p->get_sel_mgr();	switch (inCommand) {		case cmd_Paste:{			C_SUB_MATRIX	smat;			if(smat.absorb_clipping()){				if((smat.its_num_of_cols)*(smat.its_num_of_rows)==1){					obeyed = LEditField::ObeyCommand(inCommand, ioParam);					needs_refresh = false;									}else{					ioParam = (VOID  *)&smat;					obeyed = table_p->ObeyCommand(inCommand, ioParam);					its_cell=STableCell(0,0);					//must call Hide() after call table_p->ObeyCommand()					//or else cell editor won't be target inside table_p->ObeyCommand() 					Hide();					needs_refresh = false;				}			}			break;		}//due to compiler bug, get bus error if don't have these braces				default:			if(sel_mgr==editor_mgr){				obeyed = LEditField::ObeyCommand(inCommand, ioParam);				needs_refresh = false;			}else{//sel_mgr==table_mgr				obeyed = table_p->ObeyCommand(inCommand, ioParam);				needs_refresh = false;			}							break;	}			if (needs_refresh) Refresh();	return obeyed;}//******************************************VOID	C_CELL_EDITOR::FindCommandStatus(CommandT		inCommand,		//inBOOLEAN		&	outEnabled,		//outBOOLEAN		&	outUsesMark,	//outUInt16		&	outMark,		//outStr255			outName_pstr)	//out{	outEnabled = false;			outUsesMark = false;	outMark = noMark;	//its SuperCommander defined in C_EDIT_TABLE::init()	C_EDIT_TABLE  *   	table_p = (C_EDIT_TABLE  *)GetSuperCommander();		SEL_MANAGER			sel_mgr = table_p->get_sel_mgr();		switch (inCommand) {		case cmd_Paste:			if(UScrap::HasData('TEXT'))outEnabled = true;			break;				default:			if(sel_mgr==editor_mgr){				LEditField::FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName_pstr);			}else{//sel_mgr==table_mgr				table_p->FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName_pstr);			}							break;	}	}