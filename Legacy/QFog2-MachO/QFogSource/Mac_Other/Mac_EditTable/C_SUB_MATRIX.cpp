#include "C_SUB_MATRIX.h"#include <string.h>#include "EXCEPTIONS.h"#include "STRINGY.h"//C_SUB_MATRIX is similar to LHandleStream//******************************************C_SUB_MATRIX::C_SUB_MATRIX()	:its_num_of_cols(0),	its_num_of_rows(0){	//its_anchor is created as 0,0 automatically	its_content_h = ::NewHandle( 0L );	//create_h:		I create its_content_h with call to ::NewHandle().	//throwif_h:	I call ThrowIfMemFail_ above.	//destroy_h:	I destroy its_content_h in ~C_SUB_MATRIX().	ThrowIfMemFail_(its_content_h);}//******************************************C_SUB_MATRIX::~C_SUB_MATRIX(){		DisposeHandle_(its_content_h);}//******************************************BOOLEAN		C_SUB_MATRIX::absorb_clipping(){	//Refs.	//(1)Think Ref. under String.h	//(2)Shammas, Mac C++ programming in 21 days	if(!get_TEXT_scrap(its_content_h)) return false; //GLOBAL_FUN.h	StHandleState  saved_h(its_content_h);//preserve handle state	//lock its_content_h for the rest of this method	::HLock(its_content_h);//saved handle state	//Be nice and ignore any white space 	//at the end of its_content_h.	//byte_len must be at least 1 because	//get_TEXT_scrap() added null terminator.	LONG	byte_len = ::GetHandleSize(its_content_h);	LONG	pos = byte_len - 1;	CHAR *	cont_p = *its_content_h;	while(pos > -1 && (cont_p[pos]<= 0x20 || cont_p[pos] >= 0x7f)){		cont_p[pos] = '\0';		pos--;	}	const CHAR  * 	cstr = *its_content_h;	its_num_of_rows = 1; //its_num_ofrows= (num of \r + 1)	const CHAR  *  ch_p = cstr;	while(1){		ch_p = strchr(ch_p,'\r');		if(ch_p!=0){			its_num_of_rows++;			ch_p++;		}else{			break;		}			}			its_num_of_cols = 1;// its_num_ofcols = (num of \t + 1)  in last row	ch_p = cstr;	ch_p = strrchr(ch_p, '\r');	while(1){		ch_p = strchr(ch_p,'\t');		if(ch_p!=0){			its_num_of_cols++;			ch_p++;		}else{			break;		}			}	ch_p = cstr;	CHAR  *	delims = "\t\r";	BOOLEAN  clipping_is_rectan=true;		for(USHORT r=1; r<its_num_of_rows;r++){		for(USHORT c=1; c<its_num_of_cols; c++){			ch_p = strpbrk(ch_p, delims);			if(ch_p==0||ch_p[0]!='\t'){				clipping_is_rectan = false;				goto ending;			}else{				ch_p++;			}		}		ch_p = strpbrk(ch_p, delims);		if(ch_p==0||ch_p[0]!='\r'){			clipping_is_rectan = false;			goto ending;		}else{			ch_p++;		}	}		ending:;	if(!clipping_is_rectan){		::SetHandleSize(its_content_h, 0);//no need to HUnlock because not growing size		its_num_of_cols=0;		its_num_of_rows=0;		my_gen_alert("The contents of the Clipboard are not a rectangular array. Only rectangular arrays can be pasted into the table.");		return false;	}else{		return true;	}}//******************************************VOID	C_SUB_MATRIX::swap_info(C_SUB_MATRIX	 & 		inheritor)	//i-o{	Handle	x_h = its_content_h;	//	cout<<"this, x_h, inheritor"<<GetHandleSize(its_content_h)<<", "//		<<::GetHandleSize(x_h)<<", "<<::GetHandleSize(inheritor.its_content_h)<<endl;	//x, x, y	::SetHandleSize(inheritor.its_content_h, 0);//no need to HUnlock because not growing size	its_content_h	= inheritor.its_content_h;		//	cout<<"this, x_h, inheritor"<<::GetHandleSize(its_content_h)<<", "//		<<GetHandleSize(x_h)<<", "<<GetHandleSize(inheritor.its_content_h)<<endl;	//0, x, 0	inheritor.its_content_h = x_h;	//	cout<<"this, x_h, inheritor"<<GetHandleSize(its_content_h)<<", "//		<<GetHandleSize(x_h)<<", "<<GetHandleSize(inheritor.its_content_h)<<endl<<endl;	//0, x, x				inheritor.its_num_of_cols = its_num_of_cols;	inheritor.its_num_of_rows = its_num_of_rows;	inheritor.its_anchor = its_anchor;		its_num_of_cols = 0;	its_num_of_rows = 0;	its_anchor = STableCell(0,0);	}