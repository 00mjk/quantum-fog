#include "C_WIND_BDS_RECO.h"#include "C_DOC.h"#include "UOnyx.h"#pragma mark --creation/destruction--//******************************************C_WIND_BDS_RECO::C_WIND_BDS_RECO(){	its_bds.top = 0;	its_bds.bottom = 0;	its_bds.left = 0;	its_bds.right = 0;}#pragma mark --this/wind communication--//******************************************VOID	C_WIND_BDS_RECO::change_wind(LWindow  * 	wind_p)		//inconst{	//if its_bds ={0,0,0,0}, as set by 	//the WIND_ST constructor, then don't do anything 	if( (its_bds.bottom-its_bds.top)==0) return;	if(wind_p==0)return;	if(wind_p->HasAttribute(windAttr_Resizable)){			wind_p->DoSetBounds(its_bds);	}else{		wind_p->DoSetPosition(topLeft(its_bds));	}}//******************************************VOID	C_WIND_BDS_RECO::set_reco(LWindow  * 	wind_p)		//in{	if(wind_p==0)return;	wind_p->CalcPortFrameRect(its_bds);	wind_p->PortToGlobalPoint(topLeft(its_bds));	wind_p->PortToGlobalPoint(botRight(its_bds));	}//******************************************VOID	C_WIND_BDS_RECO::move_to_top_right_corner_of_screen(LWindow  * 	wind_p)			//in{	if(wind_p==0)return;	Rect   old_bds;	wind_p->CalcPortFrameRect(old_bds);	wind_p->PortToGlobalPoint(topLeft(old_bds));	wind_p->PortToGlobalPoint(botRight(old_bds));			its_bds.left = 4;	its_bds.top = 40;	its_bds.right = 4 + old_bds.right - old_bds.left;	its_bds.bottom = 40 + old_bds.bottom - old_bds.top;	if(wind_p->HasAttribute(windAttr_Resizable)){		BitMap	screenBits;		GetQDGlobalsScreenBits(&screenBits);		if (its_bds.right > screenBits.bounds.right-4) its_bds.right = screenBits.bounds.right-4;		if (its_bds.bottom > screenBits.bounds.bottom-4) its_bds.bottom = screenBits.bounds.bottom-4;		wind_p->DoSetBounds(its_bds);	}else{			wind_p->DoSetPosition(topLeft(its_bds));	}}#pragma mark --write/read to resource fork of doc--//******************************************void	C_WIND_BDS_RECO::write_res(C_DOC  * 	doc_p,		//inResIDT 		rid)	//in{	if(doc_p==0)return;	if(doc_p->GetFile()==0)return;	//We assume that the doc was created with a resource fork	doc_p->open_res_fork(fsRdWrPerm);	SLDisable_();		Rect  *  * 	rect_h = (Rect  *  *) ::Get1Resource('WBds', rid);	//destroy_h: in this method	SLEnable_();	//don't use ThrowIfResFail_(rect_h) because handle may be zero	ThrowIfResError_();		if ( rect_h != 0 )	{		//a resource already exists -- update it		**rect_h = its_bds;	  	::ChangedResource(Handle(rect_h));	} else {		//no resource exists -- add one		rect_h = (Rect  *  *) (NewHandle(sizeof(Rect)));		//create_h:		I create rect_h with call to ::NewHandle().		//throwif_h:	I call ThrowIfMemFail_ above.		//destroy_h:	I call ReleaseResource()  below.		ThrowIfMemFail_(rect_h);		**rect_h = its_bds;	  	::AddResource( Handle(rect_h), 'WBds', rid, 0);	}		::UpdateResFile(doc_p->get_res_fork_ref_num());	ReleaseResource_(Handle(rect_h));		doc_p->close_res_fork();}//******************************************VOID	C_WIND_BDS_RECO::read_res(C_DOC  * 	doc_p,		//inResIDT 		rid)		//in{	if(doc_p==0)return;	if(doc_p->GetFile()==0)return;	//We assume that the doc was created with a resource fork	Rect  *  * 	rect_h;		doc_p->open_res_fork(fsRdWrPerm);	rect_h = (Rect  *  *) ::Get1Resource('WBds', rid);	//destroy_h: in this method	ThrowIfResError_();			//Do nothing if there is no resource	if ( rect_h != 0 )	{		//search for resource succeeded -- retrieve it		its_bds = **rect_h;		 		ReleaseResource_(Handle(rect_h)); 	}  	doc_p->close_res_fork();}	