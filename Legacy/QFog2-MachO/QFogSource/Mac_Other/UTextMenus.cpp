//CW9 last time this file appeared in CW distribution//Used to be under //PP Cookbook Examples/Common f/UTextMenus.h//Cookbook examples: Controls, Hilbert, Menus, PaneView// ===========================================================================//	UTextMenus.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	This file contains classes and functions to handle the Font, Size and Style//	menus. It relies on the fact that the menu IDs of these menus are MENU_Font//	MENU_Size, and MENU_Style as defined in PP_Resources.h.////	You can use these functions in your own programs, but bear in mind that//	for world-wide code, you may want to alter some of the routines to be//	more robust. In particular, USizeMenu::GetFontSize() may need to be revised//	to handle non-Roman scripts and USizeMenu::AdjustMenu() should use resources//	to display the "Other (nn)É" string.#include <Fonts.h>#include "UTextMenus.h"LMenu		*UTextMenusBase::sFontMenu =	nil;MenuHandle	UTextMenusBase::sFontMenuH =	nil;LMenu		*UTextMenusBase::sSizeMenu = 	nil;MenuHandle	UTextMenusBase::sSizeMenuH = 	nil;LMenu		*UTextMenusBase::sStyleMenu	=	nil;MenuHandle	UTextMenusBase::sStyleMenuH =	nil;//----------------------------------------------------------------------------//		¥ UTextMenusBase::XAble (by menu object)//----------------------------------------------------------------------------//	Given a menu handle, enable or disable the entire menuvoidUTextMenusBase::XAble(	LMenu	*	inMenu,	Boolean		inEnable){	if (inMenu == nil)		return;	MenuHandle	menuH = inMenu->GetMacMenuH();	XAble(menuH, inEnable);}//----------------------------------------------------------------------------//		¥ UTextMenusBase::XAble (by menu handle)//----------------------------------------------------------------------------//	Given a menu handle, enable or disable the entire menuvoidUTextMenusBase::XAble(	MenuHandle	inMenuH,	Boolean		inEnable){	if (inMenuH == nil)		return ;	if (inEnable)		::EnableMenuItem(inMenuH, 0);	else		::DisableMenuItem(inMenuH, 0);}//----------------------------------------------------------------------------//		¥ UTextMenusBase::XAble (by ID)//----------------------------------------------------------------------------//	Given a menu ID, enable or disable the entire menuvoidUTextMenusBase::XAble(	ResIDT	inMenuID,	Boolean	inEnable){	MenuHandle	menuH = ::GetMenuHandle(inMenuID);	ThrowIfNil_(menuH);//tucci	XAble(menuH, inEnable);}//----------------------------------------------------------------------------//		¥ UTextMenusBase::XAbleEveryItem (by menu object)//----------------------------------------------------------------------------//	Given a menu object, enable or disable all the synthetic items in the menuvoidUTextMenusBase::XAbleEveryItem(	LMenu	*	inMenu,	Boolean		inEnable,	Boolean		inUnmarkAll,	Boolean		inSetStyleNormal){	if (inMenu == nil)		return;	XAbleEveryItem(inMenu->GetMacMenuH(), inEnable, inUnmarkAll, inSetStyleNormal);}//----------------------------------------------------------------------------//		¥ UTextMenusBase::XAbleEveryItem (by menu handle)//----------------------------------------------------------------------------//	Given a menu handle, enable or disable all the items in the menuvoidUTextMenusBase::XAbleEveryItem(	MenuHandle	inMenuH,	Boolean		inEnable,	Boolean		inUnmarkAll,	Boolean		inSetStyleNormal){	if (inMenuH == nil)		return ;	SInt16	itemCount = ::CountMenuItems(inMenuH);	for (short i = 1; i <= itemCount; i++) {		if (inEnable)			::EnableMenuItem(inMenuH, i);		else			::DisableMenuItem(inMenuH, i);				if (inUnmarkAll)			::SetItemMark(inMenuH, i, noMark);		if (inSetStyleNormal)			::SetItemStyle(inMenuH, i, normal);	}}//----------------------------------------------------------------------------//		¥ UTextMenusBase::XAbleEveryItem (by ID)//----------------------------------------------------------------------------//	Given a menu ID, enable or disable all the items in the menuvoidUTextMenusBase::XAbleEveryItem(	ResIDT	inMenuID,	Boolean	inEnable,	Boolean	inUnmarkAll,	Boolean	inSetStyleNormal){	XAbleEveryItem(LMenuBar::GetCurrentMenuBar()->FetchMenu(inMenuID),				inEnable, inUnmarkAll, inSetStyleNormal);}#pragma	mark ==font==//----------------------------------------------------------------------------//		¥ UFontMenu::Initialize//----------------------------------------------------------------------------//	Set up the Font menu. Call this function from your application's//	constructor.voidUFontMenu::Initialize(Boolean inEnabled){	MenuHandle	menuH = ::GetMenuHandle(MENU_Font);	SignalIf_(menuH == nil);		AppendResMenu(menuH, 'FONT');	sFontMenu = LMenuBar::GetCurrentMenuBar()->FetchMenu(MENU_Font);	sFontMenuH = menuH;	if (inEnabled)		EnableMenu();	else		DisableMenu();}//----------------------------------------------------------------------------//		¥ UFontMenu::AdjustMenu//----------------------------------------------------------------------------//	Place a check mark next to the font name that corresponds to the given//	font item number. Turns off marks for all other font names.voidUFontMenu::AdjustMenu(	SInt16	inCurrentFontItem){	SignalIf_(sFontMenuH == nil);	SInt16	itemCount = ::CountMenuItems(sFontMenuH);	for (short i = 1; i <= itemCount; i++) {		::EnableMenuItem(sFontMenuH, i);		::CheckMenuItem(sFontMenuH, i, i == inCurrentFontItem);	}}//----------------------------------------------------------------------------//		¥ UFontMenu::DisableMenu//----------------------------------------------------------------------------//	Disable the font menu.voidUFontMenu::DisableMenu()	// +++ possible inline{	XAble(sFontMenuH, false);}//----------------------------------------------------------------------------//		¥ UFontMenu::EnableMenu//----------------------------------------------------------------------------//	Enable the font menu.voidUFontMenu::EnableMenu()		// +++ possible inline{	XAble(sFontMenuH, true);}//----------------------------------------------------------------------------//		¥ UFontMenu::DisableEveryItem//----------------------------------------------------------------------------//	Disable each item in the font menu.//	Because the Menu Manager uses a long word for the enable/disable flags,//	only the first 31 items will be disabled.voidUFontMenu::DisableEveryItem()		// +++ possible inline{	XAbleEveryItem(sFontMenuH, false, true, true);}//----------------------------------------------------------------------------//		¥ UFontMenu::EnableItems//----------------------------------------------------------------------------//	Enable each item in the font menu.voidUFontMenu::EnableEveryItem()		// +++ possible inline{	XAbleEveryItem(sFontMenuH, true, true, true);}//----------------------------------------------------------------------------//		¥ UFontMenu::GetFontNumber//----------------------------------------------------------------------------//	Given an item number in the Font menu, return the corresponding font number.SInt16UFontMenu::GetFontNumber(	SInt16 inMenuItem){	Str255		fontName;	SInt16		fontNumber;	SignalIf_(sFontMenuH == nil);		::GetMenuItemText(sFontMenuH, inMenuItem, fontName);	::GetFNum(fontName, &fontNumber);	return fontNumber;}//----------------------------------------------------------------------------//		¥ UFontMenu::GetFontNumber//----------------------------------------------------------------------------//	Given a font number, return the item number of the font's name in the Font//	menu.SInt16UFontMenu::GetFontItemNumber(	SInt16	inFontNumber){	if (sFontMenuH == nil)		return 0;	SInt16	itemCount = ::CountMenuItems(sFontMenuH);	for (short i = 1; i <= itemCount; i++) {		Str255	fontName;		SInt16	fontNumber;				::GetMenuItemText(sFontMenuH, i, fontName);		::GetFNum(fontName, &fontNumber);				if (fontNumber == inFontNumber)			return i;	}	return -1;}#pragma	mark ==size==//----------------------------------------------------------------------------//		¥ USizeMenu::Initialize//----------------------------------------------------------------------------//	Initialize the Size menu by specifying how many items at the end of the size//	menu are not font sizes. The default, kDefaultReservedItems, is based on//	the Size menu illustrated in Inside Macintosh:Macintosh Toolbox Essentials//	page 3-82. Note that the Size menu given there includes the commands "Larger"//	and "Smaller" as well as the "Other" command. The Size menu given in the//	Macintosh Human Interface Guidlines (pg 122) has only the "Other" command.//	The USizeMenu class assumes that all items except the last reserved items//	are point sizes. If there is at least one reserved items, it is assumed//	to be the "Other" command.SInt16 USizeMenu::mReservedItems = kDefaultReservedItems;voidUSizeMenu::Initialize(	SInt16	inReservedItems,	Boolean	inEnabled){	MenuHandle	menuH = GetMenuHandle(MENU_Size);	SignalIf_(menuH == nil);	sSizeMenu = LMenuBar::GetCurrentMenuBar()->FetchMenu(MENU_Size);	sSizeMenuH = menuH;	mReservedItems = inReservedItems;	if (inEnabled)		EnableMenu();	else		DisableMenu();}//----------------------------------------------------------------------------//		¥ myStringToNum [static]//----------------------------------------------------------------------------//	Utility used the USizeMenu routines to convert strings to numbers that//	ignores anything that's not a number#define	IsNumber_(x)	((x) >= '0' && (x) <= '9')static voidmyStringToNum(Str255 inString, SInt32 * outNum){	SInt16 i;	for (i = 1; i <= inString[0]; i++)		if (!IsNumber_(inString[i]))			break;	inString[0] = i-1;	::StringToNum(inString, outNum);}//----------------------------------------------------------------------------//		¥ USizeMenu::AdjustMenu//----------------------------------------------------------------------------//	Call this function from the FindCommandStatus() function of the commander//	that uses the Size menu.////	Places a check mark next to the item that corresponds to the given size.//	If there is a "real font" of that size for the given font, use outline style//	for the menu item. (Note that we change the style manually here since style is//	not one of the parameters that FindCommandStatus() returns.)////	The application's UpdateMenus() function calls FindCommandStatus() for each//	menu after it goes through each command number. You can detect this case//	when the item number is 0. That's when we take the opportunity to put a check mark//	on the "Other" item at the end of the menu and to place the current size in//	parentheses if it's not one of the standard sizes.//	(See the comment above for USizeMenu::Initialize about reserved items.)voidUSizeMenu::AdjustMenu(	SInt16			inMenuItem,	SInt16			inCurrentSize,	SInt16			inCurrentFont,	Boolean		&	outEnabled,	Boolean		&	outUsesMark,	UInt16		&	outMark){	SignalIf_(sSizeMenuH == nil);	Str255		itemString;	static Boolean sizeItemChecked = 0;	if (inMenuItem == 1)		sizeItemChecked = 0;	::GetMenuItemText(sSizeMenuH, inMenuItem, itemString);		if (inMenuItem > 0) {		SInt32	size;		outEnabled = true;		outUsesMark = true;		myStringToNum(itemString, &size);			outMark = (size == inCurrentSize ? checkMark : noMark);		sizeItemChecked |= (size == inCurrentSize);		::SetItemStyle(sSizeMenuH, inMenuItem, RealFont(inCurrentFont, size) ? outline : normal);	} else {		if (mReservedItems <= 0)			return ;		SInt16	numItems = ::CountMenuItems(sSizeMenuH);		::CheckMenuItem(sSizeMenuH, numItems, !sizeItemChecked);		LString::CopyPStr("\pOther", itemString);			if (!sizeItemChecked) {			Str255	sizeString;			NumToString(inCurrentSize, sizeString);						LString::AppendPStr(itemString, "\p (");			LString::AppendPStr(itemString, sizeString);			LString::AppendPStr(itemString, "\p)");		}			LString::AppendPStr(itemString, "\pÉ");		::SetMenuItemText(sSizeMenuH, numItems, itemString);	}}//----------------------------------------------------------------------------//		¥ USizeMenu::DisableMenu//----------------------------------------------------------------------------//	Disable the font menu.voidUSizeMenu::DisableMenu()	// +++ possible inline{	XAble(sSizeMenuH, false);}//----------------------------------------------------------------------------//		¥ USizeMenu::EnableMenu//----------------------------------------------------------------------------//	Enable the font menu.voidUSizeMenu::EnableMenu()		// +++ possible inline{	XAble(sSizeMenuH, true);}//----------------------------------------------------------------------------//		¥ USizeMenu::DisableEveryItem//----------------------------------------------------------------------------//	Disable each item in the size menu.voidUSizeMenu::DisableEveryItem()		// +++ possible inline{	XAbleEveryItem(sSizeMenuH, false, true, true);}//----------------------------------------------------------------------------//		¥ USizeMenu::EnableItems//----------------------------------------------------------------------------//	Enable each item in the size menu.voidUSizeMenu::EnableEveryItem()		// +++ possible inline{	XAbleEveryItem(sSizeMenuH, true, true, true);}//----------------------------------------------------------------------------//		¥ USizeMenu::GetFontSize//----------------------------------------------------------------------------//	Given a menu item in the Size menu, return the corresponding font size.SInt16USizeMenu::GetFontSize(	SInt16 inMenuItem){	Str255		sizeString;	SInt32		fontSize;	SignalIf_(sSizeMenuH == nil);		GetMenuItemText(sSizeMenuH, inMenuItem, sizeString);		myStringToNum(sizeString, &fontSize);		return fontSize;}#pragma	mark ==style==//----------------------------------------------------------------------------//		¥ UStyleMenu::Initialize//----------------------------------------------------------------------------//	Set up the Style menu. Call this function from your application's//	constructor.voidUStyleMenu::Initialize(Boolean inEnabled){	MenuHandle	menuH = GetMenuHandle(MENU_Style);	SignalIf_(menuH == nil);	sStyleMenu = LMenuBar::GetCurrentMenuBar()->FetchMenu(MENU_Style);	sStyleMenuH = menuH;		if (inEnabled)		EnableMenu();	else		DisableMenu();}//----------------------------------------------------------------------------//		¥ UStyleMenu::DisableMenu//----------------------------------------------------------------------------//	Disable the style menu.voidUStyleMenu::DisableMenu()		// +++ possible inline{	XAble(sStyleMenuH, false);}//----------------------------------------------------------------------------//		¥ UStyleMenu::EnableMenu//----------------------------------------------------------------------------//	Enable the style menu.voidUStyleMenu::EnableMenu()		// +++ possible inline{	XAble(sStyleMenuH, true);}