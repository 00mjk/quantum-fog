#include "C_MARGINED_SCROLLER.h"#pragma mark --creation/destruction--//******************************************C_MARGINED_SCROLLER::C_MARGINED_SCROLLER(LStream  *		inStream)	//in	:LScroller(inStream){}//******************************************C_MARGINED_SCROLLER::C_MARGINED_SCROLLER(){}//******************************************C_MARGINED_SCROLLER::~C_MARGINED_SCROLLER(){}#pragma mark --scrolling--//******************************************VOID	C_MARGINED_SCROLLER::VertScroll(SInt16		inPart)		//in{//NONTRIVIAL EXCERPT FROM PP// same as PP method except for lines marked "diff"	long startTicks = ::TickCount();//diff		SPoint32		scrollUnit;	SDimension16	scrollFrameSize;	SInt16			vertUnits = 0;		mScrollingView->GetScrollUnit(scrollUnit);	mScrollingView->GetFrameSize(scrollFrameSize);		switch (inPart) {				// Determine how much to scroll			case kControlUpButtonPart:	// Scroll up one unit			vertUnits = -1;			break;					case kControlDownButtonPart:	// Scroll down one unit			vertUnits = 1;			break;					case kControlPageUpPart:		// Scroll up by Frame height										//   less one unit of overlap			vertUnits = 1 - (scrollFrameSize.height / scrollUnit.v);			if (vertUnits >= 0) {				vertUnits = -1;			}			break;					case kControlPageDownPart:		// Scroll down by Frame height										//   less one unit of overlap			vertUnits = (scrollFrameSize.height / scrollUnit.v) - 1;			if (vertUnits <= 0) {				vertUnits = 1;			}			break;	}		if (vertUnits != 0) {		mVerticalBar->IncrementValue(vertUnits);		mScrollingView->ScrollPinnedImageBy(0, vertUnits * scrollUnit.v, true);									// Scrolling changes the focus. The									// Mac Control Manager will be very									// unhappy if we don't restore focus									// to the ScrollBar											its_left_margin_p->ScrollPinnedImageBy(0, vertUnits * scrollUnit.v, true);//diff											mVerticalBar->FocusDraw();	}		//	this puts an upper speed limit on scroll rate.//diff	while (startTicks + 10>=::TickCount()){}//diff	}//******************************************VOID	C_MARGINED_SCROLLER::HorizScroll(SInt16		inPart)		//in{//NONTRIVIAL EXCERPT FROM PP// same as PP method except for lines marked "diff"	long startTicks = ::TickCount();//diff		SPoint32		scrollUnit;	SDimension16	scrollFrameSize;	SInt16			horizUnits = 0;		mScrollingView->GetScrollUnit(scrollUnit);	mScrollingView->GetFrameSize(scrollFrameSize);		switch (inPart) {				// Determine how much to scroll			case kControlUpButtonPart:	// Scroll left one unit			horizUnits = -1;			break;					case kControlDownButtonPart:	// Scroll right one unit			horizUnits = 1;			break;					case kControlPageUpPart:		// Scroll left by Frame width										//   less one unit of overlap			horizUnits = 1 - (scrollFrameSize.width / scrollUnit.h);			if (horizUnits >= 0) {				horizUnits = -1;			}			break;					case kControlPageDownPart:		// Scroll right by Frame width										//   less one unit of overlap			horizUnits = (scrollFrameSize.width / scrollUnit.h) - 1;			if (horizUnits <= 0) {				horizUnits = 1;			}			break;	}		if (horizUnits != 0) {		mHorizontalBar->IncrementValue(horizUnits);		mScrollingView->ScrollPinnedImageBy(horizUnits * scrollUnit.h, 0, true);									// Scrolling changes the focus, the									// Mac Control Manager will be very									// unhappy if we don't restore focus									// to the ScrollBar									its_top_margin_p->ScrollPinnedImageBy(horizUnits * scrollUnit.h, 0, true);//diff				mHorizontalBar->FocusDraw();	}		//	this puts an upper speed limit on scroll rate.//diff	while (startTicks + 10>=::TickCount()){}//diff	}//******************************************VOID	C_MARGINED_SCROLLER::ListenToMessage(MessageT	inMessage,		//inVOID  *		ioParam)		//i-o{	//MONITOR_THE_CHANGE_HERE		//NONTRIVIAL EXCERPT FROM PP	// same as PP method except for lines marked "diff"	if (inMessage == msg_ThumbDragged) {		LStdControl	* 	theSBar = static_cast<LStdControl *>(ioParam);		SInt32			scrollValue = theSBar->GetValue();		SPoint32		scrollUnit;		mScrollingView->GetScrollUnit(scrollUnit);		SPoint32		scrollPosition;		mScrollingView->GetScrollPosition(scrollPosition);		if (theSBar == mVerticalBar) {			scrollPosition.v = scrollValue * scrollUnit.v;			its_left_margin_p->ScrollPinnedImageTo(0, scrollPosition.v, true);//diff					} else if (theSBar == mHorizontalBar) {			scrollPosition.h = scrollValue * scrollUnit.h;			its_top_margin_p->ScrollPinnedImageTo(scrollPosition.h, 0, true);//diff					}		mScrollingView->ScrollPinnedImageTo(scrollPosition.h, scrollPosition.v,										true);		AdjustScrollBars();	}}