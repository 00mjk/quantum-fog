#include "C_DOC.h"#include "C_MAIN_VIEW.h"#include "QB_NET.h"#include "DICTIONARY.h"#include "NODE.h"#include "C_APP.h"#include "C_PROJECT_MENU.h"#include "C_KEYS.h"#include "UOnyx.h"#include "EXCEPTIONS.h"#include "UModalDialogsPlus.h"#include <Printing.h>#if  _do_debug	extern LONG	req_stack_space;#endif#include <ctype.h>#pragma mark --creation/destruction--//******************************************//	Name a new, untitled document window////	Untitled windows start with "QFog Net-1", then "QFog Net-2",//	"QFog Net-3", etc. Old numbers are reused, so there won't be//	gaps in the numbering.//VOID	C_DOC::name_new_doc(){	//called from C_DOC()	// Start with the default name ("QFog Net-1")	LStr255	name = "\pUntitled-1";	long	num = 1;	while (UWindows::FindNamedWindow(name) != nil) {						// An existing window has the current name			// Increment counter and try again		num++;		name = "\pUntitled-";		name += (LStr255)num;		/* old way of appending:		Str15	num_pstr;		::NumToString(num, num_pstr);		LString::AppendPStr(name, num_pstr);		*/	}			// Finally, set window title	mWindow->SetDescriptor(name);			}//******************************************//	Open a new document for the specified FileVOID	C_DOC::open_file(FSSpec	 & in_fs_spec)	//in{	//called from C_DOC().	// Create a new File object, read the entire File contents,	// put the contents into the main view, and set the Window	// title to the name of the File.//Initially I used LHandleStream to save files.//This is no good for large files since LHandleStream has no file buffer.//Now I use LFileStream which takes advantage of ::FSWrite(),//which has a file buffer.//start LHandleStream use/*			Try_ {			mFile = new LFile(in_fs_spec);		//delete:	PP deletes mFile via ~C_DOC()->~LSingleDoc()		ThrowIfNil_(mFile);				read_vers_res(its_vers_int32);		mFile->OpenDataFork(fsRdWrPerm);		Handle	data_h = mFile->ReadDataFork();		//create_h: 	PP creates data_h in LFile::ReadDataFork() with call to ::NewHandle().		//throwif_h: 	PP calls ThrowIfMemFail_() immediately after creation.		//destroy_h:	PP destroys data_h in ~LHandleStream(). See below.						mFile->CloseDataFork();		LHandleStream   net_stream(data_h);					DisposeHandle_((Handle)mPrintRecordH);				net_stream>>(Handle)mPrintRecordH;		UPrintingMgr::ValidatePrintRecord(mPrintRecordH);		its_mview_p->read_net_stream(&net_stream, open_reco);						mWindow->SetDescriptor(in_fs_spec.name);		// Flag that document has an associated file.		mIsSpecified = true;				//Important: this makes the main view the initial target 		//rather than some node efield		LCommander::SwitchTarget((LCommander  *)its_mview_p);							}*///end LHandleStream use//start LFileStream use	try {			mFile = new LFileStream(in_fs_spec);		//delete:	PP deletes mFile via ~C_DOC()->~LSingleDoc()		ThrowIfNil_(mFile);		LFileStream  * 	net_stream_p = dynamic_cast<LFileStream  *>(mFile);						read_vers_res(its_vers_int32);		//Don't load bounds if app and doc versions are not the same,		//because sizes of fixed-sized windows may have changed.		if(k_vers_app==its_vers_int32){		 	its_mview_p->read_bounds_res_of_satellite_winds();		}		mFile->OpenDataFork(fsRdWrPerm);/*	//old		DisposeHandle_((Handle)mPrintRecordH);		UPrintingMgr::ValidatePrintRecord(mPrintRecordH);*/		if(get_vers_int32()<= k_vers_160){			Handle temp_h = nil;			//destroy_h: in this method			net_stream_p->ReadHandle(temp_h);//read_net			DisposeHandle_(temp_h);		}		its_mview_p->read_net_stream(*net_stream_p, open_reco);//read_net				mFile->CloseDataFork();						mWindow->SetDescriptor(in_fs_spec.name);		// Flag that document has an associated file.		mIsSpecified = true;				//Important: this makes the main view the initial target 		//rather than some node efield		LCommander::SwitchTarget((LCommander  *)its_mview_p);							}//end LFileStream use		catch(...) {		// Cleanup and rethrow the error.		delete this;		throw;	}}//******************************************//Creates a new doc (window + file).//It always creates (opens) the window.//If a file spec is given, it creates a file with that file spec.//If no file spec is given, file creation is postponed.C_DOC::C_DOC(LCommander	 * in_super_p,		//inFSSpec  * in_fs_spec_p)		//in	:LSingleDoc(in_super_p), //makes mIsModified = false	its_vers_int32(k_vers_app),	its_has_ecases_file(false),	its_has_nd_probs_file(false),	its_has_bi_nd_probs_file(false),		its_has_stories_file(false),			its_evid_stream_p(0),			its_nd_probs_stream_p(0),	its_bi_nd_probs_stream_p(0),	its_stories_stream_p(0),			its_do_one_ecase_at_a_time(false),	its_ecase(0),	its_illustrate_stories(false)		{	its_io_folder_fs_spec.name[0]=0;	its_io_prefix="";	its_ecases_fs_spec.name[0]=0;	its_nd_probs_fs_spec.name[0]=0;	its_bi_nd_probs_fs_spec.name[0]=0;	its_stories_fs_spec.name[0]=0;	// Create window for our document.	// Main window will be created initially invisible. (There is a flag in PPob for this.)		//the SuperCommander of a C_DOC is the C_APP (top commander)	//the SuperCommander of a main window is a C_DOC	mWindow = LWindow::CreateWindow(main_window_rid, this);//SuperCommander declared	its_main_wind_cap_p =(LCaption  *)(mWindow->FindPaneByID(main_wind_cap_rid));	its_mview_p =(C_MAIN_VIEW  *)(mWindow->FindPaneByID(mview_rid));		its_net_p = new QB_NET();	//delete:	ThrowIfNil_(its_net_p);	its_net_p->set_doc_and_mview_ptrs(this, its_mview_p);	//its_mview_p already knows doc_p	its_mview_p->set_net_ptr(its_net_p);	//Now doc, mview, net each has a pointer to the other two			// Set name of window or open file.		if (in_fs_spec_p == nil) {		//mFile creation delayed until DoAESave() called		name_new_doc();							} else {		//this creates an mFile		open_file(*in_fs_spec_p);		}	//so far we've only initialized data members. Next do other shores.		its_net_p->set_run_state(bef_run);		mWindow->SetLatentSub(its_mview_p);	//Drawing all at once prevents blinking.	mWindow->Show();		C_PROJECT_MENU::insert_doc(this);}//******************************************C_DOC::~C_DOC(){	if(its_net_p!=0){		delete its_net_p;		its_net_p = 0;	} 	C_PROJECT_MENU::remove_doc(this);}#pragma mark --mFile s resources--//******************************************VOID	C_DOC::write_app_name_res(){	//Refs: 	//(1)	Contributed PP class: UWindowState	//(2)	docs generated by MacWrite Pro 1.01	//(3)	Think Ref., under <<Messages when finder can not find your application>>	//(4) 	Develop-18 article on preferences file	StringPtr  pstr = "\pQuantum Fog";		mFile->OpenResourceFork(fsRdWrPerm);	//not necessary since just opened its res fork	//	::UseResFile(mFile->GetResourceForkRefNum());	SLDisable_();	Handle  app_name_h = ::Get1Resource('STR ', -16396);	//create_h: 		This Get1Resource() creates the memory for app_name_h	//			If not then the NewHandle() does	//throwif_h:	I throwif below after Get1Resource() and NewHandle()	//destroy_h:	I release app_name_h below	SLEnable_();	//don't use ThrowIfResFail_(app_name_h) because handle may be zero	ThrowIfResError_();	if(app_name_h != 0){		//an app name resource already exists -- no need to update	}else{		//no app name resource has yet been saved -- add it		app_name_h = ::NewHandle(pstr[0] + 1);		//create_h:		I create app_name_h with call to ::NewHandle().		//throwif_h:	I call ThrowIfMemFail_ above.		//destroy_h:	in this method		ThrowIfMemFail_(app_name_h);		StHandleState saved_h(app_name_h);//preserve handle state		::HLock(app_name_h);//saved handle state		::BlockMoveData(pstr, *app_name_h, pstr[0] + 1);		::HUnlock(app_name_h);//saved handle state		//convert non-resource handle into resource one.		//changes: memory res map 		::AddResource( app_name_h, 'STR ', -16396, 0);	}	//changes: disk res map, disk res	::UpdateResFile(mFile->GetResourceForkRefNum());	//release handle memory and change memory res map AFTER writing to disk	ReleaseResource_(app_name_h);	mFile->CloseResourceFork();}//******************************************VOID	C_DOC::write_vers_res(){	USHORT vers_rid = 1;	::UseResFile(C_APP::get_res_file_ref_num());	VersRecHndl  app_vers_h = (VersRecHndl)::Get1Resource('vers', vers_rid);	//create_h: 	This creates the memory for app_vers_h	//throwif_h:	I throwif below	//destroy_h:	in this method	ThrowIfResFail_(app_vers_h);	mFile->OpenResourceFork(fsRdWrPerm);//not necessary since just opened its res fork//	::UseResFile(mFile->GetResourceForkRefNum());	SLDisable_();	VersRecHndl  doc_vers_h = (VersRecHndl)::Get1Resource('vers', vers_rid);	//destroy_h: in this method	SLEnable_();	//don't use ThrowIfResFail_(doc_vers_h) because handle may be zero	ThrowIfResError_();	if(doc_vers_h != 0){		// a vers resource already exists -- remove it		::RemoveResource((Handle)doc_vers_h);		::UpdateResFile(mFile->GetResourceForkRefNum());		DisposeHandle_((Handle)doc_vers_h);	}			// 		Alternative to using HandToHand()//		short  	res_size = ::GetResourceSizeOnDisk(app_vers_h);//		doc_vers_h = ::NewHandle(res_size);//		//destroy_h://		ThrowIfMemFail_(doc_vers_h);//		StHandleState saved_h(app_vers_h);//		::HLock(app_vers_h); ::HLock(doc_vers_h);//		::BlockMoveData(*app_vers_h, *doc_vers_h, res_size);//		::HUlock(app_vers_h); ::HUlock(doc_vers_h);		doc_vers_h = app_vers_h;	ThrowIfOSErr_(::HandToHand((Handle *) &doc_vers_h));	//create_h: 	HandToHand() creates the memory for doc_vers_h	//throwif_h:	I throwif below. 	//destroy_h:	in this method	ThrowIfMemFail_(doc_vers_h);	//convert non-resource handle into resource one.	//changes: memory res map 	::AddResource( (Handle)doc_vers_h, 'vers', vers_rid, 0);	//changes: disk res map, disk res	::UpdateResFile(mFile->GetResourceForkRefNum());	//release handle memory and change memory res map AFTER writing to disk	ReleaseResource_((Handle)doc_vers_h);	mFile->CloseResourceFork();			ReleaseResource_((Handle)app_vers_h);	}/*from <Script.h>****************************// Regional version codes 	verUS						= 0,	verFrance					= 1,	verBritain					= 2,	verGermany					= 3,	verItaly					= 4,	verNetherlands				= 5,	verFrBelgiumLux				= 6,	// French for Belgium & Luxembourg 	verSweden					= 7,	verSpain					= 8,	verDenmark					= 9,	verPortugal					= 10,	verFrCanada					= 11,	verNorway					= 12from <Types.h>*************************// 'vers' resource format struct VersRec {	NumVersion		numericVersion;		//encoded version number	short			countryCode;		//country code from intl utilities	Str255			shortVersion;		//version number string - worst case	Str255			reserved;			//longMessage string packed after shortVersion};typedef struct VersRec VersRec;typedef VersRec *						VersRecPtr;typedef VersRecPtr *					VersRecHndl;// Numeric version part of 'vers' resource struct NumVersion {	UInt8		majorRev;//1st part of version number in BCD	UInt8		minorAndBugRev;//2nd & 3rd part of version number share a byte	UInt8		stage;//stage code: dev, alpha, beta, final	UInt8		nonRelRev;//revision level of non-released version};typedef struct NumVersion NumVersion;enum {				// Version Release Stage Codes	developStage				= 0x20,	alphaStage					= 0x40,	betaStage					= 0x60,	finalStage					= 0x80};How to extricate minor and bug revisions:	USHORT		minor_rev = num_vers.minorAndBugRev >> 4;	USHORT		bug_rev = num_vers.minorAndBugRev & 0x0f;*///******************************************VOID   C_DOC::read_vers_res(SInt32  &	vers_int32)	//i-o{	//see also versions_are _equal() in GLOBAL_FUN.h	mFile->OpenResourceFork(fsRdWrPerm);		SHORT 	vers_rid = 1;	::UseResFile(mFile->GetResourceForkRefNum());		VersRecHndl  vers_h = (VersRecHndl)::Get1Resource('vers', vers_rid);	//destroy_h: in this method	ThrowIfResFail_(vers_h);	NumVersion	num_vers = (**vers_h).numericVersion;	vers_int32 = *((SInt32 *)(&num_vers));	ReleaseResource_((Handle) vers_h);	mFile->CloseResourceFork();}#pragma mark --about mWindow and mFile--//******************************************//	Save the entire Document to its associated File (which must already exist)VOID	C_DOC::DoSave(){	if(its_vers_int32!=k_vers_app){				if(!UModalDialogsPlus::AskForPermission(this, per_dial_rid, per_dial_cap_rid, 		"\pClicking OK will save file in a newer format. Press Cancel to abort save operation.")){			 return;		}else{			its_vers_int32=k_vers_app;		}	} 	SetModified(false);			// Saving makes doc un-modified//start LHandleStream use/*	LHandleStream   net_stream;	net_stream<<(Handle)mPrintRecordH;	its_mview_p->write_net_handle(net_stream, open_reco);	Handle 	data_h = net_stream.GetDataHandle();	//create_h:		PP creates data_h in LHandleStream() with call to ::NewHandle().	//throwif_h:	PP calls ThrowIfMemFail_(mDataH) immediately after creation.	//destroy_h:	PP destroys data_h inside ~LHandleStream().	ThrowIfNil_(data_h);		mFile->OpenDataFork(fsRdWrPerm);	StHandleState saved_h(data_h);//preserve handle state	::HLock(data_h);//saved handle state	mFile->WriteDataFork(*data_h, ::GetHandleSize(data_h));	mFile->CloseDataFork();*///end LHandleStream use//start LFileStream use	LFileStream  * 	net_stream_p = dynamic_cast<LFileStream  *>(mFile);	mFile->OpenDataFork(fsRdWrPerm);		//old:	//*net_stream_p<<(Handle)mPrintRecordH;	if(get_vers_int32()<= k_vers_160){		StHandleBlock temp_h(sizeof(TPrint));		*net_stream_p << (Handle) temp_h;//write_net	}	its_mview_p->write_net_stream(*net_stream_p, open_reco);//write_net	mFile->CloseDataFork();//end of LFileStream use	write_app_name_res();	write_vers_res();	its_mview_p->write_bounds_res_of_satellite_winds();}//******************************************//	Save Document in the specified file with the specified file type////	If file type is fileType_Default, use the normal file type for//	this documentVOID	C_DOC::DoAESave(FSSpec	&	inFileSpec,		//inOSType		inFileType)		//in{	//Calls DoSave()	//DoSave() calls SetModified(false)	delete mFile;						// Kill existing file//start LHandleStream use/*		mFile = new LFile(inFileSpec);		// Make new file object	//delete:	PP deletes mFile via ~C_DOC()->~LSingleDoc()*///end LHandleStream use	//start LFileStream use		mFile = new LFileStream(inFileSpec);		// Make new file object	//delete:	PP deletes mFile via ~C_DOC()->~LSingleDoc()//end of LFileStream use			ThrowIfNil_(mFile);	/*	fileType_Default = '****' according to Library Reference	DoAESave is called from 3 places, all in LDocument.		Function           inFileType in DoAESave()		AskSaveAs          fileType_Default	DoAEClose          fileType_Default	HandleAppleEvent   fileType_Default unless the Apple event specifies.	                   Then it could be anything.	*/		OSType	fileType;				if (inFileType == fileType_Default) {		fileType = my_file_type_id;	}else{		fileType = inFileType;	}	// Make new file on disk WITH BOTH A DATA AND RESOURCE FORK//	mFile->CreateNewDataFile(my_creator_id, fileType, 0);//only data fork	mFile->CreateNewFile(my_creator_id, fileType, 0);		// Write out data	DoSave();								// Change window name	mWindow->SetDescriptor(inFileSpec.name);	C_PROJECT_MENU::rename_doc(this);	// Document now has a specified file	mIsSpecified = true;			}//******************************************// To implement Revert(), I must first clear all data like node lists, etc..// Only then can I call read_net_stream() routines to bring in// the file version last saved on disk.// Deciding which data to clear is fairly error prone.// User can effectively do a Revert() by not to saving, quitting, and restarting. // so I won't implement it./*VOID	C_DOC::DoRevert(){}*/#pragma mark --printing--//******************************************//	Print the contents of the DocumentVOID	C_DOC::DoPrint(){		LPrintout  *  printout_p = LPrintout::CreatePrintout(printout_rid);	ThrowIfNil_(printout_p);	printout_p->SetPrintSpec(mPrintSpec);		LPlaceHolder  *	 placeholder_p = 		(LPlaceHolder  *)printout_p->FindPaneByID(placeholder_rid);	ThrowIfNil_(placeholder_p);			placeholder_p->InstallOccupant(its_mview_p, atNone);		printout_p->DoPrintJob();	delete printout_p;	printout_p = 0;}#pragma mark --import/export--//******************************************BOOLEAN  C_DOC::import_nd_sts(){	//Ref.:Think Ref., Jim Trudeau's book		BOOLEAN  cmd_obeyed = false;	UNavServicesDialogs::LFileChooser	chooser;	FSSpec fs_spec;	if (chooser.AskChooseOneFile(LFileTypeList((OSType) 'TEXT'), fs_spec)){		UCursor::SetTheCursor(watchCursor);		MY_IFSTREAM istream;		istream.mac_open(fs_spec);		its_net_p->create_nd_name_dictionary();					if(!its_net_p->read_nd_sts_file(istream)){			goto clean_up;		}		cmd_obeyed = true;		its_mview_p->refresh_pi_wind();						clean_up:;				its_net_p->kill_nd_name_dictionary();			istream.close();							UCursor::InitTheCursor();	}		return cmd_obeyed;	}//******************************************BOOLEAN  C_DOC::import_amps(){	//Ref.:Think Ref., Jim Trudeau's book	BOOLEAN  cmd_obeyed = false;		UNavServicesDialogs::LFileChooser	chooser;	FSSpec fs_spec;	if (chooser.AskChooseOneFile(LFileTypeList((OSType) 'TEXT'), fs_spec)){		UCursor::SetTheCursor(watchCursor);		MY_IFSTREAM istream;		istream.mac_open(fs_spec);		its_net_p->create_dictionaries();					if(!its_net_p->read_amps_file(istream)){			goto clean_up;		}		cmd_obeyed = true;		its_mview_p->refresh_pi_wind();					clean_up:;		its_net_p->kill_dictionaries();		istream.close();						UCursor::InitTheCursor();	}		return cmd_obeyed;	}//******************************************VOID  C_DOC::export_topology(){	UNavServicesDialogs::LFileDesignator putFile;	LString::CopyPStr("\pExport Topology", putFile.GetDialogOptions()->windowTitle);	LString::CopyPStr("\p", putFile.GetDialogOptions()->message);		if (putFile.AskDesignateFile("\p")){		UCursor::SetTheCursor(watchCursor);		MY_OFSTREAM  strm;		FSSpec  fs_spec;		putFile.GetFileSpec(fs_spec);		strm.mac_open(fs_spec);		its_net_p->write_topology_file(strm);		strm.close();		UCursor::InitTheCursor();	}}//******************************************VOID  C_DOC::export_nd_sts(){	UNavServicesDialogs::LFileDesignator putFile;	LString::CopyPStr("\pExport Node States", putFile.GetDialogOptions()->windowTitle);	LString::CopyPStr("\p", putFile.GetDialogOptions()->message);		if (putFile.AskDesignateFile("\p")){		UCursor::SetTheCursor(watchCursor);		MY_OFSTREAM  strm;		FSSpec  fs_spec;		putFile.GetFileSpec(fs_spec);		strm.mac_open(fs_spec);		its_net_p->write_nd_sts_file(strm);		strm.close();		UCursor::InitTheCursor();	}}//******************************************VOID  C_DOC::export_amps(){	UNavServicesDialogs::LFileDesignator putFile;	LString::CopyPStr("\pExport Amplitudes", putFile.GetDialogOptions()->windowTitle);	LString::CopyPStr("\p", putFile.GetDialogOptions()->message);		if (putFile.AskDesignateFile("\p")){		UCursor::SetTheCursor(watchCursor);		MY_OFSTREAM  strm;		FSSpec  fs_spec;		putFile.GetFileSpec(fs_spec);		strm.mac_open(fs_spec);		its_net_p->write_amps_file(strm);		strm.close();		UCursor::InitTheCursor();	}}#pragma mark --handle modal dialogs--//******************************************BOOLEAN  C_DOC::handle_amps_filter_dialog(){	//this is a trivial generalization of UModalDialogs::AskForOneNumber	//if this function returns true, SetModified(true) called in ObeyCommand()	//af= amplitudes filter	StDialogHandler		d_handler(af_wind_rid, its_mview_p);//SuperCommander declared	LWindow  *			dialog_p = d_handler.GetDialog();	//des = desired	//cur = current	LEditField  * 	des_finesse_efield_p = 		(LEditField  *)dialog_p->FindPaneByID(af_des_finesse_efield_rid);	LCaption  * 	cur_finesse_cap_p = 		(LCaption  *)dialog_p->FindPaneByID(af_cur_finesse_cap_rid);	dialog_p->SetLatentSub(des_finesse_efield_p);	dialog_p->Show();	UCursor::SetTheCursor(watchCursor);		USHORT	cur_finesse = its_net_p->get_cur_finesse_of_amps();			cur_finesse_cap_p->SetValue(cur_finesse);	des_finesse_efield_p->SetValue(cur_finesse);			des_finesse_efield_p->SelectAll();	UCursor::InitTheCursor();	Str255		pstr;		USHORT	des_finesse; 	while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_Cancel:				return false;				break;			case msg_OK:				des_finesse_efield_p->GetDescriptor(pstr);					if(!STRINGY(pstr).is_ushort(des_finesse)){					my_gen_alert("Your size entry must be a non-negative integer.");					break;				}				//see LDocument::ObeyCommand() for an 				//example of a similar usage of ::CautionAlert()				//if(::CautionAlert(cannot_undo_alert_rid, nil) == ok){					if(des_finesse < cur_finesse){						UCursor::SetTheCursor(watchCursor);						its_net_p->filter_out_small_amps(des_finesse);						UCursor::InitTheCursor();						its_mview_p->refresh_pi_wind();					}				//}				return true;				break;		}	}	}/*//******************************************VOID	C_DOC::handle_preview_dialog(){//	if(! its_mview_p->ProcessCommand(cmd_close_all_non_main_winds)  )return;	if(! its_mview_p->save_pi()  )return;	UCursor::SetTheCursor(watchCursor);	DOUBLE 	out_prob=0;	USHORT	num_of_stories=0;	its_net_p->do_mini_run(out_prob, num_of_stories);			LStr255  str0, str1;	str0.Assign(out_prob, FIXEDDECIMAL, 6);	str1 = LONG(num_of_stories);//	::ErrorSound(0);//no Beep upon next alert // dpo	 	UCursor::InitTheCursor();	::ParamText(str0, str1, "\p", "\p");	UDesktop::Deactivate();	::Alert(preview_alert_rid, 0);	UDesktop::Activate();	//	::InitDialogs(0); // resets error sound and empties strings ^0, ^1, ^2, ^4}*///******************************************VOID	C_DOC::handle_preview_dialog(){//	if(! its_mview_p->ProcessCommand(cmd_close_all_non_main_winds)  )return;	if(! its_mview_p->save_pi()  )return;	DOUBLE 	out_prob=0;	USHORT	num_of_stories=0;	UCursor::SetTheCursor(watchCursor);	its_net_p->do_mini_run(out_prob, num_of_stories);	UCursor::InitTheCursor();			LStr255  str0, str1;	str0.Assign(out_prob, FIXEDDECIMAL, 6);	str1 = LONG(num_of_stories);		// this is a trivial generalization of UModalDialogs::AskForOneNumber	//pv = preview	StDialogHandler		d_handler(pv_window_rid, its_mview_p);//SuperCommander declared	LWindow  *		dialog_p = d_handler.GetDialog();		((LCaption  *)dialog_p->FindPaneByID(pv_total_prob_rid))->SetDescriptor(str0);		((LCaption  *)dialog_p->FindPaneByID(pv_num_of_stories_rid))->SetDescriptor(str1);	dialog_p->Show();	while (true) {		MessageT	hit_message = d_handler.DoDialog();		if(hit_message==msg_OK){ 			return;		}	}}//******************************************BOOLEAN  	C_DOC::handle_text_files_dialog(){	//this is a trivial generalization of UModalDialogs::AskForOneNumber	//tf = text files	StDialogHandler		d_handler(tf_window_rid, its_mview_p);//SuperCommander declared	LWindow  *		dialog_p = d_handler.GetDialog();			//cbox = check box, but=button, cap = caption	LCaption  *		folder_cap_p =				(LCaption  *)dialog_p->FindPaneByID(tf_folder_cap_rid);		LEditField  *	prefix_efield_p =				(LEditField  *)dialog_p->FindPaneByID(tf_prefix_efield_rid);		LStdCheckBox  * ecases_cbox_p = 		(LStdCheckBox  *)dialog_p->FindPaneByID(tf_ecases_cbox_rid);	LStdCheckBox  * nd_probs_cbox_p = 		(LStdCheckBox  *)dialog_p->FindPaneByID(tf_nd_probs_cbox_rid);	LStdCheckBox  * bi_nd_probs_cbox_p = 		(LStdCheckBox  *)dialog_p->FindPaneByID(tf_bi_nd_probs_cbox_rid);	LStdCheckBox  * stories_cbox_p = 		(LStdCheckBox  *)dialog_p->FindPaneByID(tf_stories_cbox_rid);	FSRef		ref;	OSErr 		err =::FSpMakeFSRef(&its_io_folder_fs_spec, &ref);	//an FSSpec object with all its members zero gives err==noErr==0!!		BOOLEAN		has_folder = (err==noErr)&&its_io_folder_fs_spec.name[0]!=0;	if((!has_folder)||its_io_prefix.get_len()==0){		its_has_ecases_file=false;		its_has_nd_probs_file=false;		its_has_bi_nd_probs_file=false;		its_has_stories_file=false;				its_ecases_fs_spec.name[0]=0;		its_nd_probs_fs_spec.name[0]=0;		its_bi_nd_probs_fs_spec.name[0]=0;		its_stories_fs_spec.name[0]=0;	}				UInt8 path[max_file_path_len];	LStr255 path255;	if(has_folder){		ThrowIfOSStatus_(::FSRefMakePath(&ref, path, max_file_path_len));		path255 = LString::CToPStr((char *)path);		if(path255[0]==255)path255[255]='-';		folder_cap_p->SetDescriptor(path255);	}else{		folder_cap_p->SetDescriptor("\p");	}			LStr255		prefix;	its_io_prefix.fill_LStr255(prefix);	prefix_efield_p->SetDescriptor(prefix);		ecases_cbox_p->SetValue(its_has_ecases_file?1:0);		nd_probs_cbox_p->SetValue(its_has_nd_probs_file?1:0);	bi_nd_probs_cbox_p->SetValue(its_has_bi_nd_probs_file?1:0);	stories_cbox_p->SetValue(its_has_stories_file?1:0);			dialog_p->Show();	FSSpec 		fs_spec;	SInt32		folder_DirID;	BOOLEAN		new_folder=false;			while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_tf_folder_but:				if(UNavServicesDialogs::AskChooseFolder(fs_spec, folder_DirID)){										ThrowIfOSStatus_(::FSpMakeFSRef(&fs_spec, &ref));					ThrowIfOSStatus_(::FSRefMakePath(&ref, path, max_file_path_len));					path255 = LString::CToPStr((char *)path);					if(path255[0]==255)path255[255]='-';					folder_cap_p->SetDescriptor(path255);					new_folder = true;																					}				//don't return yet				break; 			case msg_Cancel:				return false;				break;			case msg_OK:				prefix_efield_p->GetDescriptor(prefix);								its_io_prefix = prefix;				if(new_folder){					its_io_folder_fs_spec = fs_spec;					its_io_folder_DirID = folder_DirID;				}				if((has_folder||new_folder)&&(prefix[0]!=0)){					if(ecases_cbox_p->GetValue()==1){						its_has_ecases_file=true;						::FSMakeFSSpec(its_io_folder_fs_spec.vRefNum, its_io_folder_DirID, 						prefix + "\pEcases.txt", &its_ecases_fs_spec);					}else{						its_has_ecases_file=false;					}										if(nd_probs_cbox_p->GetValue()==1){						its_has_nd_probs_file=true;						::FSMakeFSSpec(its_io_folder_fs_spec.vRefNum, its_io_folder_DirID, 						prefix + "\pNodeProbs.txt", &its_nd_probs_fs_spec);					}else{						its_has_nd_probs_file=false;					}											if(bi_nd_probs_cbox_p->GetValue()==1){						its_has_bi_nd_probs_file=true;											::FSMakeFSSpec(its_io_folder_fs_spec.vRefNum, its_io_folder_DirID, 						prefix + "\pBinodeProbs.txt", &its_bi_nd_probs_fs_spec);					}else{						its_has_bi_nd_probs_file=false;					}										if(stories_cbox_p->GetValue()==1){						its_has_stories_file=true;						::FSMakeFSSpec(its_io_folder_fs_spec.vRefNum, its_io_folder_DirID, 						prefix + "\pStories.txt", &its_stories_fs_spec);					}else{						its_has_stories_file=false;					}				}				return true;				break;		}	}	}#pragma mark --go_forward() related--//******************************************BOOLEAN		C_DOC::open_files(){	//this function returns true if we get a good start, false otherwise	//The following facts can be demonstrated by the example	//in the folder called FILES TIED TO STREAMS		//AFTER a file-to-stream connection is established (with open()), you can move	//the file to another folder, and still write or read to its stream.	//The stream will keep track of its file and find it no matter where it is.	//So one need only worry about files missing BEFORE the file-to-stream connection	//is established.	//OUTPUT files:		//If you try to open an out stream with an FSSpec that no longer applies to any	//file, open() will create a new file with that FSSpec. So there is no need to check 	//the FSSpec before calling open() for the out files.		//INPUT files:	//If you try to open an in stream with an FSSpec that no longer applies to any	//file, open() will do nothing, fail. A failure to open can be detected with is_open().				if(its_has_ecases_file){		its_evid_stream_p = new MY_IFSTREAM();		//delete:	in C_DOC::close_files().	 		ThrowIfNil_(its_evid_stream_p);		its_evid_stream_p->mac_open(its_ecases_fs_spec);		if(!its_evid_stream_p->is_open()){			my_gen_alert("E-cases file is missing.");			delete its_evid_stream_p;			its_evid_stream_p = 0;			return false;				}						its_net_p->create_dictionaries();								if(!its_net_p->good_ecases_file(*its_evid_stream_p)){			its_net_p->kill_dictionaries();			its_evid_stream_p->close();			delete its_evid_stream_p;			its_evid_stream_p = 0;			return false;				}	}	if(its_has_nd_probs_file){		its_nd_probs_stream_p = new MY_OFSTREAM();		//delete:	in C_DOC::close_files().		ThrowIfNil_(its_nd_probs_stream_p);		its_nd_probs_stream_p->mac_open(its_nd_probs_fs_spec);		its_net_p->write_header_of_nd_probs_file(its_nd_probs_stream_p);	}			if(its_has_bi_nd_probs_file){		its_bi_nd_probs_stream_p = new MY_OFSTREAM();		//delete:	in C_DOC::close_files().		ThrowIfNil_(its_bi_nd_probs_stream_p);		its_bi_nd_probs_stream_p->mac_open(its_bi_nd_probs_fs_spec);	}			if(its_has_stories_file){	 	its_stories_stream_p = new MY_OFSTREAM();		//delete:	in C_DOC::close_files(). 	 	ThrowIfNil_(its_stories_stream_p);		its_stories_stream_p->mac_open(its_stories_fs_spec);	}			return true;	}//******************************************VOID	C_DOC::close_files(){	if(its_has_ecases_file){		its_net_p->kill_dictionaries();		its_evid_stream_p->close();		delete  its_evid_stream_p;		its_evid_stream_p=0;	}									if(its_has_nd_probs_file){		its_nd_probs_stream_p->close();		delete  its_nd_probs_stream_p;		its_nd_probs_stream_p=0;	}	if(its_has_bi_nd_probs_file){		its_bi_nd_probs_stream_p->close();		delete  its_bi_nd_probs_stream_p;		its_bi_nd_probs_stream_p=0;	}	if(its_has_stories_file){		its_stories_stream_p->close();		delete  its_stories_stream_p;		its_stories_stream_p=0;	}	}//******************************************VOID	C_DOC::go_forward(const CHAR * ecase_name_cstr)	//in{	its_net_p->go_forward(ecase_name_cstr, its_nd_probs_stream_p,		its_bi_nd_probs_stream_p, its_stories_stream_p, its_illustrate_stories );	Str255  ecase_name_pstr;	ecase_name_pstr[0] = strlen(ecase_name_cstr);	::BlockMoveData(ecase_name_cstr, ecase_name_pstr + 1, ecase_name_pstr[0]);	its_main_wind_cap_p->SetDescriptor(ecase_name_pstr);					its_ecase++;}//******************************************VOID	C_DOC::meta_go_forward(){	if(!its_mview_p->ProcessCommand(cmd_close_all_non_main_winds)  )return;	//free some memory:		UScrap::ClearData();//empty scrap	its_mview_p->PostAction(0);//delete its current uaction	UCursor::SetTheCursor(watchCursor);	if(its_ecase==0){		if(!open_files()){			UCursor::InitTheCursor();			refresh_req_stack_space_();return;		}		//I tried to make 		//its_net_p->preserve_act_st_sts_of_all_nds()		//part of open_files()		//and 		//its_net_p->restore_act_st_sts_of_all_nds()		//part of close_files() but couldn't.		//Files must be closed during aft_run state so user can open them.		//But can't restore active states during aft_run state,		//because the user may want to 		//look at the results of the last ecase of the ecases file.		if(its_has_ecases_file)its_net_p->preserve_act_st_sets_of_all_nds();				its_mview_p->disable_nd_efields();		its_net_p->set_run_state(dur_run);			}	CHAR  ecase_name_cstr[64]="1"; // ecase = evidence case	//ecase_name_cstr[0]='\0';		if(!its_has_ecases_file){//if there is no ecase file		its_net_p->go_forward(ecase_name_cstr, its_nd_probs_stream_p,			its_bi_nd_probs_stream_p, its_stories_stream_p, its_illustrate_stories );		its_ecase++;		close_files();		its_net_p->set_run_state(aft_run);		UCursor::InitTheCursor();		refresh_req_stack_space_();return;	} 		//The rest of this method assumes that there is an ecase file			STRINGY   	nd_name;	STRINGY   	nd_st_name;	USHORT  	nd_id;	USHORT		nd_st_id; 	CHAR  		ch;	BOOLEAN 	more_nodes;		//Below, we use a  /**/  to indicate a line	//which does not appear in good_ecases_file().	try{/**/	if(its_ecase==0){			ch=my_endline;			while( ch!='#' ){ its_evid_stream_p->my_get(ch); }/**/	}else{/**/		ch='#';/**/	}		while(ch=='#'){//loop over ecases/**/		//default active-state list		/**/		its_net_p->fill_act_st_sets_of_all_nds();			*its_evid_stream_p >> ecase_name_cstr;			its_evid_stream_p->my_get(ch);			while(ch!=my_endline){				its_evid_stream_p->my_get(ch);			}			while(isspace(ch)){its_evid_stream_p->my_get(ch);}			if(ch=='#'){				more_nodes = false;			}else{				more_nodes = true;				its_evid_stream_p->putback(ch);			}								while(more_nodes){ //loop over nodes with non default active-state set				*its_evid_stream_p >> nd_name;				nd_id =its_net_p->get_dict().get_id_of_this_stringy(nd_name);/**/			//default active-state list does not apply to nd_id/**/			its_net_p->get_nd_ptr(nd_id)->empty_act_st_set();				its_evid_stream_p->my_get(ch);				while(ch!=my_endline){ //loop over the active state names of a single node					if(isspace(ch)){						its_evid_stream_p->my_get(ch);					}else{						its_evid_stream_p->putback(ch);						*its_evid_stream_p >> nd_st_name;						nd_st_id = its_net_p->get_nd_ptr(nd_id)->get_dict().get_id_of_this_stringy(nd_st_name);/**/					its_net_p->activate_a_nd_state(nd_id, nd_st_id);						its_evid_stream_p->my_get(ch);					}				}//end of loop over state names				while(isspace(ch)){its_evid_stream_p->my_get(ch);}				if(ch=='#'){					more_nodes = false;				}else{					more_nodes = true;					its_evid_stream_p->putback(ch);				}								}//end of loop over nodes with non default active-state set/**/		go_forward(ecase_name_cstr);/**/		//if its_do_one_ecase_at_a_time, leave after just one cycle of ecase loop:		/**/		if(its_do_one_ecase_at_a_time) ch = 'a';		}//end of loop over ecases		}//end of try		catch(END_OF_FILE){ /**/	//do the last ecase/**/	go_forward(ecase_name_cstr);/**/	//Files must be closed during aft_run state so user can open them./**/	//But can't restore active states during aft_run state,/**/	//because the user may want to /**/ 	//look at the results of the last ecase of the ecases file./**/	close_files();/**/	its_net_p->set_run_state(aft_run);	}				UCursor::InitTheCursor();		refresh_req_stack_space_();	}//******************************************VOID	C_DOC::go_back_to_initial_state(){	its_mview_p->ProcessCommand(cmd_close_all_non_main_winds);		//in case we are going back to the initial run state 	// without first going through all the ecases:	if(its_net_p->get_run_state()==dur_run)close_files();		if(its_has_ecases_file) its_net_p->restore_act_st_sets_of_all_nds();		its_mview_p->enable_nd_efields();	its_net_p->set_run_state(bef_run);	its_ecase=0;	its_main_wind_cap_p->SetDescriptor("\p");}#pragma mark --command center--//******************************************BOOLEAN		C_DOC::ObeyCommand(CommandT	inCommand,		//inVOID  *		ioParam)		//i-o{		//MONITOR_THE_CHANGE_HERE	//doc: see below	//mview: see below	//very important:	//should use SetModified() to change mIsModified	//instead of changing it directly so that at debug time,	//can intercept all changes to mIsModified.	BOOLEAN		obeyed = true;		switch (inCommand) {		case cmd_import_nd_sts:			if(import_nd_sts()){SetModified(true); its_mview_p->set_is_modified(true, mview_del);}			break;		case cmd_import_amps:			if(import_amps()){SetModified(true); its_mview_p->set_is_modified(true, mview_del);}			break;		case cmd_export_topology:			export_topology();			break;		case cmd_export_nd_sts:			export_nd_sts();			break;			case cmd_export_amps:			export_amps();			break;		case cmd_filter_out_small_amps:			if(handle_amps_filter_dialog()){SetModified(true); its_mview_p->set_is_modified(true, mview_del);}			break;		case cmd_preview:			handle_preview_dialog();			break;		case cmd_text_files:			handle_text_files_dialog();			break;		case cmd_do_one_ecase_at_a_time:			toggle(its_do_one_ecase_at_a_time);			break;		case cmd_illustrate_stories:			toggle(its_illustrate_stories);			break;		case cmd_initial_run_state:			go_back_to_initial_state();			break;		case cmd_go_forward:			refresh_req_stack_space_();			meta_go_forward();			#if _do_debug				if(C_KEYS::KeyIsDown(0X3A)){ //option_key=0x3A					STRINGY sgy = req_stack_space;					sgy = (STRINGY)"Min stack space is " && sgy;//					::ErrorSound(0);//no Beep upon next alert	// dpo					 					my_gen_alert(sgy);					//					::InitDialogs(0); // dpo // resets error sound and empties strings ^0, ^1, ^2, ^4				}			#endif //_do_debug			break;		case cmd_show_main_wind:			if(C_KEYS::KeyIsDown(0X3A)){ //option_key=0x3A				its_mview_p->shift_wind_to_top_left_corner_of_desktop();			}			mWindow->Select();			break;		case cmd_doc_SetModified:			SetModified(true);			break;					default:			obeyed = LSingleDoc::ObeyCommand(inCommand, ioParam);			break;	}	return obeyed;}//******************************************VOID	C_DOC::FindCommandStatus(CommandT		inCommand,		//inBOOLEAN		&	outEnabled,		//outBOOLEAN		&	outUsesMark,	//outUInt16		&	outMark,		//outStr255			outName_pstr)	//out{	outEnabled = false;	outUsesMark = false;	outMark = noMark;		USHORT	num_of_nds = its_net_p->get_num_of_nds();	RUN_STATE run_st = its_net_p->get_run_state();			switch (inCommand) {		case cmd_import:		case cmd_import_nd_sts:		case cmd_import_amps:		case cmd_export:		case cmd_export_topology:		case cmd_export_nd_sts:		case cmd_export_amps:			//dictionaries are used during run and when export. 			//To avoid conflicts, only allow export bef_run			if(num_of_nds!=0 && run_st==bef_run)outEnabled=true; 			break;		case cmd_filter_out_small_amps:			if(num_of_nds!=0 && run_st==bef_run)outEnabled=true; 			break;		case cmd_preview:			if(num_of_nds!=0 && run_st==bef_run)outEnabled=true; 			break;		case cmd_text_files:			if(num_of_nds!=0 && run_st==bef_run)outEnabled=true;			outUsesMark=true;			if(	its_has_ecases_file ||				its_has_nd_probs_file ||				its_has_bi_nd_probs_file ||					its_has_stories_file ){				outMark=checkMark;			}else{				outMark=noMark;			} 			break;		case cmd_do_one_ecase_at_a_time:			if(num_of_nds!=0 && run_st==bef_run && its_has_ecases_file)outEnabled=true; 			outUsesMark=true;			its_do_one_ecase_at_a_time?outMark=checkMark:outMark=noMark;						break;		case cmd_illustrate_stories:			if(num_of_nds!=0 && run_st==bef_run)outEnabled=true; 			outUsesMark=true;			its_illustrate_stories?outMark=checkMark:outMark=noMark;						break;		case cmd_initial_run_state:			if(num_of_nds!=0 && run_st!=bef_run)outEnabled = true;			break;		case cmd_go_forward:			if(num_of_nds!=0 && run_st!=aft_run)outEnabled = true;			break;		case cmd_show_main_wind:			outEnabled = true;			break;		default:			LSingleDoc::FindCommandStatus(inCommand, outEnabled,												outUsesMark, outMark, outName_pstr);			break;	}}		