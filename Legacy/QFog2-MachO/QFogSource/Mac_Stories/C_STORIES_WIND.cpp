#include "C_STORIES_WIND.h"#include "C_MAIN_VIEW.h"#include "EXCEPTIONS.h"#pragma mark --creation/destruction--//******************************************C_STORIES_WIND::C_STORIES_WIND(LStream  *		inStream)	//in	:LWindow(inStream){}//******************************************C_STORIES_WIND::C_STORIES_WIND(){}//******************************************C_STORIES_WIND::~C_STORIES_WIND(){	set_item_if_diff(1);						its_mview_p->finish_stories_wind_closing();}//******************************************VOID	C_STORIES_WIND::show_owner(const LStr255  &  file_name)	//in{	LStr255  cap = "\pProject: ";	cap += (LStr255)file_name;	its_owner_cap_p->SetDescriptor(cap);}//******************************************VOID	C_STORIES_WIND::fill_popup(COORD_SYSTEM  coord_sys)		//in{	its_popup_p->Hide();		MenuHandle		menu_h = its_popup_p->GetMacMenuH();	//destroy_h: by PP	ThrowIfNil_(menu_h);			// first clear popup		SInt16  num_of_items = ::CountMenuItems(menu_h);	for(SInt16 menu_item =1; menu_item<= num_of_items; menu_item++){		::DeleteMenuItem(menu_h, 1);	} 	 	USHORT item_num=1;	USHORT story_ctr=1;	USHORT   ending, cur_ending=max_ushort;	LStr255  ending_str;		C_ANTHOLOGY_ITEM   * ant_it_p;	DIR_DATA<C_ANTHOLOGY_ITEM>  *  dir_ant_it_p = its_net_p->get_anthology_first_p();	while(dir_ant_it_p){		ant_it_p = &(dir_ant_it_p->its_data);				ending = ant_it_p->get_ending();		if(ending!=cur_ending){			::NumToString(ending, ending_str);			ending_str = "\pending=" + ending_str + "\p  next";			::AppendMenu(menu_h, ending_str);			cur_ending = ending;			item_num++;		}							      	// Add the item      	// Insert a dummy item, then rename it so special chars are not a problem		::AppendMenu(menu_h, "\pdummy");			::SetMenuItemText( menu_h, item_num , ant_it_p->get_descriptor(story_ctr, coord_sys) );		story_ctr++;		item_num++;		dir_ant_it_p = dir_ant_it_p->its_next_p;	}	item_num--;	its_num_of_items = item_num;		its_popup_p->Show();}//******************************************VOID	C_STORIES_WIND::init_popup(){	fill_popup(rect_cs);	its_popup_p->SetMinValue(1);   	its_popup_p->SetMaxValue(its_num_of_items);   	its_popup_p->StopBroadcasting();			its_popup_p->SetValue(1);	its_popup_p->StartBroadcasting();}//******************************************VOID	C_STORIES_WIND::special_finish_create(const LStr255  & file_name)		//in{ 	its_owner_cap_p =(LCaption  *)FindPaneByID(sto_wind_owner_cap_rid);	its_coord_sys_cap_p =(LCaption  *)FindPaneByID(sto_wind_cs_cap_rid);	its_popup_p = (LPopupButton  *)FindPaneByID(sto_wind_popup_rid); //	its_polar_radio_p = (LStdRadioButton  *)FindPaneByID(sto_wind_polar_radio_rid); 	//	its_first_but_p =(LStdButton  *)FindPaneByID(sto_wind_first_but_rid);//	its_next_but_p =(LStdButton  *)FindPaneByID(sto_wind_next_but_rid);	 	// Activate RidL resource.   	UReanimator::LinkListenerToControls(this, this, sto_wind_ridl);	//its SuperCommander defined in C_MAIN_VIEW::create_stories_wind() 	((C_MAIN_VIEW  *)GetSuperCommander())->get_top_ptrs(its_doc_p, its_mview_p, its_net_p); 	show_owner(file_name); 	  	init_popup();  	  	its_coord_sys = rect_cs;  	its_item_num = 1;  		Show();//necessary! 	  	}#pragma mark --focus story--//******************************************const VECTOR<USHORT>   *  C_STORIES_WIND::get_net_story_ptr(USHORT the_item_num)	//in{	// Returns a null pointer if item number 	// corresponds to an "ending=x next" statement	// or if the item number is too large	USHORT item_num=1;	USHORT   ending, cur_ending=max_ushort;	C_ANTHOLOGY_ITEM	 *  ant_it_p;	DIR_DATA<C_ANTHOLOGY_ITEM>  *  dir_ant_it_p = its_net_p->get_anthology_first_p();	while(dir_ant_it_p){		ant_it_p = &(dir_ant_it_p->its_data);				ending = ant_it_p->get_ending();		if(ending!=cur_ending){			if(item_num == the_item_num)return 0;			cur_ending = ending;			item_num++;		}		if(item_num == the_item_num){			return ant_it_p->get_net_story_ptr();		}							item_num++;		dir_ant_it_p = dir_ant_it_p->its_next_p;	}	return 0; // the item number is too high	}//******************************************VOID	C_STORIES_WIND::set_item_always(USHORT item_num)		//in{	its_item_num = item_num;		its_popup_p->StopBroadcasting();	its_popup_p->SetValue(item_num);	its_popup_p->StartBroadcasting();		its_mview_p->show_story_caps(get_net_story_ptr(item_num));}#pragma mark --button:	coord sys--//******************************************VOID	C_STORIES_WIND::toggle_coord_sys(){	if(its_coord_sys==rect_cs){		its_coord_sys = polar_cs;		fill_popup(polar_cs);		its_coord_sys_cap_p->SetDescriptor("\p(radius, angle in degrees)");	}else{		its_coord_sys = rect_cs;		fill_popup(rect_cs);		its_coord_sys_cap_p->SetDescriptor("\p(real part, imaginary part)");	}}#pragma mark --buttons:	response center--//******************************************VOID	C_STORIES_WIND::ListenToMessage(MessageT  	inMessage,		//inVOID  * 	ioParam )		//i-o{	//MONITOR_THE_CHANGE_HERE		USHORT		new_item_num;		switch ( inMessage ) {		case msg_sto_wind_popup:			// for nd_popup: inMessage = pane id, *ioParam = current item 			new_item_num = *((SInt32  *)ioParam);						set_item_if_diff(new_item_num); 			break;		// Due to the fact that the polar and rect buttons form a radio group,		//this message is received when either button is changed.		case msg_sto_wind_polar_radio: 			toggle_coord_sys();			break;					case msg_sto_wind_first_but:			set_item_if_diff(1);			break;		case msg_sto_wind_next_but:			if(its_item_num<its_num_of_items){				set_item_if_diff(its_item_num + 1);			}else{				::SysBeep(0);			}			break;	}}