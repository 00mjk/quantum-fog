#include "C_MAIN_VIEW.h"#include "C_APP.h"#include "C_KEYS.h"#include "C_DOC.h"#include "C_WIND_BDS_RECO.h"#include "C_MVIEW_ACTIONS.h"#include "C_EFIELD_PASTE_ATMENT.h"#include "StCPTstate.h"#include "SET.h"#include "EXCEPTIONS.h"#pragma mark --creation/destruction--//******************************************C_MAIN_VIEW::C_MAIN_VIEW(LStream  *	inStream)	//in	:LView(inStream),	C_ACTION_FLAGS(mview_num_of_act_types),	its_doc_p(0),	its_net_p(0),	its_num_of_sel_nds(0),	its_num_of_sel_arrows(0),	its_image_horiz_inches(10),	its_image_vert_inches(8),	its_has_grid_lines(true),	its_pane_counter(0),	its_pi_wind_p(0),	its_bi_nd_wind_p(0),	its_nd_probs_wind_p(0),	its_bi_nd_probs_wind_p(0),	its_stories_wind_p(0){	its_pasting_center.h=0;	its_pasting_center.v=0;}//******************************************C_MAIN_VIEW::~C_MAIN_VIEW(){	//the following avoids a bug in PP CW11	//whereby the windows are destroyed in such an order that	//we can end up with all windows closed 	//(but the app and doc still alive) and a	//corrupted value for sTarget.	//It occurred in particular if I	//(1) opened stories and nd_probs window,	//(2)clicked on the close box of the main window,	//(Now the app and doc are still alive but sTarget is corrupted.)	//(3)pressed on Quit or New, both of which use sTarget.	ProcessCommand(cmd_close_all_non_main_winds);}//******************************************VOID	C_MAIN_VIEW::FinishCreateSelf(){	//command chain:	//main view <- main window <- doc <- app 	//main view SuperCommander is defined as main window automatically when main window is created	//main window SuperCommander is defined in C_DOC::C_DOC()	its_main_wind_p = (LWindow  *)GetSuperCommander();	its_doc_p= (C_DOC  *)(this->GetSuperCommander()->GetSuperCommander());		ResizeImageTo(pix_per_in*its_image_horiz_inches, 		pix_per_in*its_image_vert_inches, false);	set_min_max_and_std_of_wind(true);		 	// %%%%%%%	font stuff from CSampleText (PP cookbook example):	TextTraitsH	 text_traits_h = UTextTraits::LoadTextTraits(node_txt_rid);//not destroyed by PP	//create_h:		PP creates text_traits_h with a call to ::GetResource().	//throwif_h:	PP calls SignalIfNil immediately after creation.	//destroy_h:	PP does NOT release text_traits_h resource.	//				I delete it below, in this method.	ThrowIfNil_(text_traits_h);			its_fsize = (**text_traits_h).size;	its_fnum = (**text_traits_h).fontNumber;	ReleaseResource_((Handle)text_traits_h);	check_fsize_and_fnum();	its_fname_item_num = UFontMenu::GetFontItemNumber(its_fnum);			LUndoer  * undoer_p = new LUndoer;	//delete:	PP deletes undoer_p via 	//			~C_MAIN_VIEW()->LView()->~LPane()	//			->~LAttachable()->LAttachable::RemoveAllAttachments().	ThrowIfNil_(undoer_p);	AddAttachment(undoer_p); 	}#pragma mark --doc pointers--//******************************************VOID	C_MAIN_VIEW::get_top_ptrs(C_DOC  *  & 		doc_p,			//outC_MAIN_VIEW  *  & 	mview_p,		//outQB_NET  *   &		net_p)			//out{	doc_p = its_doc_p;	mview_p = this;	net_p = its_net_p;}#pragma mark --bounds records--//******************************************VOID   C_MAIN_VIEW::set_pal_bds_reco(){	//if pal is closed but it was open before, don't do anything to pal_bds_reco	((C_APP  *)GetTopCommander())->get_pal_bds(its_pal_bds_reco);	}//******************************************VOID   C_MAIN_VIEW::read_bounds_res_of_satellite_winds(){	//don't do anything if file hasn't been created yet	if(its_doc_p->GetFile()==0)return;	its_pal_bds_reco.read_res(its_doc_p, pal_rid);			its_pi_wind_bds_reco.read_res(its_doc_p, pi_wind_rid);		its_bi_nd_wind_bds_reco.read_res(its_doc_p, bi_nd_wind_rid);		its_nd_probs_wind_bds_reco.read_res(its_doc_p, nd_probs_wind_rid);		its_bi_nd_probs_wind_bds_reco.read_res(its_doc_p, bi_nd_probs_wind_rid);		its_stories_wind_bds_reco.read_res(its_doc_p, sto_wind_rid);}	//******************************************VOID   C_MAIN_VIEW::write_bounds_res_of_satellite_winds(){	//don't do anything if file hasn't been created yet	if(its_doc_p->GetFile()==0)return;		//make sure that bounds records reflect current bounds	//set_reco does nothing is zero window pointer	set_pal_bds_reco();	its_pi_wind_bds_reco.set_reco(its_pi_wind_p);	its_bi_nd_wind_bds_reco.set_reco(its_bi_nd_wind_p);	its_nd_probs_wind_bds_reco.set_reco(its_nd_probs_wind_p);	its_bi_nd_probs_wind_bds_reco.set_reco(its_bi_nd_probs_wind_p);	its_stories_wind_bds_reco.set_reco(its_stories_wind_p);	its_pal_bds_reco.write_res(its_doc_p, pal_rid);				its_pi_wind_bds_reco.write_res(its_doc_p, pi_wind_rid);		its_bi_nd_wind_bds_reco.write_res(its_doc_p, bi_nd_wind_rid);		its_nd_probs_wind_bds_reco.write_res(its_doc_p, nd_probs_wind_rid);		its_bi_nd_probs_wind_bds_reco.write_res(its_doc_p, bi_nd_probs_wind_rid);		its_stories_wind_bds_reco.write_res(its_doc_p, sto_wind_rid);}	#pragma mark --create/update/destroy satellite windows--//******************************************BOOLEAN		C_MAIN_VIEW::save_pi(){	BOOLEAN		obeyed;	if(its_pi_wind_p!=0){		obeyed = its_pi_wind_p->save_pi();	}else{		obeyed = true;	}	return obeyed;}//******************************************VOID	C_MAIN_VIEW::create_pi_wind(USHORT  sel_nd) 	//in//sel_nd = selected node{	LStr255  file_name;	its_main_wind_p->GetDescriptor(file_name);	USHORT	screen_size = 0;	//12 in monitor: 384 X 512	//14 in monitor: 480 X 640	//menu bar ~ 40 	//small pi wind height= 338+40	//large pi wind height= 430+40	BitMap screenBits;	GetQDGlobalsScreenBits(&screenBits);	if(screenBits.bounds.bottom > 475) screen_size = 1;	its_pi_wind_p = (C_PI_WIND  *)LWindow::CreateWindow(pi_wind_rid + screen_size, this);//SuperCommander declared	its_pi_wind_bds_reco.change_wind(its_pi_wind_p);	its_pi_wind_p->special_finish_create(file_name, sel_nd);				//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating.		LCommander::SetUpdateCommandStatus( true );		}//******************************************VOID	C_MAIN_VIEW::finish_pi_wind_closing(){	 	its_pi_wind_bds_reco.set_reco(its_pi_wind_p);	its_pi_wind_p = 0;	//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating.		LCommander::SetUpdateCommandStatus( true );	}//******************************************VOID	C_MAIN_VIEW::create_bi_nd_wind(){	LStr255  file_name;	its_main_wind_p->GetDescriptor(file_name);	its_bi_nd_wind_p = (C_BI_ND_WIND  *)LWindow::CreateWindow(bi_nd_wind_rid, this);//SuperCommander declared		its_bi_nd_wind_bds_reco.change_wind(its_bi_nd_wind_p);	its_bi_nd_wind_p->special_finish_create(file_name);					//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating.		LCommander::SetUpdateCommandStatus( true );		}//******************************************VOID	C_MAIN_VIEW::finish_bi_nd_wind_closing(){ 		its_bi_nd_wind_bds_reco.set_reco(its_bi_nd_wind_p);	its_bi_nd_wind_p = 0;	//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating.		LCommander::SetUpdateCommandStatus( true );	}//******************************************VOID	C_MAIN_VIEW::create_nd_probs_wind(USHORT  sel_nd) 	//in//sel_nd = selected node{	LStr255  file_name;	its_main_wind_p->GetDescriptor(file_name);	its_nd_probs_wind_p = (C_ND_PROBS_WIND  *)LWindow::CreateWindow(nd_probs_wind_rid, this);//SuperCommander declared	its_nd_probs_wind_bds_reco.change_wind(its_nd_probs_wind_p);	its_nd_probs_wind_p->special_finish_create( file_name, sel_nd); 		//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating.		LCommander::SetUpdateCommandStatus( true );		}//******************************************VOID	C_MAIN_VIEW::finish_nd_probs_wind_closing(){	its_nd_probs_wind_bds_reco.set_reco(its_nd_probs_wind_p);	its_nd_probs_wind_p = 0;	//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating.		LCommander::SetUpdateCommandStatus( true );	}//******************************************VOID	C_MAIN_VIEW::create_bi_nd_probs_wind(USHORT  sel_loc) 	//in//sel_loc = selected location in bi_nds list. Zero based{	LStr255  file_name;	its_main_wind_p->GetDescriptor(file_name);		its_bi_nd_probs_wind_p = (C_BI_ND_PROBS_WIND  *)LWindow::CreateWindow(bi_nd_probs_wind_rid, this);//SuperCommander declared		its_bi_nd_probs_wind_bds_reco.change_wind(its_bi_nd_probs_wind_p);	its_bi_nd_probs_wind_p->special_finish_create( file_name, sel_loc); 		//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating.		LCommander::SetUpdateCommandStatus( true );		}//******************************************VOID	C_MAIN_VIEW::finish_bi_nd_probs_wind_closing(){ 	its_bi_nd_probs_wind_bds_reco.set_reco(its_bi_nd_probs_wind_p);	its_bi_nd_probs_wind_p = 0;	//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating.		LCommander::SetUpdateCommandStatus( true );	}//******************************************VOID	C_MAIN_VIEW::create_stories_wind(){	LStr255  file_name;	its_main_wind_p->GetDescriptor(file_name);	its_stories_wind_p = (C_STORIES_WIND  *)LWindow::CreateWindow(sto_wind_rid, this);//SuperCommander declared		its_stories_wind_bds_reco.change_wind(its_stories_wind_p);	its_stories_wind_p->special_finish_create(file_name);					//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating.		LCommander::SetUpdateCommandStatus( true );		}//******************************************VOID	C_MAIN_VIEW::finish_stories_wind_closing(){ 	its_stories_wind_bds_reco.set_reco(its_stories_wind_p);	its_stories_wind_p = 0;	//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating.		LCommander::SetUpdateCommandStatus( true );	}#pragma mark --font--//******************************************VOID	C_MAIN_VIEW::check_fsize_and_fnum(){	//from CSampleText (PP cookbook example):	//See also CTextOptionsDialog and CDynamicCaption			if (its_fsize == 0) its_fsize = ::GetDefFontSize();			//systemFont=0 (by definition),	//applFont=1 (by definition),	//System may have been altered so that	//0 and 1 are no longer font numbers.	//Font number zero can mean 	//system font or missing font!!		if (its_fnum == systemFont){		its_fnum = ::GetSysFont();	}else if (its_fnum == applFont){		its_fnum = ::GetAppFont();	}	if(!::RealFont(its_fnum, its_fsize)){		its_fnum = ::GetSysFont();		its_fsize = ::GetDefFontSize();		}}		#pragma mark --size of image and window--//******************************************VOID   C_MAIN_VIEW::shift_wind_to_top_left_corner_of_desktop(){			Rect   bds;	its_main_wind_p->CalcPortFrameRect(bds);	bds.left += 4;	bds.right += 4;	bds.top += 40;	bds.bottom += 40;	BitMap	screenBits;	GetQDGlobalsScreenBits(&screenBits);	if (bds.right > screenBits.bounds.right-4) bds.right = screenBits.bounds.right-4;	if (bds.bottom > screenBits.bounds.bottom-4) bds.bottom = screenBits.bounds.bottom-4;		its_main_wind_p->DoSetBounds(bds);		}		//******************************************VOID   C_MAIN_VIEW::set_min_max_and_std_of_wind(BOOLEAN		set_bds_to_std)		//in{	//For a window, image and pane size are set equal by DoSetBounds().	//Image size of window is NOT the same as image size of main view!	//In this class, when we refer to the image, without any qualifications,	//we mean the main view image.	SDimension16 	size_mwind, size_mview;		its_main_wind_p->GetFrameSize(size_mwind);	GetFrameSize(size_mview);		SDimension16  std_size;		std_size.width = pix_per_in*its_image_horiz_inches 		+(size_mwind.width - size_mview.width);	std_size.height = pix_per_in*its_image_vert_inches		+(size_mwind.height - size_mview.height);	its_main_wind_p->SetStandardSize(std_size);//Doesn't draw. An inline that just changes data member	Rect	std_bds;	its_main_wind_p->CalcStandardBounds(std_bds);	std_size.width = std_bds.right -std_bds.left;	std_size.height = std_bds.bottom -std_bds.top;	its_main_wind_p->SetStandardSize(std_size);		Rect	min_max_rect;	min_max_rect.left = 265;//horiz_min	min_max_rect.top = 200;//vert_min	min_max_rect.right = std_size.width;		min_max_rect.bottom = std_size.height;	its_main_wind_p->SetMinMaxSize(min_max_rect);//Doesn't draw. An inline that just changes data member	if(set_bds_to_std){		its_main_wind_p->DoSetBounds(std_bds);	}}//******************************************BOOLEAN  C_MAIN_VIEW::handle_drawing_size_dialog(){	// this is a trivial generalization of UModalDialogs::AskForOneNumber	//if this function returns true, SetModified(true) called in ObeyCommand()	StDialogHandler		d_handler(ds_window_rid, this);//SuperCommander declared	LWindow  *		dialog_p = d_handler.GetDialog();		LEditField  * 	horiz_efield_p = 		(LEditField  *)dialog_p->FindPaneByID(ds_horiz_efield_rid);	LEditField  * 	vert_efield_p = 		(LEditField  *)dialog_p->FindPaneByID(ds_vert_efield_rid);						horiz_efield_p->SetValue(its_image_horiz_inches);	vert_efield_p->SetValue(its_image_vert_inches);				horiz_efield_p->SelectAll();	dialog_p->SetLatentSub(horiz_efield_p);	dialog_p->Show();		USHORT		count;	Str255		pstr;	while (true) {		MessageT	hit_message = d_handler.DoDialog();		switch(hit_message){			case msg_Cancel:				return false;				break;			case msg_OK:									horiz_efield_p->GetDescriptor(pstr);					if((!STRINGY(pstr).is_ushort(count))|| count==0){					my_gen_alert("Your entry must be a positive integer.");					break;				}				its_image_horiz_inches  = count;								vert_efield_p->GetDescriptor(pstr);					if((!STRINGY(pstr).is_ushort(count))|| count==0){					my_gen_alert("Your entry must be a positive integer.");					break;				}								its_image_vert_inches = count;								ResizeImageTo(pix_per_in*its_image_horiz_inches, 					pix_per_in*its_image_vert_inches, false);				set_min_max_and_std_of_wind(true);								return true;				break;		}	}	}#pragma mark --drawing--//******************************************VOID   C_MAIN_VIEW::DrawSelf(){//drawer	if(its_has_grid_lines){		SDimension32  image_size;		GetImageSize(image_size);				StCPTstate		saved_st(true, true, false);		saved_st.Normalize();//		Pattern gray;	//		::PenPat(::GetQDGlobalsGray(&gray));//		::PenMode(patXor);		RGBColor  my_graph_paper_blue = {39321, 65535, 65535};//cyan like		::RGBForeColor(&my_graph_paper_blue);				SInt16 i;			for(i=1;i<its_image_horiz_inches;i++){			::MoveTo(i*pix_per_in, 0);			::LineTo(i*pix_per_in, image_size.height);		}		for(i=1;i<its_image_vert_inches;i++){			::MoveTo(0, 				i*pix_per_in);			::LineTo(image_size.width, 	i*pix_per_in);		}		/* 		//for testing purposes:		SInt16 x, y;		for(x=0;x<its_image_horiz_inches;x++){			for(y=0;y<its_image_vert_inches;y++){				::MoveTo(x*its_horiz_page_size, y*its_vert_page_size);				::LineTo((x+1)*its_horiz_page_size, (y+1)*its_vert_page_size);				::MoveTo((x+1)*its_horiz_page_size, y*its_vert_page_size);				::LineTo(x*its_horiz_page_size, (y+1)*its_vert_page_size);			}		}		*/					}		C_ARROW  * ar_p;		DIR_DATA<C_ARROW>  *  dir_arrow_p = its_net_p->get_arrows_first_p();	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		ar_p->draw();		if(ar_p->is_selected())ar_p->draw_sel_handles();		dir_arrow_p = dir_arrow_p->its_next_p;	}		NODE  *  nd_p;	for(USHORT nd=0; nd < its_net_p->get_num_of_nds(); nd++){		nd_p = its_net_p->get_nd_ptr(nd);		nd_p->draw();// this draws circle, efield and state_cap but not sel_handles		if(nd_p->is_selected())nd_p->draw_sel_handles();	}	}#pragma mark --node efield/story cap--//******************************************VOID	C_MAIN_VIEW::disable_nd_efields(){		for(USHORT	i = 0; i<its_net_p->get_num_of_nds(); i++){		its_net_p->get_nd_ptr(i)->get_efield_ptr()->Disable();	}}//******************************************VOID	C_MAIN_VIEW::enable_nd_efields(){		for(USHORT	i = 0; i<its_net_p->get_num_of_nds(); i++){		its_net_p->get_nd_ptr(i)->get_efield_ptr()->Enable();	}}//******************************************VOID	C_MAIN_VIEW::create_nd_efield(const Point  &  m_down_pt,		//inUSHORT nd_id)					//in{	its_pane_counter++;	Str255  name_pstr= "\pnode_";	Str255  pane_counter_pstr;	::NumToString(its_pane_counter, pane_counter_pstr);	LString::AppendPStr(name_pstr, pane_counter_pstr);		STRINGY  namey(name_pstr);	its_net_p->get_nd_ptr(nd_id)->set_name(namey);	NODE  *  nd_p = its_net_p->get_nd_ptr(nd_id);	SInt16  sel_rad = nd_p->get_selection_cir().its_radius;	SPaneInfo  pane_info;		//its_pane_counter starts at 0		pane_info.paneID = its_pane_counter + first_nd_efield_rid ;		pane_info.width = 100;		pane_info.height = 30;		pane_info.enabled = true;				pane_info.bindings.left = false;		pane_info.bindings.top = false;		pane_info.bindings.right = false;		pane_info.bindings.bottom = false;		pane_info.left = m_down_pt.h -50;		pane_info.top = m_down_pt.v + sel_rad + 3;		pane_info.superView = this;	C_ND_EFIELD  *	efield_p = new C_ND_EFIELD(		pane_info,//pane_info		name_pstr,//initial caption		node_txt_rid,// 'Txtr' resource id		16,// maximum number of characters		true,// has box		false,// has word wrap		C_KEYS::my_PrintingCharField,// key filter function		this);// super commander	//delete:	I destroy efield_p via 	//			QB_NET::del_nd()->C_MAIN_VIEW::destroy_nd_efield()	ThrowIfNil_(efield_p);		efield_p->FinishCreate();	efield_p->set_nd_always(nd_id);	efield_p->AddListener(this);	efield_p->AddAttachment(new C_ND_NAME_PASTE_ATMENT());//= new	//delete:		SwitchTarget((LCommander  *) efield_p);	efield_p->Show();			nd_p->set_efield_ptr(efield_p);	}//******************************************VOID	C_MAIN_VIEW::destroy_nd_efield(USHORT nd_id)		//in{	NODE  *  nd_p = its_net_p->get_nd_ptr(nd_id);	C_ND_EFIELD  *  efield_p = nd_p->get_efield_ptr();	delete efield_p;	efield_p = 0;	}//******************************************VOID	C_MAIN_VIEW::ListenToMessage(MessageT  	inMessage,		//inVOID  * 	ioParam )		//i-o{	//MONITOR_THE_CHANGE_HERE	//Calling its_doc_p->SetModified(true) here is a bad thing	//because of periodical nd_efields.	//Luckily, it's unnecessary since C_MAIN_VIEW::Click()	//and C_PI_WIND::Click() make the call. // the main view will be responsible for ALL steps necessary to respond// to  msg_mv_nd_efield  and  msg_pi_nd_efield	LStr255  descriptor;	C_ND_EFIELD  * 	mv_nd_efield_p;	C_PI_ND_EFIELD  * 	pi_nd_efield_p;	USHORT  nd_id;		switch ( inMessage ) {			case msg_mv_nd_efield:			mv_nd_efield_p = (C_ND_EFIELD  *)ioParam;			mv_nd_efield_p->GetDescriptor(descriptor);			if(descriptor[0]==0)descriptor="\p?";			nd_id = mv_nd_efield_p->get_nd();						its_net_p->get_nd_ptr(nd_id)->set_name(STRINGY(descriptor));						if(its_pi_wind_p!=0 ){ 				its_pi_wind_p->rename_a_nd(nd_id, descriptor);//call this only AFTER tell its_net of node name change!			}						if(its_bi_nd_wind_p!=0 ){ 				its_bi_nd_wind_p->rename_a_nd(nd_id, descriptor);			}						break;		case msg_pi_nd_efield:			pi_nd_efield_p = (C_PI_ND_EFIELD  *)ioParam;			pi_nd_efield_p->GetDescriptor(descriptor);			if(descriptor[0]==0)descriptor="\p?";			nd_id = pi_nd_efield_p->get_nd();			its_net_p->get_nd_ptr(nd_id)->set_name(STRINGY(descriptor));									mv_nd_efield_p = its_net_p->get_nd_ptr(nd_id)->get_efield_ptr();			mv_nd_efield_p->SetDescriptor(descriptor);			mv_nd_efield_p->UserChangedText();						if(its_bi_nd_wind_p!=0 ){ 				its_bi_nd_wind_p->rename_a_nd(nd_id, descriptor);			}									break;	}}//******************************************VOID   C_MAIN_VIEW::show_story_caps(const VECTOR<USHORT>   *  net_story_p)	//in{	if(net_story_p==0){			for(USHORT nd=0; nd< its_net_p->get_num_of_nds(); nd++){//			its_net_p->get_nd_ptr(nd)->undraw_state_cap();			its_net_p->get_nd_ptr(nd)->set_state_num_for_cap(max_ushort);		}	}else{		for(USHORT nd=0; nd< its_net_p->get_num_of_nds(); nd++){			its_net_p->get_nd_ptr(nd)->set_state_num_for_cap((*net_story_p)[nd]);//			its_net_p->get_nd_ptr(nd)->draw_state_cap();		}	}	Refresh();		}#pragma mark --get_touched--//******************************************C_PORT_NAME		C_MAIN_VIEW::get_touched_avail_s_port(const Point  &  pt)		//in{	C_PORT_NAME 	port_name(max_ushort, max_ushort);	USHORT  sub_nd_id;	for(USHORT nd_id=0; nd_id < its_net_p->get_num_of_nds(); nd_id++){		if(its_net_p->get_nd_ptr(nd_id)->pt_is_in_greeting_cir_of_avail_s_port(pt, sub_nd_id)){			port_name.its_nd_id = nd_id;			port_name.its_sub_nd_id = sub_nd_id;			return port_name;		}	}	return port_name;}//******************************************C_PORT_NAME		C_MAIN_VIEW::get_touched_avail_d_port(const Point  &  pt)		//in{	C_PORT_NAME 	port_name(max_ushort, max_ushort);	USHORT  sub_nd_id;	for(USHORT nd_id=0; nd_id < its_net_p->get_num_of_nds(); nd_id++){		if(its_net_p->get_nd_ptr(nd_id)->pt_is_in_greeting_cir_of_avail_d_port(pt, sub_nd_id)){			port_name.its_nd_id = nd_id;			port_name.its_sub_nd_id = sub_nd_id;			return port_name;		}	}	return port_name;}//******************************************USHORT		C_MAIN_VIEW::get_touched_nd(const Point  &  pt)		//in{ // more specifically, get FIRST node touched.	for(USHORT nd=0; nd < its_net_p->get_num_of_nds(); nd++){		if( its_net_p->get_nd_ptr(nd)->pt_is_in_sel_cir(pt) )return nd;	}	return max_ushort;}//******************************************C_ARROW  *		C_MAIN_VIEW::get_touched_ar(const Point  &  pt)		//in{// more specifically, get FIRST arrow touched.	C_ARROW  *  ar_p;		DIR_DATA<C_ARROW>  *  dir_arrow_p = its_net_p->get_arrows_first_p();	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		if( ar_p->pt_is_in_sel_dom(pt) ){				return ar_p;		}		dir_arrow_p = dir_arrow_p->its_next_p;	}	return  0;}#pragma mark --selection--//******************************************VOID   C_MAIN_VIEW::select_all(){		for(USHORT nd=0; nd< its_net_p->get_num_of_nds(); nd++){		its_net_p->get_nd_ptr(nd)->select(this);	}		DIR_DATA<C_ARROW>  *  dir_arrow_p = its_net_p->get_arrows_first_p();	while(dir_arrow_p){		dir_arrow_p->its_data.select(this);		dir_arrow_p = dir_arrow_p->its_next_p;	}}//******************************************Boolean   C_MAIN_VIEW::unselect_all(){	Boolean		changed = false;	for(USHORT nd=0; nd< its_net_p->get_num_of_nds(); nd++){		if(its_net_p->get_nd_ptr(nd)->unselect(this)) changed = true;	}		DIR_DATA<C_ARROW>  *  dir_arrow_p = its_net_p->get_arrows_first_p();	while(dir_arrow_p){		if(dir_arrow_p->its_data.unselect(this)) changed = true;		dir_arrow_p = dir_arrow_p->its_next_p;	}	return changed;}//******************************************VOID   C_MAIN_VIEW::select_nd_and_its_entourage(USHORT nd_id)		//in//used in select_rect_contents{	its_net_p->get_nd_ptr(nd_id)->select(this);	C_ARROW  *  ar_p;		DIR_DATA<C_ARROW>  *  dir_arrow_p = its_net_p->get_arrows_first_p();	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		if( (ar_p->get_s_port_name().its_nd_id==nd_id)||			(ar_p->get_d_port_name().its_nd_id==nd_id)){				ar_p->select(this);		}		dir_arrow_p = dir_arrow_p->its_next_p;	}}//******************************************VOID   C_MAIN_VIEW::select_rect_contents(const Rect  & rect)		//in{	C_CIRCLE	cir;	for(USHORT nd_id=0; nd_id< its_net_p->get_num_of_nds(); nd_id++){		cir = its_net_p->get_nd_ptr(nd_id)->get_selection_cir();		if(cir.intersects_rect(rect)) select_nd_and_its_entourage(nd_id); 	}}//******************************************VOID   C_MAIN_VIEW::move_selection_by(const Point  &   delta)		//in{	NODE  *  nd_p;	for(USHORT nd=0; nd< its_net_p->get_num_of_nds(); nd++){		nd_p  =its_net_p->get_nd_ptr(nd);		if(nd_p->is_selected()){			nd_p->move_by(delta);		}	}		C_ARROW  * ar_p;	NODE  * s_nd_p;	NODE  * d_nd_p;		C_CIRCLE  s_cir, d_cir;	Point 	init_pt, fin_pt;	DIR_DATA<C_ARROW>  *  dir_arrow_p = its_net_p->get_arrows_first_p();	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		s_nd_p = its_net_p->get_nd_ptr(ar_p->get_s_port_name().its_nd_id);		d_nd_p = its_net_p->get_nd_ptr(ar_p->get_d_port_name().its_nd_id);		if( s_nd_p->is_selected() || d_nd_p->is_selected() ){			if( s_nd_p->is_selected() && d_nd_p->is_selected() ){				ar_p->move_by(delta);			}else{				s_cir = s_nd_p->get_docking_cir(ar_p->get_s_port_name().its_sub_nd_id);				d_cir = d_nd_p->get_docking_cir(ar_p->get_d_port_name().its_sub_nd_id);				if(its_net_p->calc_closest_pts(s_cir, d_cir, init_pt, fin_pt)){					ar_p->undraw();					if(ar_p->is_selected())ar_p->undraw_sel_handles();					ar_p->set_init_pt(init_pt);					ar_p->set_fin_pt(fin_pt);					ar_p->draw(); 					if(ar_p->is_selected())ar_p->draw_sel_handles();				}			}		}		dir_arrow_p = dir_arrow_p->its_next_p;	}		 //this prevents the state captions from erasing stuff they move over	 //It does NOT erase the main view before drawing on it	Draw(0);}//******************************************VOID   C_MAIN_VIEW::respond_to_selection_tool(const Point  &  m_down_pt,		//inBoolean 	pal_open)			//in{//drawer	FocusDraw();	C_ARROW  *  ar_p = get_touched_ar(m_down_pt);	USHORT 	nd_id = get_touched_nd(m_down_pt);	NODE  * 	nd_p=0;	if(nd_id!=max_ushort)nd_p = its_net_p->get_nd_ptr(nd_id);		if(pal_open){		if(C_KEYS::KeyIsDown(0x3A)||C_KEYS::KeyIsDown(0x38)){//shift or option key is down			if(nd_id != max_ushort || ar_p != 0){//node or arrow was touched				select_all();			}else{//nothing touched				if(unselect_all()) Refresh(); //undrawing handles may leave gaps in arrowheads so refresh.			}			return;		}else{//neither shift or option key is down			if(nd_id != max_ushort){ //node was touched				nd_p->toggle_select(this);				if(!nd_p->is_selected())Refresh();			}else if(ar_p!=0){ //arrow was touched				ar_p->toggle_select(this);				if(!ar_p->is_selected())Refresh();			}		}	}else{//pal closed		if(C_KEYS::KeyIsDown(0x38)){//shift key is down			if(nd_id != max_ushort){ //node was touched				nd_p->toggle_select(this);				if(!nd_p->is_selected())Refresh();			}else if(ar_p!=0){ //arrow was touched				ar_p->toggle_select(this);				if(!ar_p->is_selected())Refresh();			}		}else{//shift key is not down			if(nd_id == max_ushort && ar_p ==0){//nothing touched				unselect_all();			}else if(nd_id != max_ushort){ //node was touched				if(nd_p->is_selected()){					//do nothing				}else{					unselect_all();					nd_p->select(this);				}			}else if(ar_p!=0){ //arrow was touched				if(ar_p->is_selected()){					//do nothing				}else{					unselect_all();					ar_p->select(this);				}			}		}			}				Point old_pt, new_pt;	Rect  sel_rect;		if(nd_id == max_ushort && ar_p==0){ //no node or arrow was touched		StCPTstate		saved_st(true, true, false);		saved_st.Normalize();		Pattern gray;	::GetQDGlobalsGray(&gray);		Pattern black;	::GetQDGlobalsBlack(&black);		::PenPat(&gray);		::PenMode(patXor);		new_pt = m_down_pt;		old_pt = m_down_pt;		::SetRect(&sel_rect, m_down_pt.h, m_down_pt.v, new_pt.h, new_pt.v);			while(::StillDown()){			::GetMouse(&new_pt);			if(!::EqualPt(new_pt, old_pt)){				::FrameRect(&sel_rect);				if(AutoScrollImage(new_pt)){					//autoscroll normalizes the pen					::PenPat(&gray);					::PenMode(patXor);				}				::SetRect(&sel_rect, m_down_pt.h, m_down_pt.v, new_pt.h, new_pt.v);				::FrameRect(&sel_rect);								old_pt =new_pt;			}		}		::FrameRect(&sel_rect);		::PenPat(&black);		::PenMode(patCopy);		select_rect_contents(sel_rect);		return;	}	}//******************************************Rect	C_MAIN_VIEW::get_sel_rect(){	//2^15 = 32768;	SInt16	min_hor = 32767;	SInt16	min_ver = 32767;	SInt16	max_hor = -32767; //actually it goes as low as -32768	SInt16	max_ver	= -32767;		Point	center;	Rect	sel_rect;	USHORT  num_of_nds = its_net_p->get_num_of_nds();	for(USHORT	i = 0; i<num_of_nds; i++){		NODE  *   nd_p = its_net_p->get_nd_ptr(i);		if(nd_p->is_selected()){			center = nd_p->get_center();			if(min_hor>center.h)min_hor = center.h;			if(min_ver>center.h)min_ver = center.v;			if(max_hor<center.h)max_hor = center.h;			if(max_ver<center.h)max_ver = center.v;		}	}	sel_rect.top = min_ver - 16;	sel_rect.left = min_hor - 16;	sel_rect.bottom = max_ver + 16;	sel_rect.right = max_hor + 16;		return 	sel_rect;}//******************************************BOOLEAN		C_MAIN_VIEW::s_and_d_and_ar_selected(const C_ARROW	 *		ar_p)  //in{	return (		ar_p->is_selected() &&		its_net_p->get_nd_ptr(ar_p->get_d_port_name().its_nd_id)->is_selected() &&		its_net_p->get_nd_ptr(ar_p->get_s_port_name().its_nd_id)->is_selected()	);}//******************************************BOOLEAN		C_MAIN_VIEW::s_or_d_or_ar_selected(const C_ARROW	 *		ar_p)  //in{	return (		ar_p->is_selected() ||		its_net_p->get_nd_ptr(ar_p->get_d_port_name().its_nd_id)->is_selected() ||		its_net_p->get_nd_ptr(ar_p->get_s_port_name().its_nd_id)->is_selected()	);}//******************************************VOID		C_MAIN_VIEW::get_map_with_sel_last(UI_MAP	 &		map_with_sel_last)	//out{	USHORT		num_of_nds = its_net_p->get_num_of_nds();		USHORT		i_unsel_nds = 0;	USHORT		i_sel_nds = num_of_nds - its_num_of_sel_nds;		map_with_sel_last.set_to_default_map(num_of_nds);	for(USHORT i=0; i<num_of_nds; i++){		if(!its_net_p->get_nd_ptr(i)->is_selected()){			map_with_sel_last.its_newfo[i]=i_unsel_nds;			i_unsel_nds++;		}else{			map_with_sel_last.its_newfo[i]=i_sel_nds;			i_sel_nds++;		}	}	map_with_sel_last.set_oldfn();}//******************************************VOID   C_MAIN_VIEW::make_only_last_nds_selected(USHORT	num_of_sel_nds)	//in{	USHORT	num_of_nds = its_net_p->get_num_of_nds();	ThrowIf_(num_of_nds < num_of_sel_nds);	USHORT	num_of_unsel_nds = 	num_of_nds - num_of_sel_nds;	USHORT	nd;	for(nd=0; nd< num_of_unsel_nds; nd++){		its_net_p->get_nd_ptr(nd)->unselect(this);	}	for(nd=num_of_unsel_nds ; nd< num_of_nds; nd++){		its_net_p->get_nd_ptr(nd)->select(this);	}}/*//******************************************VOID   C_MAIN_VIEW::get_selected_arrows(SET &		sel_ars)	//out{	sel_ars.empty();	sel_ars.resize(its_net_p->get_num_of_arrows());	USHORT	ar_id=0;	C_ARROW  *  ar_p;		DIR_DATA<C_ARROW>  *  dir_arrow_p = its_net_p->get_arrows_first_p();	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		if(ar_p->is_selected())sel_ars.insert(ar_id);		dir_arrow_p = dir_arrow_p->its_next_p;		ar_id++;	}}//******************************************VOID   C_MAIN_VIEW::set_selected_arrows(const SET &		sel_ars)	//in{	USHORT	ar_id=0;	C_ARROW  *  ar_p;		DIR_DATA<C_ARROW>  *  dir_arrow_p = its_net_p->get_arrows_first_p();	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		if(sel_ars.contains(ar_id)){			if(!ar_p->is_selected()) ar_p->select(this);		}else{//sel_ars does not contain ar_id			if(ar_p->is_selected()) ar_p->unselect(this);		}		dir_arrow_p = dir_arrow_p->its_next_p;		ar_id++;	}}*///******************************************VOID   C_MAIN_VIEW::make_only_first_arrows_selected(USHORT	num_of_sel_ars)	//in{	USHORT		pos=0;	C_ARROW  *  ar_p;		DIR_DATA<C_ARROW>  *  dir_arrow_p = its_net_p->get_arrows_first_p();	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		if(pos<num_of_sel_ars){			if(!ar_p->is_selected()) ar_p->select(this);		}else{			if(ar_p->is_selected()) ar_p->unselect(this);		}		dir_arrow_p = dir_arrow_p->its_next_p;		pos++;	}}#pragma mark --tool behavior--//******************************************VOID   C_MAIN_VIEW::respond_to_bi_nd_selector(const Point  &  m_down_pt)		//in{	USHORT  touched_nd = get_touched_nd(m_down_pt);	if(touched_nd==max_ushort)return;	its_bi_nd_wind_p->respond_to_bi_nd_selector(touched_nd);	}//******************************************VOID   C_MAIN_VIEW::respond_to_drag_tool(const Point  &  m_down_pt)		//in{// can't use get_(first)_touched_nd here. //What is needed is get_first_touched_selected_nd	FocusDraw();	Point	new_pt = m_down_pt;	Point 	old_pt = m_down_pt;	Point 	delta;	NODE  *  nd_p;	for(USHORT nd=0; nd < its_net_p->get_num_of_nds(); nd++){		nd_p = its_net_p->get_nd_ptr(nd);		if( nd_p->pt_is_in_sel_cir(m_down_pt) && nd_p->is_selected() ){			while(::StillDown()){				::GetMouse(&new_pt);				if(!::EqualPt(new_pt, old_pt)){					delta.h =new_pt.h - old_pt.h;					delta.v =new_pt.v - old_pt.v;					move_selection_by(delta);					old_pt =new_pt;				}				AutoScrollImage(new_pt);			}			Refresh();			return;		}	}	return;}//******************************************VOID   C_MAIN_VIEW::respond_to_open_tool(const Point  &  m_down_pt)		//in{	USHORT 	touched_nd = get_touched_nd(m_down_pt);	if(	GetClickCount()==2 && touched_nd!=max_ushort){		if(its_net_p->get_run_state()==bef_run){			if(its_pi_wind_p==0){				create_pi_wind(touched_nd);			}else{				//It's not always necessary,				//but sometimes, like now, it's useful to				//unload editor of amps table before changing node.				//If don't unload it, changes made to				//last cell touched of the amps table				//will not be remembered.				//This would not be a fatal error.				if(!its_pi_wind_p->save_pi())return;				its_pi_wind_p->set_nd_if_diff(touched_nd);				its_pi_wind_p->Select();							}		}else{			if(its_nd_probs_wind_p==0){				create_nd_probs_wind(touched_nd);			}else{				its_nd_probs_wind_p->set_nd_if_diff(touched_nd);				its_nd_probs_wind_p->Select();							}		}			}}//******************************************VOID   C_MAIN_VIEW::respond_to_no_tool(const Point  &  m_down_pt)		//in{	if(	GetClickCount()==2){		respond_to_open_tool(m_down_pt);	}else{		//does mouse tracking iff node or arrow NOT touched:		respond_to_selection_tool(m_down_pt, false);		//does mouse tracking iff node touched:		respond_to_drag_tool(m_down_pt);		Refresh();	}}	//******************************************VOID  C_MAIN_VIEW::rotate_nd(const Point  &  m_down_pt)		//in{		USHORT	 nd_id = get_touched_nd(m_down_pt);	if(nd_id==max_ushort)return;			C_ARROW  *  	ar_p;	NODE  * 	s_nd_p;	NODE  * 	d_nd_p;		C_CIRCLE  s_cir, d_cir;	Point 	init_pt, fin_pt;	C_PORT_NAME  s_port_name, d_port_name;	DIR_DATA<C_ARROW>  *  dir_arrow_p;			its_net_p->get_nd_ptr(nd_id)->rotate();	dir_arrow_p = its_net_p->get_arrows_first_p();		while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		s_port_name = ar_p->get_s_port_name();		d_port_name = ar_p->get_d_port_name();		if( (s_port_name.its_nd_id==nd_id)||			(d_port_name.its_nd_id==nd_id) ){				//			ar_p->undraw();	//not necessary because of refresh at the end						s_nd_p = its_net_p->get_nd_ptr(s_port_name.its_nd_id);			d_nd_p = its_net_p->get_nd_ptr(d_port_name.its_nd_id);			s_cir = s_nd_p->get_docking_cir(s_port_name.its_sub_nd_id);			d_cir = d_nd_p->get_docking_cir(d_port_name.its_sub_nd_id);			if(its_net_p->calc_closest_pts(s_cir, d_cir, init_pt, fin_pt)){				ar_p->set_init_pt(init_pt);				ar_p->set_fin_pt(fin_pt);//				ar_p->draw(); 	//not necessary because of refresh at the end			} 		}		dir_arrow_p = dir_arrow_p->its_next_p;	}	Refresh();}//******************************************VOID	C_MAIN_VIEW::paint_nd(const Point  &  pt)		//in{ // get_(first)_touched_nd not good enough. Want first touched, colored node.	NODE  * 	nd_p;	for(USHORT nd=0; nd < its_net_p->get_num_of_nds(); nd++){		nd_p = its_net_p->get_nd_ptr(nd); 		if( nd_p->has_color() && nd_p->pt_is_in_sel_cir(pt)){			C_APP  * 	app_p=(C_APP  *)LCommander::GetTopCommander();			nd_p->set_color(app_p->get_cur_color());			nd_p->draw();			return;						}	}}//******************************************VOID	C_MAIN_VIEW::copy_nd_color(const Point  &  pt)		//in{ // get_(first)_touched_nd not good enough. Want first touched, colored node.	NODE  * 	nd_p;	for(USHORT nd=0; nd < its_net_p->get_num_of_nds(); nd++){		nd_p = its_net_p->get_nd_ptr(nd); 		if( nd_p->has_color() && nd_p->pt_is_in_sel_cir(pt)){			C_APP  * 	app_p=(C_APP  *)LCommander::GetTopCommander();			app_p->set_cur_color(nd_p->get_color());			return;						}	}}//******************************************VOID	C_MAIN_VIEW::maybe_add_arrow(const Point  &  m_down_pt)		//in{//drawer	FocusDraw();	StCPTstate		saved_st(true, true, false);	saved_st.Normalize();			// m_down_pt = mouse down point	C_PORT_NAME  s_port_name = get_touched_avail_s_port(m_down_pt);	USHORT  s_nd = s_port_name.its_nd_id;	if(s_nd ==max_ushort) return;	C_ARROW_DRAWER  cupid((LView  *)this, 16, 25); // (view, arrowhead length, halfwidth)		Point	old_pt = m_down_pt;	Point 	new_pt;	::PenMode(patXor);	while(::StillDown()){		::GetMouse(&new_pt);		if(!::EqualPt(new_pt, old_pt)){			cupid.sketch(m_down_pt, old_pt);// on the first pass, this does nothing				//because m_down_pt = old_pt			if(AutoScrollImage(new_pt)){				//autoscroll normalizes the pen				::PenMode(patXor);			}			cupid.sketch(m_down_pt, new_pt);							old_pt =new_pt;		}	}	// We erase the last arrow:	// it's no good because m_down_pt and m_up_pt 	//do not dock properly on the s and d ports.	cupid.sketch(m_down_pt, new_pt);	::PenMode(patCopy);		Point   m_up_pt; // m_up_pt = mouse up point	::GetMouse(&m_up_pt);	C_PORT_NAME  d_port_name = get_touched_avail_d_port(m_up_pt);	USHORT	d_nd = d_port_name.its_nd_id;	 	if((d_nd != max_ushort)&&(d_nd !=s_nd)){		if(its_net_p->mac_add_int_arrow(s_port_name, d_port_name, true)){			if(its_pi_wind_p!=0){				if(d_nd==its_pi_wind_p->get_nd()){					//must refresh pi_wind in this case					its_pi_wind_p->set_nd_always(d_nd);				}					}		}	}	Refresh();	}//******************************************VOID	C_MAIN_VIEW::maybe_change_source_nd_of_ar(const Point  &  m_down_pt)		//in{//drawer	//this function is similar to C_MAIN_VIEW::maybe_add_arrow()	FocusDraw();	StCPTstate		saved_st(true, true, false);	saved_st.Normalize();		C_ARROW  *   ar_p = get_touched_ar(m_down_pt);	if(ar_p==0) return;	Point  	old_fin_pt = ar_p->get_fin_pt();	Point	old_init_pt = ar_p->get_init_pt();	C_ARROW_DRAWER  cupid((LView  *)this, 16, 25); // (view, arrowhead length, halfwidth)		Point	old_pt = old_init_pt;	Point 	new_pt;	ar_p->unselect(this);	::PenMode(patXor);		while(::StillDown()){		::GetMouse(&new_pt);//initially new_pt = m_down_pt		if(!::EqualPt(new_pt, old_pt)){			cupid.sketch(old_pt, old_fin_pt);			if(AutoScrollImage(new_pt)){				//autoscroll normalizes the pen				::PenMode(patXor);			}			cupid.sketch(new_pt, old_fin_pt);							old_pt =new_pt;		}	}	//We erase the last arrow:	//it's no good because m_down_pt and m_up_pt 	//do not dock properly on the s and d ports.	cupid.sketch(new_pt, old_fin_pt);	::PenMode(patCopy);		Point   m_up_pt; // m_up_pt = mouse up point	::GetMouse(&m_up_pt);	C_PORT_NAME  d_port_name = ar_p->get_d_port_name();	USHORT  d_nd = d_port_name.its_nd_id;	C_PORT_NAME  s_port_name = get_touched_avail_s_port(m_up_pt);	USHORT	s_nd = s_port_name.its_nd_id;	 	if((s_nd != max_ushort)&&(s_nd !=d_nd)){		if(its_net_p->change_source_nd_of_ar(ar_p, s_port_name)){			if(its_pi_wind_p!=0){				if(d_nd==its_pi_wind_p->get_nd()){					//must refresh pi_wind in this case					its_pi_wind_p->set_nd_always(d_nd);				}					}		}	}	Refresh();	}//******************************************VOID	C_MAIN_VIEW::Click(SMouseDownEvent	&	inMouseDown)	//in{	//MONITOR_THE_CHANGE_HERE	//if call its_doc_p->SetModified(true) inside ClickSelf() rather than Click(),	//then it won't be called if I click on subpanes like nd edit fields	its_doc_p->SetModified(true);		its_pasting_center.h = inMouseDown.whereLocal.h;	its_pasting_center.v = inMouseDown.whereLocal.v;		LView::Click(inMouseDown);}//******************************************VOID   C_MAIN_VIEW::ClickSelf(const SMouseDownEvent  &  in_mouse_down)	//in{	//MONITOR_THE_CHANGE_HERE	//doc: marked modified in C_MAIN_VIEW::Click()		Point  m_down_pt = in_mouse_down.whereLocal;		//if( FindSubPaneHitBy(m_down_pt.h, m_down_pt.v)!=0) return;//this is redundant	SwitchTarget(this);	// makes main view the target as soon as click outside editfields				USHORT 	touched_nd;			if(its_bi_nd_wind_p!=0 && its_bi_nd_wind_p->is_selector_ON()){		respond_to_bi_nd_selector(m_down_pt);//calculates touched nd internally		 return;	}					C_APP  * 	app_p=(C_APP  *)LCommander::GetTopCommander();			SInt16 	cur_tool = app_p->get_cur_tool();	ND_CLASS_ID		nd_class_id(NO_NODE_id);	switch(cur_tool){		case no_tool:			respond_to_no_tool(m_down_pt);//calculates touched nd internally			break;		case selection_tool:			respond_to_selection_tool(m_down_pt, true);//calculates touched nd internally			break;		case drag_tool: 			respond_to_drag_tool(m_down_pt);//DOESN'T calculate touched nd internally, but calculates something similar 			break;		case open_tool:			respond_to_open_tool(m_down_pt);//calculates touched nd internally			break;		case rotation_tool:			rotate_nd(m_down_pt);//calculates touched nd internally			break;		case paint_tool:			paint_nd(m_down_pt);//DOESN'T calculate touched nd internally, but calculates something similar 			break;		case copy_color_tool:			copy_nd_color(m_down_pt);//DOESN'T calculate touched nd internally, but calculates something similar 			break;		case arrow_tool:			if(its_net_p->get_run_state()!=bef_run){only_allowed_in_initial_run_state_alert(); return;}			maybe_add_arrow(m_down_pt);//DOESN'T calculate touched nd internally, but calculates something similar  			break;		case arrow_source_tool:			if(its_net_p->get_run_state()!=bef_run){only_allowed_in_initial_run_state_alert(); return;}			maybe_change_source_nd_of_ar(m_down_pt);//DOESN'T calculate touched nd internally, but calculates something similar  			break;		case beam_spl_tool:			nd_class_id = BEAM_SPL_id;			break;		case custom_nd_tool:			nd_class_id = CUSTOM_ND_id;			break;		case det_nd_tool:			nd_class_id = DET_ND_id;			break;		case pol_rot_tool:			nd_class_id = POL_ROTATOR_id;			break;		case polarizer_tool:			nd_class_id = POLARIZER_id;			break;		case qbit_rot_tool:			nd_class_id = QBIT_ROT_id;			break;		case sg_magnet_tool:			nd_class_id = SG_MAGNET_id;			break;	}//cur_tool switch		if(nd_class_id!=NO_NODE_id){		if(its_net_p->get_run_state()!=bef_run){only_allowed_in_initial_run_state_alert(); return;}		touched_nd = get_touched_nd(m_down_pt);		if(touched_nd==max_ushort){			its_net_p->mac_add_nd(nd_class_id, m_down_pt, true);		}	}/* 	//autoscroll code from Muscle Demo, CBigView::ClickSelf()	//This doesn't work for me because respond_to_drag_tool	//has its own while(::StillDown())	while (::StillDown()) {		FocusDraw();		Point	localMouse;		::GetMouse(&localMouse);		AutoScrollImage(localMouse);	}*/	}//******************************************VOID   C_MAIN_VIEW::AdjustMouseSelf(Point in_port_pt,						//in const EventRecord  &   in_mac_event, 	//inRgnHandle outMouseRgn)					//out{#pragma unused(in_mac_event, outMouseRgn)/*	LPane  * 	hit_pane = FindSubPaneHitBy(in_port_pt.h, in_port_pt.v);	if( hit_pane !=0){		hit_pane->AdjustCursor(in_port_pt, in_mac_event);		return;	}*/	if(its_bi_nd_wind_p!=0 && its_bi_nd_wind_p->is_selector_ON()){		UCursor::SetTheCursor(bi_node_and_pointing_hand_rid);		return;	}					C_APP  * 	app_p=(C_APP  *)LCommander::GetTopCommander();	SInt16 	cur_tool = app_p->get_cur_tool();	ResIDT		cursor_rid;	switch(cur_tool){		case no_tool:			UCursor::SetArrow();	//arrow			break;		case selection_tool:			UCursor::SetTheCursor(pointing_hand_rid);			break;		case drag_tool:			cursor_rid = open_hand_rid;			if(::StillDown()){//this is NOT a while(::StillDown()) loop				NODE  *  nd_p;				for(USHORT nd=0; nd < its_net_p->get_num_of_nds(); nd++){					nd_p = its_net_p->get_nd_ptr(nd);					if( nd_p->pt_is_in_sel_cir(in_port_pt) && nd_p->is_selected() ){						cursor_rid = closed_hand_rid;					}				}			}			UCursor::SetTheCursor(cursor_rid);			break;		case open_tool:			UCursor::SetTheCursor(explosion_rid);			break;		case rotation_tool:			UCursor::SetTheCursor(clockwise_rot_rid);			break;		case paint_tool:			UCursor::SetTheCursor(paint_brush_rid);			break;		case copy_color_tool:			UCursor::SetTheCursor(eye_dropper_rid);			break;		case arrow_tool:			UCursor::SetTheCursor(bow_and_arrow_rid);			break;		case arrow_source_tool:			UCursor::SetTheCursor(arrow_source_rid);			break;		case beam_spl_tool:			case custom_nd_tool:		case det_nd_tool:		case pol_rot_tool:		case polarizer_tool:		case qbit_rot_tool:		case sg_magnet_tool:			UCursor::SetTheCursor(crossCursor);			break;		default:			// same as LPane::AdjustCursorSelf(in_port_pt, in_mac_event);			UCursor::InitTheCursor();	//arrow					break;					}}	#pragma mark --write/read net--//******************************************VOID	C_MAIN_VIEW::translate_pt_from_sel_to_pasting_rect(Point	 &	 	pt,			//i-oconst Rect  &	sel_rect)	//in{	Point 	delta;		delta.h = 8;	delta.v = 8;		if(its_pasting_center.h!=0 && its_pasting_center.v!=0){		Point 	sel_center;		sel_center.h = sel_rect.left + (sel_rect.right -sel_rect.left)/2;		sel_center.v = sel_rect.top + (sel_rect.bottom -sel_rect.top)/2;		delta.h = its_pasting_center.h - sel_center.h;		delta.v = its_pasting_center.v - sel_center.v;	}		pt.h += delta.h;	pt.v +=	delta.v;	}	//******************************************BOOLEAN		C_MAIN_VIEW::pasting_should_restore_amps_of(USHORT		nd_id)  //in{	NODE  *		nd_p = its_net_p->get_nd_ptr(nd_id);	//false if node is not selected		if(!nd_p->is_selected()) return false;	//false if at least one of the node's parents is NOT selected		USHORT		num_of_in_nds = nd_p->get_in_nds().get_len();	for(USHORT	i=0; i<num_of_in_nds; i++){				if(!its_net_p->get_nd_ptr(nd_p->get_in_nds()[i])->is_selected())return false;	}		return true;}//******************************************BOOLEAN		C_MAIN_VIEW::undeleting_should_restore_amps_of(USHORT		nd_id)  //in{	NODE  *		nd_p = its_net_p->get_nd_ptr(nd_id);		//true if node is selected	if(nd_p->is_selected())return true;		//true if at least one of the node's parents is selected	USHORT		num_of_in_nds = nd_p->get_in_nds().get_len();	for(USHORT	i=0; i<num_of_in_nds; i++){				if(its_net_p->get_nd_ptr(nd_p->get_in_nds()[i])->is_selected())return true;	}	//true if some incoming arrow is selected	C_ARROW  *  ar_p;		DIR_DATA<C_ARROW>  *  dir_arrow_p = its_net_p->get_arrows_first_p();	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		if(ar_p->is_selected() && ar_p->get_d_port_name().its_nd_id==nd_id)return true;		dir_arrow_p = dir_arrow_p->its_next_p;	}		return false;}//******************************************VOID	C_MAIN_VIEW::write_net_stream(LStream  &  		net_stream,			//i-o	NET_STREAM_TYPE		stream_type)		//in{	if(stream_type==open_reco){		net_stream<<its_image_horiz_inches;//write_net		net_stream<<its_image_vert_inches;//write_net			Rect 	bds;		its_main_wind_p->CalcPortFrameRect(bds);		its_main_wind_p->PortToGlobalPoint(topLeft(bds));		its_main_wind_p->PortToGlobalPoint(botRight(bds));		net_stream<<bds;//write_net		net_stream<<its_has_grid_lines;//write_net		net_stream<<its_fnum;//write_net		if(its_doc_p->get_vers_int32()<= k_vers_160){			net_stream<<its_fname_item_num;//write_net		}		net_stream<<its_fsize;//write_net	}		its_net_p->write_net_stream(net_stream, stream_type);//write_net}//******************************************VOID	C_MAIN_VIEW::read_net_stream(LStream  &  		net_stream,			//i-o	NET_STREAM_TYPE		stream_type)		//in{		if(stream_type==open_reco){			net_stream>>its_image_horiz_inches;//read_net		net_stream>>its_image_vert_inches;//read_net		Rect 	bds;		net_stream>> bds;//read_net		//C_MAIN_VIEW::FinishCreate() called default values		//need to update		ResizeImageTo(pix_per_in*its_image_horiz_inches, 			pix_per_in*its_image_vert_inches, false);		set_min_max_and_std_of_wind(false);		its_main_wind_p->DoSetBounds(bds);				net_stream>>its_has_grid_lines;//read_net					net_stream>>its_fnum;//read_net		if(its_doc_p->get_vers_int32()<= k_vers_160){			net_stream>>its_fname_item_num;//read_net		}		net_stream>>its_fsize;//read_net				check_fsize_and_fnum();		its_fname_item_num = UFontMenu::GetFontItemNumber(its_fnum);			}		its_net_p->read_net_stream(net_stream, stream_type);//read_net}#pragma mark --copy, del, cut, paste--//******************************************VOID	C_MAIN_VIEW::copy_selection(){	//this function is analogous to C_DOC::DoSave()		//sel = net selection		//Checks for selected nodes.	//If finds none:	//zeros scrap, 	//kills any L_MAIN_VIEW's uactions,	//and then returns.	if(!at_least_one_nd_is_sel()){		UScrap::ClearData();		PostAction(0);		return;	}			UI_MAP  	map_with_sel_last(its_net_p->get_num_of_nds());  	get_map_with_sel_last(map_with_sel_last);	its_net_p->reorder_nds(map_with_sel_last);		LHandleStream   net_stream;	write_net_stream(net_stream, paste_reco);//write_net		UI_MAP	inv_map;	map_with_sel_last.get_inverse(inv_map);	its_net_p->reorder_nds(inv_map);				Handle 	data_h = net_stream.GetDataHandle();	//create_h:		PP creates data_h in LHandleStream() with call to ::NewHandle().	//throwif_h:	PP calls ThrowIfMemFail_(mDataH) immediately after creation.	//destroy_h:	PP destroys data_h inside ~LHandleStream().	ThrowIfNil_(data_h);	//NSel = net selection	UScrap::SetData('NSel', data_h); 	//zero pasting center immediately after copy		its_pasting_center.h = 0;	its_pasting_center.v = 0;}//******************************************VOID   C_MAIN_VIEW::delete_selection(BOOLEAN		sel_is_last)	//i-o{	USHORT num_of_nds = its_net_p->get_num_of_nds();	if(num_of_nds==0)return;	USHORT	init_num_of_sel_nds = its_num_of_sel_nds;	if(!sel_is_last){		UI_MAP		map_with_sel_last(num_of_nds);		get_map_with_sel_last(map_with_sel_last);		its_net_p->reorder_nds(map_with_sel_last);	}	//The following will also delete unselected arrows	//if they are connected to a selected node.	//By deleting the last node each time, we avoid 	//reordering operation in del_nd() if nodes have	//already been reordered so that selected ones are last.	for(USHORT i = 0; i<init_num_of_sel_nds; i++){		its_net_p->del_nd(num_of_nds- 1, false);		num_of_nds--;	}	C_ARROW  * ar_p;		DIR_DATA<C_ARROW>  *  dir_arrow_p = its_net_p->get_arrows_first_p();	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		if( ar_p->is_selected() ){			its_net_p->del_int_arrow(	ar_p->get_s_port_name().its_nd_id,									ar_p->get_d_port_name().its_nd_id, false);			dir_arrow_p = its_net_p->get_arrows_first_p();					}else{			dir_arrow_p = dir_arrow_p->its_next_p;		}	}		its_net_p->chrono_sort();		Refresh();	//at this point, num_of_nds= num of nodes after selection has been deleted.		if(num_of_nds!=0){		if(its_pi_wind_p!=0){			its_pi_wind_p->set_nd_always(0);		}		if(its_bi_nd_wind_p!=0){			its_bi_nd_wind_p->refill_list_box();		}				}else{		if(its_pi_wind_p!=0){			its_pi_wind_p->ProcessCommand(cmd_Close);						its_pi_wind_p=0;		}						if(its_bi_nd_wind_p!=0){			its_bi_nd_wind_p->ProcessCommand(cmd_Close);						its_bi_nd_wind_p=0;		}					}	//Go from some nodes selected to no nodes selected 	//(may even have zero nodes at this point) so	//must update menus (from enabled to disabled).		//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating:		LCommander::SetUpdateCommandStatus( true );				}//******************************************VOID	C_MAIN_VIEW::paste_clipping(){		//this function is analogous to C_DOC::open_file()	SInt32	len;	Handle	data_h = ::NewHandle( 0L );	//create_h:		I create data_h with call to ::NewHandle().	//throwif_h:	I call ThrowIfMemFail_ above.	//				I also call ThrowOSErr_ immediately after call to GetScrap,	//			 	which allocates more space for data_h	//destroy_h:	PP destroys data_h inside ~LHandleStream().	ThrowIfMemFail_(data_h);	len = UScrap::GetData('NSel', data_h);	if(len == noTypeErr){		//no data of this type was found		DisposeHandle_(data_h);		return;	}	if(len < 0) ThrowOSErr_(len);			LHandleStream   net_stream(data_h);	read_net_stream(net_stream, paste_reco);//read_net	Refresh();	//May go from no nodes selected to some nodes selected so	//must update menu (from disabled to enabled).		//This is an LCommander inline that just changes the needs-update data member.	//It does not itself do the menu updating:		LCommander::SetUpdateCommandStatus( true );		SwitchTarget(this);	//edit field is target if don't include this.	}#pragma mark --command center--//******************************************BOOLEAN   C_MAIN_VIEW::HandleKeyPress(const EventRecord  & in_key_event)		//in{//MONITOR_THE_CHANGE_HERE//doc marked modified in C_MAIN_VIEW::ObeyCommand()	if( ((in_key_event.message &keyCodeMask)>>8) == 0x33){//delete key was pressed		//This is like a combination of ObeyCommand() and FindCommandStatus()		if(at_least_one_nd_is_sel()||at_least_one_arrow_is_sel()){			return ProcessCommand(cmd_Clear);		}else{			return true;		}	}else{		return LCommander::HandleKeyPress(in_key_event);	}}//******************************************BOOLEAN		C_MAIN_VIEW::ObeyCommand(CommandT	inCommand,		//inVOID  *		ioParam)		//i-o{	//MONITOR_THE_CHANGE_HERE		//When C_MAIN_VIEW is the target commander,	//UNDO or REDO commands are enabled 	//iff an LAction object exists for C_MAIN_VIEW. 	//We will always mark a doc 	//modified as soon such an LAction is created ("posted").	BOOLEAN  	mark_doc_modified = true;	BOOLEAN		obeyed = true;	BOOLEAN		needs_refresh = true;	ResIDT		menuID;	SInt16		menuItem;	RUN_STATE run_st = its_net_p->get_run_state();		if (IsSyntheticCommand(inCommand, menuID, menuItem)) {		if (menuID == MENU_Font) {							its_fnum = UFontMenu::GetFontNumber(menuItem);			its_fname_item_num = menuItem;			for(USHORT nd=0; nd < its_net_p->get_num_of_nds(); nd++){				its_net_p->get_nd_ptr(nd)->get_efield_ptr()->set_fnum(its_fnum);			}			}else if (menuID == MENU_Size){			its_fsize = USizeMenu::GetFontSize(menuItem);			for(USHORT nd=0; nd < its_net_p->get_num_of_nds(); nd++){				its_net_p->get_nd_ptr(nd)->get_efield_ptr()->set_fsize(its_fsize);			}		}else {			//let super commander decide if the menus items it's 			//resposible for modify document			mark_doc_modified = false;				obeyed = LCommander::ObeyCommand(inCommand, ioParam);			needs_refresh = false;		}	} else {		switch (inCommand) {			case cmd_Cut:				if(run_st!=bef_run){					mark_doc_modified = false;					only_allowed_in_initial_run_state_alert();				}else{					PostAction(new C_NET_DEL_OR_CUT_ACTION(1, its_doc_p, this, its_net_p));//= new					//delete:				}				break;			case cmd_Copy:				mark_doc_modified = false;				if(run_st!=bef_run){					only_allowed_in_initial_run_state_alert();				}else{					copy_selection();				}				break;			case cmd_Paste:				if(run_st!=bef_run){					mark_doc_modified = false;					only_allowed_in_initial_run_state_alert();				}else{					paste_clipping();				}				break;					case cmd_Clear:				if(run_st!=bef_run){					mark_doc_modified = false;					only_allowed_in_initial_run_state_alert();				}else{					PostAction(new C_NET_DEL_OR_CUT_ACTION(0, its_doc_p, this, its_net_p));//= new					//delete:				}				break;			case cmd_SelectAll:				mark_doc_modified = false;				select_all();				break;			case cmd_drawing_size:				if(!handle_drawing_size_dialog())mark_doc_modified = false;				break;			case cmd_grid_lines:				toggle(its_has_grid_lines);				break;			case cmd_FontOther:					//	When the user chooses "Other" from the Size menu, we					//	display the Other Size dialog box using a single					//	function call. UModalDialogs::AskForOneNumber() handles					//	all user interaction until the user dismisses the					//	dialog box. It returns true if the user clicked OK,					//	and false if the user clicked Cancel.									SInt32 newSize = its_fsize;				needs_refresh = UModalDialogs::AskForOneNumber(this, other_fsize_window_rid,															other_fsize_efield_rid, newSize);				// 6 is min font size (see CSampleText::SetSize() in cookbook examples)				its_fsize = (newSize>=6?newSize:6);				for(USHORT nd=0; nd < its_net_p->get_num_of_nds(); nd++){					its_net_p->get_nd_ptr(nd)->get_efield_ptr()->set_fsize(its_fsize);				}				break;							case cmd_show_pi_wind:				mark_doc_modified = false;				if(its_pi_wind_p==0){					create_pi_wind(0);//open prior info wind for the first node				}else{										if(C_KEYS::KeyIsDown(0X3A)){ //option_key=0x3A						its_pi_wind_bds_reco.move_to_top_right_corner_of_screen(its_pi_wind_p);					}					its_pi_wind_p->Select();							}				break;			case cmd_show_bi_nd_wind:				mark_doc_modified = false;				if(its_bi_nd_wind_p==0){					create_bi_nd_wind();				}else{					if(C_KEYS::KeyIsDown(0X3A)){ //option_key=0x3A						its_bi_nd_wind_bds_reco.move_to_top_right_corner_of_screen(its_bi_nd_wind_p);					}					its_bi_nd_wind_p->Select();							}				break;			case cmd_show_nd_probs_wind:				mark_doc_modified = false;				if(its_nd_probs_wind_p==0){					create_nd_probs_wind(0);				}else{					if(C_KEYS::KeyIsDown(0X3A)){ //option_key=0x3A						its_nd_probs_wind_bds_reco.move_to_top_right_corner_of_screen(its_nd_probs_wind_p);					}					its_nd_probs_wind_p->Select();							}				break;			case cmd_show_bi_nd_probs_wind:				mark_doc_modified = false;				if(its_bi_nd_probs_wind_p==0){					create_bi_nd_probs_wind(0);				}else{					if(C_KEYS::KeyIsDown(0X3A)){ //option_key=0x3A						its_bi_nd_probs_wind_bds_reco.move_to_top_right_corner_of_screen(its_bi_nd_probs_wind_p);					}					its_bi_nd_probs_wind_p->Select();							}				break;			case cmd_show_stories_wind:				mark_doc_modified = false;				if(its_stories_wind_p==0){					create_stories_wind();				}else{					if(C_KEYS::KeyIsDown(0X3A)){ //option_key=0x3A						its_stories_wind_bds_reco.move_to_top_right_corner_of_screen(its_stories_wind_p);					}					its_stories_wind_p->Select();							}				break;			case cmd_close_all_non_main_winds:				mark_doc_modified = false;				if(its_pi_wind_p!=0){					if(!its_pi_wind_p->save_pi()){						obeyed=false;						break;					}else{													its_pi_wind_p->ProcessCommand(cmd_Close);									finish_pi_wind_closing();					}				}				if(its_bi_nd_wind_p!=0){					its_bi_nd_wind_p->ProcessCommand(cmd_Close);								finish_bi_nd_wind_closing();				}								if(its_nd_probs_wind_p!=0){					its_nd_probs_wind_p->ProcessCommand(cmd_Close);								finish_nd_probs_wind_closing();				}								if(its_bi_nd_probs_wind_p!=0){					its_bi_nd_probs_wind_p->ProcessCommand(cmd_Close);								finish_bi_nd_probs_wind_closing();				}				if(its_stories_wind_p!=0){					its_stories_wind_p->set_item_if_diff(1);					its_stories_wind_p->ProcessCommand(cmd_Close);								finish_stories_wind_closing();				}				// pass it up chain of command so palette is also closed:								obeyed = LCommander::ObeyCommand(inCommand, ioParam);				needs_refresh = false;				break;			default:				//let super commander decide if the menus items it's 				//resposible for modify document				mark_doc_modified = false;								obeyed = LCommander::ObeyCommand(inCommand, ioParam);				needs_refresh = false;				break;		}	}		if(mark_doc_modified) its_doc_p->SetModified(true);		if (needs_refresh) Refresh();	return obeyed;}//******************************************VOID	C_MAIN_VIEW::FindCommandStatus(CommandT		inCommand,		//inBOOLEAN		&	outEnabled,		//outBOOLEAN		&	outUsesMark,	//outUInt16		&	outMark,		//outStr255			outName_pstr)	//out{	outEnabled = false;			outUsesMark = false;	outMark = noMark;		USHORT	num_of_nds = its_net_p->get_num_of_nds();		RUN_STATE run_st = its_net_p->get_run_state();		ResIDT	menuID;	SInt16	menuItem;	if (IsSyntheticCommand(inCommand, menuID, menuItem)) {		if (menuID == MENU_Font){				//	The Font menu doesn't have a corresponding Mcmd resource,				//	so FindCommandStatus() only handles the case where we're				//	updating the entire menu. UFontMenu::AdjustMenu() enables				//	all the menu items and places a check mark next to the				//	name of the current font.			outEnabled=true;// a small bug in Adjust menu(): it expects this initial condition			UFontMenu::AdjustMenu(its_fname_item_num);		}else if (menuID == MENU_Size){						//	The commands in the Size menu that specify a particular				//	font size are specified with cmd_UseMenuItem in the Size				//	menu's corresponding Mcmd. That means that we'll get				//	synthetic command numbers for these items and that				//	UpdateMenus() will call FindCommandStatus() for each				//	one of those items.			USizeMenu::AdjustMenu(menuItem, its_fsize, its_fnum, outEnabled, outUsesMark, outMark);		}else{							LCommander::FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName_pstr);		}	}else{		switch (inCommand) {			case cmd_Cut:				if(at_least_one_nd_is_sel())outEnabled = true;				break;			case cmd_Copy:				outEnabled = true;				break;			case cmd_Paste:				if(UScrap::HasData('NSel'))outEnabled = true;				break;					case cmd_Clear:				if( at_least_one_nd_is_sel()||at_least_one_arrow_is_sel() )outEnabled = true;				break;				case cmd_SelectAll:				if(num_of_nds!=0)outEnabled = true;				break;			case cmd_PageSetup:				outEnabled = true;				break;									case cmd_drawing_size:				outEnabled = true;				break;									case cmd_grid_lines:				outEnabled = true;				outUsesMark = true;				outMark = its_has_grid_lines?checkMark:noMark;				break;									case cmd_FontMenu:				if(num_of_nds!=0)outEnabled = true;				break;				case cmd_SizeMenu:				if(num_of_nds!=0)outEnabled = true;				break;				case cmd_FontOther:				outEnabled = true;				break;			case cmd_show_pi_wind:				if(num_of_nds!=0 && run_st==bef_run){					outEnabled=true; 				}				if ( its_pi_wind_p==0 ) {					LString::CopyPStr( "\pOpen Node Prior-Info", outName_pstr );				} else {					LString::CopyPStr( "\pSELECT Node Prior-Info", outName_pstr );				}				break;			case cmd_show_bi_nd_wind:				if(num_of_nds!=0 && run_st==bef_run){					outEnabled=true; 				}				if ( its_bi_nd_wind_p==0 ) {					LString::CopyPStr( "\pOpen Bi-nodes Of Interest", outName_pstr );				} else {					LString::CopyPStr( "\pSELECT Bi-nodes Of Interest", outName_pstr );				}				break;			case cmd_show_nd_probs_wind:				if(num_of_nds!=0  && run_st!=bef_run){					outEnabled=true; 				}				if ( its_nd_probs_wind_p==0 ) {					LString::CopyPStr( "\pOpen Node Probs.", outName_pstr );				} else {					LString::CopyPStr( "\pSELECT Node Probs.", outName_pstr );				}				break;			case cmd_show_bi_nd_probs_wind:				if(num_of_nds!=0  && run_st!=bef_run && its_net_p->get_num_of_bi_nds()!=0){					outEnabled=true; 				}				if ( its_bi_nd_probs_wind_p==0 ) {					LString::CopyPStr( "\pOpen Bi-node Probs.", outName_pstr );				} else {					LString::CopyPStr( "\pSELECT Bi-node Probs.", outName_pstr );				}				break;			case cmd_show_stories_wind:				if(num_of_nds!=0 && run_st!=bef_run && its_net_p->get_anthology_len()!=0){					outEnabled=true; 				}				if ( its_stories_wind_p==0 ) {					LString::CopyPStr( "\pOpen Stories", outName_pstr );				} else {					LString::CopyPStr( "\pSELECT Stories", outName_pstr );				}				break;			default:								LCommander::FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName_pstr);				break;		}	}	}			 