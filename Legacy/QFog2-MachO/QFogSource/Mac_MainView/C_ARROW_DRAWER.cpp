#include "C_ARROW_DRAWER.h"//******************************************C_ARROW_DRAWER::C_ARROW_DRAWER(LView  * view_p, 	//inSInt16 len,			//inSInt16 width)		//in	:its_mview_p(view_p),	its_arrowhead_len(len),	its_arrowhead_halfwidth(width){}//******************************************/*VOID C_ARROW_DRAWER::draw(const Point  & init_pt,		//inconst Point  & fin_pt)		//in{ //drawer	if(!its_mview_p->FocusDraw())return;		// This function is based on article in MacTech (Aug 1985)	Rect  arrowhead_rect;      //the Rect that the arrowhead wedge is drawn in	   	Rect  init_rect;      //initial Rect used in PtToAngle to determine the arrow's direction	SInt16 	arrow_direction;  // arrow_direction, in degrees, measured clockwise from upward axis	if(::EqualPt(init_pt, fin_pt) ) return;		::MoveTo(init_pt.h, init_pt.v);  	::SetRect(&init_rect, //output  		init_pt.h-30, init_pt.v-30, init_pt.h+30, init_pt.v+30);//input   	::PtToAngle(&init_rect, fin_pt, &arrow_direction);//	SInt16 ss = nearest_int16(its_arrowhead_len*sin(my_pi/180*(arrow_direction-180)));//	SInt16 cc = nearest_int16(its_arrowhead_len*cos(my_pi/180*(arrow_direction-180)));//  ::LineTo(fin_pt.h + ss, fin_pt.v - cc);	::LineTo(fin_pt.h , fin_pt.v );  	//in next call, the one pixel horizontal displacement fixes glitch in downward-arrows  	::SetRect(&arrowhead_rect,//output  		fin_pt.h - its_arrowhead_len +1, fin_pt.v - its_arrowhead_len,//input   		fin_pt.h + its_arrowhead_len +1, fin_pt.v + its_arrowhead_len);//input  		 		::PaintArc(&arrowhead_rect,		 arrow_direction - 180 - its_arrowhead_halfwidth,		 2*its_arrowhead_halfwidth);}*///******************************************VOID C_ARROW_DRAWER::sketch(const Point  & init_pt,		//inconst Point  & fin_pt)		//in{ //drawer	//Sketch vs. draw	//We use the word sketch (draw) if the cpt state is imposed externally (internally) //init = initial, fin = final	if(!its_mview_p->FocusDraw())return;		if(::EqualPt(init_pt, fin_pt) ) return;			DOUBLE  arrow_len = sqrt(	pow(DOUBLE(init_pt.h - fin_pt.h), 2)		+ pow(DOUBLE(init_pt.v - fin_pt.v), 2)	);	DOUBLE  scale_factor = its_arrowhead_len/arrow_len;		DOUBLE rho_zero_h = (init_pt.h - fin_pt.h)*scale_factor; 	DOUBLE rho_zero_v = (init_pt.v - fin_pt.v)*scale_factor; 	DOUBLE tt = tan(its_arrowhead_halfwidth * my_pi/180.);	DOUBLE rho_plus_h =   rho_zero_h 		-tt*rho_zero_v;	DOUBLE rho_plus_v =   tt*rho_zero_h 	+rho_zero_v;	DOUBLE rho_minus_h =  rho_zero_h 		+tt*rho_zero_v;	DOUBLE rho_minus_v = -tt*rho_zero_h 	+rho_zero_v;	Point r_zero, r_plus, r_minus;	r_plus.h =  nearest_int16(rho_plus_h + fin_pt.h);	r_plus.v =  nearest_int16(rho_plus_v + fin_pt.v);		r_minus.h = nearest_int16(rho_minus_h + fin_pt.h);	r_minus.v = nearest_int16(rho_minus_v + fin_pt.v);//	r_zero.h =  nearest_int16(rho_zero_h + fin_pt.h);//	r_zero.v =  nearest_int16(rho_zero_v + fin_pt.v);	r_zero.h =  nearest_int16((rho_plus_h + rho_minus_h)*0.5 + fin_pt.h);	r_zero.v =  nearest_int16((rho_plus_v + rho_minus_v)*0.5 + fin_pt.v);		RgnHandle  rgn_h = ::NewRgn();	//destroy_h: in this method	ThrowIfNil_(rgn_h);	::OpenRgn();				::MoveTo(fin_pt.h, fin_pt.v);		::LineTo(r_plus.h, r_plus.v);		::LineTo(r_minus.h, r_minus.v);		::LineTo(fin_pt.h, fin_pt.v);	::CloseRgn(rgn_h);	::PaintRgn(rgn_h);	::DisposeRgn(rgn_h);/*	PolyHandle  poly_h;	poly_h = ::OpenPoly();	//destroy_h: in this method		ThrowIfNil_(poly_h);		::MoveTo(fin_pt.h, fin_pt.v);		::LineTo(r_plus.h, r_plus.v);		::LineTo(r_minus.h, r_minus.v);		::LineTo(fin_pt.h, fin_pt.v);	::ClosePoly();	::PaintPoly(poly_h);	::KillPoly(poly_h);*/	//Draw shaft.	//Drawing a pixel an even number of times screws up patXor.//Don't draw twice pixels where the arrowhead overlaps with the shaft./*	::MoveTo(init_pt.h, init_pt.v);	::LineTo(r_zero.h, r_zero.v);*/	::MoveTo(r_zero.h, r_zero.v);	::LineTo(init_pt.h, init_pt.v);}