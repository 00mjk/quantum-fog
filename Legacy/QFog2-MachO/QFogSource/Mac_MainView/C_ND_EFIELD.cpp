#include "C_ND_EFIELD.h"#include "C_MAIN_VIEW.h"#include "StCPTstate.h"#pragma mark --creation/destruction--//******************************************C_ND_EFIELD::C_ND_EFIELD(LStream  * inStream)	//in	:LEditField(inStream){}//******************************************C_ND_EFIELD::C_ND_EFIELD(){}//******************************************C_ND_EFIELD::~C_ND_EFIELD(){}//******************************************C_ND_EFIELD::C_ND_EFIELD(const SPaneInfo	&	inPaneInfo,Str255				in_pstr,ResIDT				inTextTraitsID,SInt16				inMaxChars,BOOLEAN				inHasBox,BOOLEAN				inHasWordWrap,TEKeyFilterFunc		inKeyFilter,LCommander	*		inSuper)	:LEditField(		inPaneInfo,		in_pstr,		inTextTraitsID,		inMaxChars,		inHasBox,		inHasWordWrap,		inKeyFilter,		inSuper){}//******************************************VOID	C_ND_EFIELD::FinishCreateSelf(){	//The default number of characters for an LEditfield	//created from the stream is	//is sizeof(SInt16) = 16. Change this to 31:	SetMaxChars(31);	C_MAIN_VIEW  *  view_p = (C_MAIN_VIEW  *)GetSuperView();	TextTraitsH	 text_traits_h = UTextTraits::LoadTextTraits(node_txt_rid);//not destroyed by PP	//create_h:		PP creates text_traits_h with a call to ::GetResource().	//throwif_h:	PP calls SignalIfNil immediately after creation.	//destroy_h:	PP does NOT release text_traits_h resource.	//				I delete it below, in this method	ThrowIfNil_(text_traits_h);	//about mTextEditH	//create_h: 	PP creates mTextEditH in LEditField() with call to ::TENew().	//throwif_h:	PP does not call throwif immediately after creation.	//destroy_h:	PP destroys mTextEditH in ~LEditField() with call to ::TEDispose(mTextEditH).	ThrowIfNil_(mTextEditH);		(**text_traits_h).fontNumber = view_p->get_fnum();	(**text_traits_h).size = view_p->get_fsize();	::HLock((Handle)text_traits_h);//no need to save handle state as will be destroying handle soon	UTextTraits::SetTETextTraits( *text_traits_h, mTextEditH );	ReleaseResource_((Handle)text_traits_h); 	 	UserChangedText();	//If I don't give an undoer to each C_ND_EFIELD,	//it will post its actions at the undoer of C_MAIN_VIEW.	//This produces a bug if you edit a C_ND_EFIELD,	//and then you try to delete the node with that efield.	//The bug is that undoing the node deletion is not permitted.	LUndoer  * undoer_p = new LUndoer;	//delete:	PP deletes undoer_p via 	//			~C_ND_EFIELD->~LPane()	//			->~LAttachable()->LAttachable::RemoveAllAttachments().	ThrowIfNil_(undoer_p);	AddAttachment(undoer_p);	}#pragma mark --font--//******************************************VOID   C_ND_EFIELD::set_fnum(SInt16	fnum)	//in{	//one needs to do more than just set (**mTextEditH).txFont = fnum;	//Let UTextTraits::SetTETextTraits do the extra stuff.		TextTraitsH    text_traits_h = UTextTraits::LoadTextTraits( node_txt_rid );//not destroyed by PP	//create_h:		PP creates text_traits_h with a call to ::GetResource().	//throwif_h:	PP calls SignalIfNil immediately after creation.	//destroy_h:	PP does NOT release text_traits_h resource.	//				I delete it below, in this method	ThrowIfNil_(text_traits_h);	(**text_traits_h).fontNumber = fnum;	(**text_traits_h).size = (**mTextEditH).txSize;	::HLock((Handle)text_traits_h);//no need to save handle state as will be destroying handle soon	UTextTraits::SetTETextTraits( *text_traits_h, mTextEditH );	ReleaseResource_((Handle)text_traits_h);	UserChangedText();}//******************************************VOID   C_ND_EFIELD::set_fsize(SInt16 fsize)	//in{	//one needs to do more than just set (**mTextEditH).txSize = fsize;	//Let UTextTraits::SetTETextTraits do the extra stuff.		TextTraitsH    text_traits_h = UTextTraits::LoadTextTraits( node_txt_rid );//not destroyed by PP	//create_h:		PP creates text_traits_h with a call to ::GetResource().	//throwif_h:	PP calls SignalIfNil immediately after creation.	//destroy_h:	PP does NOT release text_traits_h resource.	//				I delete it below, in this method.	ThrowIfNil_(text_traits_h);	(**text_traits_h).fontNumber = (**mTextEditH).txFont;	(**text_traits_h).size = fsize;	::HLock((Handle)text_traits_h);//no need to save handle state as will be destroying handle soon	UTextTraits::SetTETextTraits( *text_traits_h, mTextEditH );	ReleaseResource_((Handle)text_traits_h);	UserChangedText();}#pragma mark --about sizes	(const functions)--//******************************************SInt16	C_ND_EFIELD::get_TE_width() const{// this function was inspired by LEditField::AdjustTextWidth()		Point	startPoint = ::TEGetPoint(0, mTextEditH);	Point	endPoint = ::TEGetPoint((**mTextEditH).teLength, mTextEditH);	return endPoint.h - startPoint.h;	}//******************************************VOID	C_ND_EFIELD::calc_state_cap_frame(Rect  &  frame)		//outconst{//The rectangle that is returned will have zero width.//This function is used in NODE::draw_state_cap().	CalcLocalFrameRect(frame);	frame.left = frame.left + (frame.right - frame.left)/2; 	frame.right = frame.left;	SInt16  height = frame.bottom - frame.top;	frame.top = frame.bottom;	frame.bottom = frame.top + height;		}#pragma mark --drawing it--//******************************************VOID  C_ND_EFIELD::UserChangedText(){	SDimension16  	frame_size;	GetFrameSize(frame_size);	SInt16  delta_width = get_TE_width() + 2*left_margin - frame_size.width;	SInt16  delta_height = 2*get_TE_height() - get_TE_ascent() + 2 - frame_size.height;		ResizeFrameBy(delta_width, delta_height, true);	//both refreshes are necessary in case box is shrinking	MoveBy(-delta_width/2, 0, true);}//******************************************VOID	C_ND_EFIELD::DrawBox(){ //drawer//NONTRIVIAL EXCERPT FROM PP	//This method takes out some parts from the 	//method it overrides		// Box around an EditField is outset from the Text by 2 pixels.		// The box itself is 1 pixel thick, drawn in the foreground color		// of the Pane (not necessarily the same as the text color). If		// the EditField is disabled, the box draws with a gray pattern.		//		// The 1 pixel rectangle between the box and the text draws in		// the background color of the text.//	StColorState	saveColors;			// Preserve color state	StCPTstate		saved_st(true, true, false);//diff	// Preserve color and pen state	Rect			frame;	CalcLocalFrameRect(frame);	::PenNormal();			// Draw empty area between Box and Text. On entry, the fore		// and back colors for the Text are in effect (as set in FocusDraw).		// Use Text back color as the fore color for the empty area.		::InsetRect(&frame, 1, 1);	RGBColor	emptyColor;	::GetBackColor(&emptyColor);	::RGBForeColor(&emptyColor);	::FrameRect(&frame);			// Draw border around EditField			::InsetRect(&frame, -1, -1);	//Don't want gray box for disabled case.//	if (mEnabled != triState_On) {		// Disabled EditField has gray border//		::PenPat(&UQDGlobals::GetQDGlobals()->gray);//	}		ApplyForeAndBackColors();	::FrameRect(&frame);	}//******************************************VOID	C_ND_EFIELD::undraw(){//drawer	GetSuperView()->FocusDraw();		Rect	frame;	CalcLocalFrameRect(frame);	//	::EraseRect(&frame); //this works but not as well as what follows	// ref. LEditField::DrawSelf(), LEditField::Drawbox()	StCPTstate		saved_st(true, true, false);	saved_st.Normalize();	::RGBForeColor(&C_COLORS::its_white);			if (mHasBox) {						::FrameRect(&frame);		::InsetRect(&frame, 2, 2);	}	::TEUpdate(&frame, mTextEditH);	}//******************************************VOID	C_ND_EFIELD::EnableSelf(){	//NONTRIVIAL EXCERPT FROM PP	//This method takes out some parts from the 	//method it overrides//	if (mHasBox && FocusExposed()) {//		DrawBox();//	}}//******************************************VOID	C_ND_EFIELD::DisableSelf(){	//NONTRIVIAL EXCERPT FROM PP	//This method takes out some parts from the 	//method it overrides		if (IsOnDuty()) {				// Shouldn't be on duty when disabled		SwitchTarget(GetSuperCommander());	}	//if (mHasBox && FocusExposed()) { 	//	DrawBox(); 	//} 	}#pragma mark --spend time broadcasting--//******************************************VOID	C_ND_EFIELD::SpendTime(const EventRecord	&	inMacEvent )	//in{	LEditField::SpendTime(inMacEvent);	BroadcastMessage(msg_mv_nd_efield, this);}