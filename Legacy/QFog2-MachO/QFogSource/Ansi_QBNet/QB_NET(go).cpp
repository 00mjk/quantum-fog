#include "QB_NET.h"#include "EXCEPTIONS.h"#include "MY_FSTREAMS.h"#include <ctype.h>#include "BEAM_SPL.h"#include "CUSTOM_ND.h"#include "DET_ND.h"#include "POL_ROTATOR.h"#include "POLARIZER.h"#include "QBIT_ROT.h"#include "SG_MAGNET.h"#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	#include "C_MAIN_VIEW.h"#endif //_mac_gui_app \\............................................//#if  _do_debug	extern LONG	req_stack_space;#endif#pragma mark --go_forward() related--//******************************************VOID	QB_NET::set_cum_info_to_default(){	for(USHORT nd=0; nd<its_num_of_nds; nd++){		its_nds_p_p[nd]->set_cum_info_to_default();	} 	DIR_DATA<BI_NODE>  *  dir_bi_nd_p = its_bi_nds.get_first_p();	while(dir_bi_nd_p){		dir_bi_nd_p->its_data.set_cum_info_to_default();		dir_bi_nd_p = dir_bi_nd_p->its_next_p;	}}//******************************************VOID	QB_NET::fill_final_era_degens(VECTOR<USHORT>  &	final_era_degens)		//out{	for(USHORT i = 0; i<its_final_era_len; i++){		USHORT time = i + its_num_of_nds - its_final_era_len;		final_era_degens[i] = its_nds_p_p[its_nd_chronology[time]]->get_degen();	}}//******************************************VOID	QB_NET::set_all_dyn_sts_to_max_ushort(){	for(USHORT i =0; i<its_num_of_nds; i++){		its_nds_p_p[i]->set_dyn_st(max_ushort);	}}//******************************************BOOLEAN 	QB_NET::external_nds_accept_ending(const VECTOR<USHORT>  & ending_vec)		//in{	for(USHORT i = 0; i<its_final_era_len; i++){		USHORT time = i + its_num_of_nds - its_final_era_len;		NODE  *  nd_p = its_nds_p_p[its_nd_chronology[time]];		if(!nd_p->is_active_state(ending_vec[i]))return false;		nd_p->set_dyn_st_and_dir_ele_ptr(ending_vec[i]);	}	return true;}//******************************************BOOLEAN 	QB_NET::dyn_in_st_is_consistent(USHORT nd_id)		//in{	//This method checks for consistency with the its_dyn_st of other nodes, 	//for those nodes that have been assigned one already.	//It also checks for consistency with evidence.	NODE  *   nd_p = its_nds_p_p[nd_id];	for(USHORT i=0; i<nd_p->get_in_nds().get_len(); i++){		NODE  * in_nd_p = its_nds_p_p[nd_p->get_in_nds()[i]];		if(in_nd_p->get_dyn_st()!=max_ushort){			if(in_nd_p->get_dyn_st()!=nd_p->get_dyn_in_st()[i])return false;		}		if(!in_nd_p->is_active_state(nd_p->get_dyn_in_st()[i]))return false;	}	return true;}//******************************************VOID  QB_NET::send_dyn_in_st_to_nds(USHORT nd_id)		//in{	NODE  *   nd_p = its_nds_p_p[nd_id];	for(USHORT i=0; i<nd_p->get_in_nds().get_len(); i++){		NODE  * in_nd_p = its_nds_p_p[nd_p->get_in_nds()[i]];		if(in_nd_p->get_dyn_st()==max_ushort){			in_nd_p->set_dyn_st_and_dir_ele_ptr(nd_p->get_dyn_in_st()[i]);		}	}}//******************************************VOID	QB_NET::use_dyn_in_sts_to_reconstruct_dyn_sts_for_times_larger_than(USHORT limit_time)		//in{	USHORT time;	USHORT  first_time_of_final_era = its_num_of_nds -its_final_era_len;	for(time = 0; time< first_time_of_final_era; time++){		its_nds_p_p[its_nd_chronology[time]]->set_dyn_st(max_ushort);	}	for(time=limit_time + 1; time<its_num_of_nds; time++){		NODE  * nd_p = its_nds_p_p[its_nd_chronology[time]];		for(USHORT i=0; i<nd_p->get_in_nds().get_len(); i++){			NODE  * in_nd_p = its_nds_p_p[nd_p->get_in_nds()[i]];			in_nd_p->set_dyn_st(nd_p->get_dyn_in_st()[i]);		}	}}//******************************************VOID	QB_NET::set_dyn_net_story_and_amp(){	its_dyn_amp = COMPLEX(1, 0);	for(USHORT i=0; i<its_num_of_nds; i++){		its_dyn_story[i] = its_nds_p_p[i]->get_dyn_st();		its_dyn_amp *= its_nds_p_p[i]->get_dyn_amp();	}}//******************************************VOID	QB_NET::add_story_to_cum_amps(){		for(USHORT i=0; i<its_num_of_nds; i++){		its_nds_p_p[i]->add_to_dyn_st_entry_of_cum_amps(its_dyn_amp);	}	USHORT nd1, nd2, nd1_st, nd2_st;	DIR_DATA<BI_NODE>  *  dir_bi_nd_p = its_bi_nds.get_first_p();	while(dir_bi_nd_p){		nd1 = dir_bi_nd_p->its_data.get_nd1();		nd2 = dir_bi_nd_p->its_data.get_nd2();		nd1_st = its_dyn_story[nd1];		nd2_st = its_dyn_story[nd2];		dir_bi_nd_p->its_data.add_to_an_entry_of_cum_amps(nd1_st, nd2_st, its_dyn_amp);		dir_bi_nd_p = dir_bi_nd_p->its_next_p;	}}//******************************************VOID	QB_NET::prepare_cum_info_for_next_ending(){	for(USHORT nd=0;nd<its_num_of_nds; nd++){		its_nds_p_p[nd]->prepare_cum_info_for_next_ending();	} 	DIR_DATA<BI_NODE>  *  dir_bi_nd_p = its_bi_nds.get_first_p();	while(dir_bi_nd_p){		dir_bi_nd_p->its_data.prepare_cum_info_for_next_ending();		dir_bi_nd_p = dir_bi_nd_p->its_next_p;	}}//******************************************VOID	QB_NET::normalize_cum_probs(){	for(USHORT nd=0;nd<its_num_of_nds; nd++){		its_nds_p_p[nd]->normalize_cum_probs();	}	DIR_DATA<BI_NODE>  *  dir_bi_nd_p = its_bi_nds.get_first_p();	while(dir_bi_nd_p){		dir_bi_nd_p->its_data.normalize_cum_probs();		dir_bi_nd_p = dir_bi_nd_p->its_next_p;	}}//******************************************VOID	QB_NET::add_story_to_anthology(USHORT ending)		//in{ // net_story_count and ending are both one based.// This function does nothing for ansi_app.#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	C_ANTHOLOGY_ITEM   item( its_dyn_story, its_dyn_amp, ending);	its_anthology.insert_last(item);#endif //_mac_gui_app \\............................................//	refresh_req_stack_space_();}//******************************************VOID	QB_NET::multi_mode_go(BOOLEAN				is_mini_run,				//in				//go forward variablesconst CHAR  * 		ecase_name_cstr,			//inMY_OFSTREAM  * 		nd_probs_stream_p,			//i-oMY_OFSTREAM  *  	bi_nd_probs_stream_p,		//i-oMY_OFSTREAM  * 		stories_stream_p,			//i-o BOOLEAN  			illustrate_stories, 			//in//mini_run variablesDOUBLE  &	out_prob,							//outUSHORT	&	num_of_stories)						//out		{		if(its_num_of_nds==0)return;		//go_forward variables	USHORT net_story_ctr = 1;	USHORT happy_ending = 1;	USHORT prev_ending = max_ushort;	USHORT extra_story_steps = illustrate_stories||(stories_stream_p!=0);	//mini_run variables	DOUBLE 		cum_prob = 0;	COMPLEX 	cum_amp = 0;		if(!is_mini_run){//go_forward		if(stories_stream_p!=0){				*stories_stream_p				<< "**********ecase = " 				<< ecase_name_cstr				<<my_endline;		}		// next 2 steps absolutely necessary if more than one evidence case		set_cum_info_to_default();#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.			its_anthology.clear();#endif //_mac_gui_app \\............................................//	}else{//mini_run		preserve_act_st_sets_of_all_nds();		fill_act_st_sets_of_all_nds();	}			VECTOR<USHORT>  final_era_degens(0, its_final_era_len);	fill_final_era_degens(final_era_degens);	STRETCH_OR_FOLD  endings_sof(final_era_degens);	USHORT 			nd_id;	NODE  * 		nd_p;	for(USHORT ending=0; ending<endings_sof.get_num_of_vecs(); ending++){		//"ending" labels stories of the final era. 		//It is zero based and may include impossible endings.		set_all_dyn_sts_to_max_ushort();		//at the beginnig and end of each "ending", all dir_ele pointers point to first row		if(!external_nds_accept_ending(endings_sof.vec_label(ending))) goto next_ending;		BOOLEAN 		need_to_reconstruct = false;		USHORT time = its_num_of_nds - 1;		while(time != its_num_of_nds){			if(time != 0){				nd_id = its_nd_chronology[time];				nd_p = its_nds_p_p[nd_id];				if(nd_p->has_dyn_in_st()){					if(need_to_reconstruct){						use_dyn_in_sts_to_reconstruct_dyn_sts_for_times_larger_than(time);						need_to_reconstruct = false;					}											if(dyn_in_st_is_consistent(nd_id) ){						send_dyn_in_st_to_nds(nd_id);						time--;						}else{						nd_p->advance_dyn_dir_ele_ptr();					}					}else{					nd_p->move_dyn_dir_ele_ptr_to_first_col();					if(time!=its_num_of_nds-1){						its_nds_p_p[its_nd_chronology[time + 1]]->advance_dyn_dir_ele_ptr();						need_to_reconstruct = true;					}					time++;				}			}else{  // if time ==0				nd_id = its_nd_chronology[0];				nd_p = its_nds_p_p[nd_id];						if(nd_p->has_dyn_in_st()){					if(dyn_in_st_is_consistent(nd_id) ){						set_dyn_net_story_and_amp();						if(!is_mini_run){//go_forward							add_story_to_cum_amps();							if(extra_story_steps){								// Not all endings make it to here,								// so we number the possible endings with the counter happy_ending.								// happy_ending is 1 based.								if(prev_ending!=ending){									if(prev_ending!=max_ushort)happy_ending++;									prev_ending= ending;								}								if(illustrate_stories){									add_story_to_anthology(happy_ending); 								}								if(stories_stream_p!=0){									write_one_story_into_file(stories_stream_p, net_story_ctr, happy_ending);								}								net_story_ctr++;							}													}else{//mini_run							cum_amp += its_dyn_amp;							net_story_ctr++;						}						nd_p->advance_dyn_dir_ele_ptr();					}else{						nd_p->advance_dyn_dir_ele_ptr();					}				}else{					if(its_num_of_nds!=1){						nd_p->move_dyn_dir_ele_ptr_to_first_col();						its_nds_p_p[its_nd_chronology[1]]->advance_dyn_dir_ele_ptr();						use_dyn_in_sts_to_reconstruct_dyn_sts_for_times_larger_than(1);					}					time++;				}			}			refresh_req_stack_space_();		}//times		if(!is_mini_run){//go_forward			prepare_cum_info_for_next_ending();				}else{//mini_run			//norm = modulus**2 = abs**2 = real**2 + imag**2			cum_prob += norm(cum_amp);			cum_amp = 0;		}		next_ending: ;		refresh_req_stack_space_();	}//endings	num_of_stories = net_story_ctr - 1; //net_story_ctr starts at 1 so this is always >=0	if(!is_mini_run){//go_forward		normalize_cum_probs();		if(nd_probs_stream_p!=0){			write_nd_probs_into_file(ecase_name_cstr, nd_probs_stream_p );		}		if(bi_nd_probs_stream_p!=0){			write_bi_nd_probs_into_file( ecase_name_cstr, bi_nd_probs_stream_p );		}	}else{//mini_run		restore_act_st_sets_of_all_nds();		out_prob = cum_prob;	}		refresh_req_stack_space_();}//******************************************VOID	QB_NET::go_forward(const CHAR  * 		ecase_name_cstr,			//inMY_OFSTREAM  * 		nd_probs_stream_p,			//i-oMY_OFSTREAM  *  	bi_nd_probs_stream_p,		//i-oMY_OFSTREAM  * 		stories_stream_p,			//i-o BOOLEAN  			illustrate_stories ) 			//in{	DOUBLE	out_prob=0;	USHORT	num_of_stories=0;	multi_mode_go(		false,//is_mini_run		ecase_name_cstr,		nd_probs_stream_p,		bi_nd_probs_stream_p,		stories_stream_p, 		illustrate_stories,		out_prob,		num_of_stories);}		