#include "QB_NET.h"#include "EXCEPTIONS.h"#include "MY_FSTREAMS.h"#include <ctype.h>#include "BEAM_SPL.h"#include "CUSTOM_ND.h"#include "DET_ND.h"#include "POL_ROTATOR.h"#include "POLARIZER.h"#include "QBIT_ROT.h"#include "SG_MAGNET.h"#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	#include "C_MAIN_VIEW.h"#endif //_mac_gui_app \\............................................//#pragma mark --creation/destruction--//******************************************VOID  QB_NET::clear_nds(){	for(USHORT i=0; i<its_num_of_nds;i++){		delete its_nds_p_p[i];		its_nds_p_p[i] = 0;	}	delete [] its_nds_p_p;	its_nds_p_p = 0;}//******************************************VOID  QB_NET::clear(){	clear_nds();	its_num_of_nd_ptrs=0;	its_num_of_nds=0;}//******************************************VOID  QB_NET::init(){//stress the debug version#if	_do_debug	its_num_of_nd_ptrs=2;#else	its_num_of_nd_ptrs=32;#endif	its_num_of_nds=0;	its_nd_names_p_p=0;	its_nd_name_dict_p=0;	its_nds_p_p = new NODE  * [its_num_of_nd_ptrs];//new[]	//delete:	in QB_NET::clear_nds().	ThrowIfNil_(its_nds_p_p);	for(USHORT i=0; i<its_num_of_nd_ptrs; i++){		its_nds_p_p[i]=0;		//So far not creating any memory for each its_nds_p_p[i].		//Will do this in add_nd() or mac_add_nd();	}}		//******************************************QB_NET::QB_NET(){	init();} //******************************************QB_NET::~QB_NET(){		clear();}#pragma mark --node names--//******************************************USHORT  QB_NET::get_len_of_longest_nd_name(){	USHORT max = 0;	USHORT len;	for(USHORT i = 0;  i<its_num_of_nds; i++){		len = its_nds_p_p[i]->get_name().get_len();		if(len>max) max = len;	}	return max;}#pragma mark --state names--//******************************************USHORT  QB_NET::get_len_of_longest_st_name(USHORT nd_id)		//in{	USHORT max = 0;	USHORT len;	NODE  * 	nd_p = its_nds_p_p[nd_id];	for(USHORT i = 0; i< nd_p->get_degen(); i++){		len = nd_p->get_st_name(i).get_len();		if(len>max) max = len;	}	return max;}#pragma mark --small amps--	//******************************************const USHORT	QB_NET::get_cur_finesse_of_amps()const{	USHORT	prec, max_prec=0;	for(USHORT i=0; i<its_num_of_nds; i++){		prec = its_nds_p_p[i]->get_tm_amps().get_cur_finesse_of_amps();		if(prec > max_prec) max_prec = prec;	}	return max_prec;}//******************************************VOID	QB_NET::filter_out_small_amps(USHORT	finesse )		//in{	for(USHORT i=0; i<its_num_of_nds; i++){		its_nds_p_p[i]->get_tm_amps().filter_out_small_amps( finesse );	}}#pragma mark --active states--//******************************************VOID  QB_NET::empty_act_st_sets_of_all_nds(){	for(USHORT nd=0;nd<its_num_of_nds;nd++){		its_nds_p_p[nd]->empty_act_st_set();	}}//******************************************VOID  QB_NET::fill_act_st_sets_of_all_nds(){	for(USHORT nd=0;nd<its_num_of_nds;nd++){		its_nds_p_p[nd]->fill_act_st_set();	}}//******************************************VOID 	QB_NET::preserve_act_st_sets_of_all_nds(){	for(USHORT i=0;i<its_num_of_nds;i++){		its_nds_p_p[i]->preserve_act_st_set();	}}//******************************************VOID 	QB_NET::restore_act_st_sets_of_all_nds(){	for(USHORT i=0;i<its_num_of_nds;i++){		its_nds_p_p[i]->restore_act_st_set();	}}#pragma mark --add nodes and arrows--//******************************************BOOLEAN 	QB_NET::sort_into_layers_of_external_nds(VECTOR<USHORT>  &  era_of,		//outUSHORT  & 	num_of_eras)		//out{	//Returns true(1) if can sort (no cycles), false(0) if can't.	//We won't be grouping nodes into eras of this type.	//This function will never be used. It's just presented for completeness. 	if(its_num_of_nds==0){		num_of_eras=0;		return true;	}	VECTOR<USHORT> out_degrees(0, its_num_of_nds);	USHORT i;	for(i=0; i<its_num_of_nds;i++){				out_degrees[i]=  its_nds_p_p[i]->get_out_nds().get_len();	}		VECTOR<USHORT> rel_era_of(0, its_num_of_nds);			L_LIST<USHORT> queue;	for(i=0; i<its_num_of_nds;i++){				if(out_degrees[i]==0){			queue.insert_last(i);			//Eras start at 0 and end at its_num_of_eras-1.			//At this point, we don't know how many eras there will be,			//so we temporarily translate era ids so that last one is max_ushort.			rel_era_of[i]=max_ushort;  		}	}		USHORT  nd_counter=0;	USHORT	x, pre_x;	USHORT	last_x_considered = 0;	VECTOR<USHORT>  nds_entering_x;		while( queue.extract_first(x) ){ 		// i.e., loop continues while there are nodes left in the queue		nd_counter++;		nds_entering_x =  its_nds_p_p[x]->get_in_nds();		for(i= 0; i<nds_entering_x.get_len(); i++){			pre_x = nds_entering_x[i];			--out_degrees[pre_x];			if(out_degrees[pre_x]==0){				queue.insert_last(pre_x);				rel_era_of[pre_x] = rel_era_of[x] - 1;			}		}		last_x_considered = x;	}	if(nd_counter!=its_num_of_nds) return false;	//if they are not equal, then we have a cycle.	USHORT smallest_rel_era= rel_era_of[last_x_considered];	//parenthesis important because dealing with ushorts:	num_of_eras = (max_ushort -  smallest_rel_era) + 1;	for(i=0;i<its_num_of_nds;i++){		era_of[i] = rel_era_of[i] - smallest_rel_era;	}	return true;}/*the following function doesn't detect cycles correctly in all cases//******************************************USHORT  QB_NET::sort_into_layers_of_parents(VECTOR<USHORT>  &  era_of,		//outUSHORT  & 	num_of_eras)		//out{	//Returns true if can sort (iff no cycles), false if can't.	if(its_num_of_nds==0){		num_of_eras=0;		return true;	}	VECTOR<USHORT> rel_era_of(0, its_num_of_nds);	SHORT 	num_of_zero_comps = its_num_of_nds;	USHORT	i;	USHORT	cur_era_size = 0;	for(i=0; i<its_num_of_nds;i++){				if(its_nds_p_p[i]->get_out_nds().get_len()==0){			//Eras start at 0 and end at num_of_eras-1.			//At this point, we don't know how many eras there will be,			//so we temporarily translate era ids so that last one is max_ushort.			rel_era_of[i]=max_ushort;			num_of_zero_comps--;			cur_era_size++;  		}	}		if(cur_era_size==0)return false; //pure cycle			USHORT	cur_rel_era=max_ushort;	NODE  * nd_p;	while(num_of_zero_comps!=-1){		//For cycle detection, its important to go through loop once for root nodes		//i.e., once with num_of_zero_comps == 0 		if(num_of_zero_comps==0){			num_of_zero_comps=-1;		}		if(cur_era_size==0)return false;			cur_era_size = 0;		for(i=0; i<its_num_of_nds; i++){			nd_p = its_nds_p_p[i];			if(rel_era_of[i]==cur_rel_era){				for(USHORT j=0; j<nd_p->get_in_nds().get_len(); j++){					USHORT	in_nd = nd_p->get_in_nds()[j];					if(rel_era_of[in_nd]>cur_rel_era){						return false;//can't sort, a cycle is present					} else if (rel_era_of[in_nd]==cur_rel_era){						//Do nothing.						//If the node has already been assigned to the era  cur_rel_era,						//don't assign it to the era cur_rel_era-1.						//This takes care of era self-interaction						//i.e., arrows connecting nodes in the same era.					}else if(rel_era_of[in_nd]==0){						rel_era_of[in_nd]=cur_rel_era-1;						num_of_zero_comps--;						cur_era_size++;					}				}	 			}		}			cur_rel_era--;	}	//the smallest era ever assigned is:	USHORT smallest_rel_era = (cur_rel_era==max_ushort? max_ushort:cur_rel_era+1);	//parenthesis important because dealing with ushorts:	num_of_eras = (max_ushort -  smallest_rel_era) + 1;	for(i=0;i<its_num_of_nds;i++){		era_of[i] = rel_era_of[i] - smallest_rel_era;	}	return true;}*///******************************************BOOLEAN 	QB_NET::chrono_sort(){	VECTOR<USHORT> 	era_of(0, its_num_of_nds);	USHORT	num_of_eras;		if(!sort_into_layers_of_external_nds(era_of, num_of_eras))return false;	its_nd_chronology.set_to_default_vec(0, its_num_of_nds);	its_final_era_len = 0;	USHORT time=0;	for(USHORT e=0; e<num_of_eras; e++){		for(USHORT nd=0; nd<its_num_of_nds; nd++){			if(era_of[nd]==e){				its_nd_chronology[time]=nd;				time++;				if(e==(num_of_eras-1)){					its_final_era_len++;				}			}		}	}	return true; // This return value signals that there are no cycles.	}//******************************************VOID	QB_NET::grow_num_of_nd_ptrs(){	//See QB_NET::init() 	//We started with 32 node pointers (2 in the debug version).	//Double num of pointers each time we grow.	its_num_of_nd_ptrs  *=  2;	NODE  *  * 		x_p_p = new NODE  * [its_num_of_nd_ptrs];//new[]	//delete:	substitution of delete-new pair	ThrowIfNil_(x_p_p);	USHORT i;	for(i=0; i<its_num_of_nds; i++){		x_p_p[i] = its_nds_p_p[i];	}	for(i=its_num_of_nds; i<its_num_of_nd_ptrs ; i++){		x_p_p[i] = 0;	}	delete [] its_nds_p_p;	its_nds_p_p = x_p_p;}	//******************************************VOID	QB_NET::warn_user_about_cycle(){	my_gen_alert("Your last arrow is inadmissible because it would create a cycle in the graph.");#ifdef   _ansi_app //''''''''''''''''''''''''''''''''''''''''''''\\.		exit(1);#endif //_ansi_app \\............................................//}//******************************************BOOLEAN 	QB_NET::add_int_arrow(USHORT s,					//inUSHORT d,					//inBOOLEAN		try_to_sort)	//in{	//used only by ansi app. See mac_add_int_arrow().	NODE  *  s_p = its_nds_p_p[s];	NODE  *  d_p = its_nds_p_p[d];	s_p->add_out_nd(d);	d_p->add_in_nd(s, s_p->get_degen());	if(try_to_sort){ 		if(!chrono_sort() ){	 		warn_user_about_cycle();			return false;		}	}	return true;	}//******************************************USHORT  QB_NET::add_nd(const STRINGY  & nd_class_str,		//inBOOLEAN try_to_sort)			//in{// used only by ansi_app. See mac_add_nd().	if( its_num_of_nds == its_num_of_nd_ptrs )   grow_num_of_nd_ptrs();	its_num_of_nds++;		NODE  * 	nd_p=0;  	if(nd_class_str=="BEAM_SPL"){		nd_p = new BEAM_SPL();		//delete:	in QB_NET::clear_nds().	}else if(nd_class_str=="CUSTOM_ND"){		nd_p = new CUSTOM_ND();				//delete:	in QB_NET::clear_nds().	}else if(nd_class_str=="DET_ND"){		nd_p = new DET_ND();		//delete:	in QB_NET::clear_nds().	}else if(nd_class_str=="POL_ROTATOR"){		nd_p = new POL_ROTATOR();		//delete:	in QB_NET::clear_nds().	}else if(nd_class_str=="POLARIZER"){		nd_p = new POLARIZER();		//delete:	in QB_NET::clear_nds().	}else if(nd_class_str=="QBIT_ROT"){		nd_p = new QBIT_ROT();		//delete:	in QB_NET::clear_nds().	}else if(nd_class_str=="SG_MAGNET"){		nd_p = new SG_MAGNET();		//delete:	in QB_NET::clear_nds().	}	ThrowIfNil_(nd_p);	its_nds_p_p[its_num_of_nds-1] = nd_p;	if(try_to_sort){		chrono_sort();		its_dyn_story.set_to_default_vec(0, its_num_of_nds);	}	return its_num_of_nds-1; // the returned number will become the node id.//// IMPORTANT: the return value was off by one!!!!!}#pragma mark --degen--//******************************************VOID	QB_NET::set_degen_of_a_nd(USHORT nd_id,		//inUSHORT degen)		//in{	NODE  *  nd_p = its_nds_p_p[nd_id];		//this is important because don't want to empty trans mat 	//of out nds unless it's necessary	if(nd_p->get_degen()==degen || degen==0)return;	nd_p->set_degen(degen);	VECTOR<USHORT>  out_nds = nd_p->get_out_nds();	for(USHORT i= 0; i< out_nds.get_len(); i++){		its_nds_p_p[out_nds[i]]->set_in_nd_degen(nd_id, degen);	}	USHORT nd1, nd2, degen1, degen2;	BI_NODE  *  bi_nd_p;	DIR_DATA<BI_NODE>  *  dir_bi_nd_p = its_bi_nds.get_first_p();	while(dir_bi_nd_p){		bi_nd_p = &(dir_bi_nd_p->its_data);		nd1 = bi_nd_p->get_nd1();		nd2 = bi_nd_p->get_nd2();		if(nd_id==nd1 || nd_id==nd2){			degen1 = its_nds_p_p[nd1]->get_degen();			degen2 = its_nds_p_p[nd2]->get_degen();			bi_nd_p->set_degens(degen1, degen2);		}		dir_bi_nd_p = dir_bi_nd_p->its_next_p;	}}//******************************************USHORT	QB_NET::get_max_degen(){	USHORT candidate, max=0;	for(USHORT nd=0; nd<its_num_of_nds;nd++){		candidate = its_nds_p_p[nd]->get_degen();		max = ( (max>candidate)? max:candidate );	}	return max;}#pragma mark --bi-nodes--//******************************************STRINGY		QB_NET::get_bi_nd_name(USHORT	loc)		//in{	BI_NODE  *	bi_nd_p = &(its_bi_nds[loc]);	USHORT		nd1 = bi_nd_p->get_nd1();	STRINGY 	namey1 = its_nds_p_p[nd1]->get_name();	USHORT		nd2 = bi_nd_p->get_nd2();	STRINGY 	namey2 = its_nds_p_p[nd2]->get_name();	//need two \s because first \ signals to take second \ literally	STRINGY		namey = namey1  && " \\ " && namey2;	return namey;}//******************************************VOID	QB_NET::get_bi_nd(USHORT loc,			//inUSHORT  & nd1,		//outUSHORT  & nd2)		//out{//loc is input and nd1, nd2 are outputs	nd1 = its_bi_nds[loc].get_nd1();	nd2 = its_bi_nds[loc].get_nd2();}//******************************************BOOLEAN		QB_NET::add_bi_nd(USHORT nd1,		//inUSHORT nd2)		//in{	//This function checks to see if 	//(1)the bi-node has been added before,	//(2)the bi_node is degenerate (i.e., nd1==nd2)	//If either (1) or (2) are true, the function returns "false" and flashes an alert message.	//Otherwise, the function  returns "true", creates a new bi-node,  and inserts	//it into the net's list of bi-nodes.	if(nd1==nd2){		warn_user_about_degenerate_bi_nd();		return false;	}	BI_NODE  * 	bi_nd_p;	DIR_DATA<BI_NODE>  *  dir_bi_nd_p = its_bi_nds.get_first_p();	while(dir_bi_nd_p!=0){		bi_nd_p = &(dir_bi_nd_p->its_data);		if(bi_nd_p->has(nd1, nd2)){			warn_user_about_repeated_bi_nd();			return false;		}		dir_bi_nd_p = dir_bi_nd_p->its_next_p;	}	USHORT 	degen1 = its_nds_p_p[nd1]->get_degen();	USHORT 	degen2 = its_nds_p_p[nd2]->get_degen();	BI_NODE   new_bi_nd(nd1, degen1, nd2, degen2);	its_bi_nds.insert_last(new_bi_nd);	return true;}//******************************************VOID	QB_NET::warn_user_about_degenerate_bi_nd(){	my_gen_alert("Your last node choice is inadmissible because the two nodes of a bi-node must be different.");#ifdef   _ansi_app //''''''''''''''''''''''''''''''''''''''''''''\\.		exit(1);#endif //_ansi_app \\............................................//}//******************************************VOID	QB_NET::warn_user_about_repeated_bi_nd(){	my_gen_alert("Your last node choice is inadmissible because it would add to the list a bi-node that is already listed.");#ifdef   _ansi_app //''''''''''''''''''''''''''''''''''''''''''''\\.		exit(1);#endif //_ansi_app \\............................................//}#pragma mark --dictionaries--//******************************************VOID	QB_NET::create_nd_name_dictionary(){	if(its_num_of_nds==0)return;	//check that it doesn't already exist	if(its_nd_name_dict_p==0){		its_nd_names_p_p =  new const STRINGY  * [its_num_of_nds];//new[]		//delete:	in QB_NET::kill_nd_name_dictionary().		ThrowIfNil_(its_nd_names_p_p);		for(USHORT i=0; i< its_num_of_nds; i++){			its_nd_names_p_p[i] = &get_nd_name(i);		}				its_nd_name_dict_p = new DICTIONARY(its_nd_names_p_p, its_num_of_nds );		//delete:	in QB_NET::kill_nd_name_dictionary().		ThrowIfNil_(its_nd_name_dict_p);	}else{		its_nd_name_dict_p->add_one_user();	}}//******************************************VOID 	 QB_NET::create_nd_st_dictionaries(){ 	for(USHORT i=0; i< its_num_of_nds;i++){		its_nds_p_p[i]->create_dict();	} }//******************************************VOID 	QB_NET::create_dictionaries(){	create_nd_name_dictionary();		create_nd_st_dictionaries();}//******************************************VOID 	QB_NET::kill_nd_name_dictionary(){	if(its_nd_name_dict_p->get_num_of_users()<=1){		delete [] its_nd_names_p_p;		its_nd_names_p_p = 0;		delete its_nd_name_dict_p;		its_nd_name_dict_p = 0;	}else{		its_nd_name_dict_p->del_one_user();	}}//******************************************VOID 	 QB_NET::kill_nd_st_dictionaries(){ 	for(USHORT i=0; i< its_num_of_nds;i++){		its_nds_p_p[i]->kill_dict();	} }//******************************************VOID 	 QB_NET::kill_dictionaries(){	kill_nd_name_dictionary();		kill_nd_st_dictionaries();}#pragma mark --import from TEXT files--//******************************************VOID	QB_NET::read_topology_file(MY_IFSTREAM  & istream)		//i-o{	istream.ignore(500, my_endline);	USHORT 	num_of_nds;	istream>> num_of_nds;//		istream.ignore(500, my_endline);istream.ignore(500, my_endline);  	STRINGY nd_name, nd_class_str; 	USHORT nd_id, i;	for(i=0;i<num_of_nds;i++){		istream>> nd_id>> nd_name >> nd_class_str;		add_nd(nd_class_str, false);		set_nd_name(nd_id, nd_name);	}//		istream.ignore(500, my_endline);istream.ignore(500, my_endline);	USHORT num_of_arrows;	istream>> num_of_arrows;//		istream.ignore(500, my_endline);istream.ignore(500, my_endline);	USHORT source, dest;		for(i=0;i<num_of_arrows;i++){		istream>> source >> dest;		add_int_arrow(source, dest, false);	}	chrono_sort();	its_dyn_story.set_to_default_vec(0, its_num_of_nds);//		istream.ignore(500, my_endline);istream.ignore(500, my_endline);	USHORT num_of_bi_nds;	istream>> num_of_bi_nds;  //	istream.ignore(500, my_endline);istream.ignore(500, my_endline);	USHORT nd1, nd2;	for(i=0;i<num_of_bi_nds;i++){		istream>>nd1>>nd2;	 	add_bi_nd(nd1, nd2);	 }}//******************************************BOOLEAN		QB_NET::good_nd_sts_file(MY_IFSTREAM  & istream)			//i-o{	STRINGY 	nd_name, st_name;	USHORT 		nd_id, degen;	USHORT 		nd_counter = 0;	CHAR 		ch ;	BOOLEAN 	file_is_ok = true;	//this function assumes that a node name dictionary is currently available	//bad = fatal error	//fail = fatal or not fatal error	//IMP: Do use exceptions(failbit) because 	//it alerts you to cases such as if x is an int and 	//cin>>x fails because cin doesn't have an int next.	//IMP: (istream >> name) will set eof()=true	//if there is no visible or invisible(like \n) character after name.	//Therefore, try to test name immediately after	//(istream >> name), and before you call my_get() again.	//IMP: Do not use exceptions(eofbit) or else	//for example, in	//			istream>>st_name;	//			if(!st_name.is_legal_name())throw ILLEGAL_NAME(st_name);	//>> may throw before I test st_name.is_legal_name()	//IMP: A very important stress test for this and 	//all other methods that read text files is to delete the last invisible	//character of the file and to make the last thing read illegal.	//For example, if the file should end with a double,	//replace the double by	//(1)1a  (with no invisible after 1a)	//(2)1a\n	//(3)1  (with no invisible after 1)	//(4)1\n				istream.exceptions(ios::badbit | ios::failbit);	//RP = reading position	try{		//skip header:		ch = my_endline;		while( ch!='#' ){ istream.my_get(ch); }		//AT THIS POINT, RP = ch = #		while(ch =='#'){			istream>>nd_name>>degen;			nd_counter++;			nd_id = its_nd_name_dict_p->get_id_of_this_stringy(nd_name);			if(nd_id==max_ushort) throw UNLISTED_NODE(nd_name);			if(degen==0)throw ZERO_DEGEN(nd_name);			for(USHORT r=0; r<degen; r++){				istream>>st_name;				if(!st_name.is_legal_name())throw ILLEGAL_NAME(st_name);			}			//AT THIS POINT, RP is on last character of st_name			istream.my_get(ch);			//AT THIS POINT, RP = ch = first character after st_name				//go to #:			while(ch!='#'){				//isspace includes \r, \n, \t, space bar				if( !isspace(ch) )throw WRONG_PATTERN();				istream.my_get(ch);			}			//AT THIS POINT, RP = ch = #		}	}	catch(END_OF_FILE){}	catch(const IO_EXCEPTION  &  exc){		exc.print_error("with names of node states", istream.cur_line() );		file_is_ok = false;#ifdef   _ansi_app //''''''''''''''''''''''''''''''''''''''''''''\\.			exit(1);#endif //_ansi_app \\............................................//	}	//The class failure is defined INSIDE the class ios so	//one must use "ios::failure" to access it.	catch(const ios::failure  &  io_exc){		//STRINGY   stringy = io_exc.what();//pretty useless		my_gen_alert(			STRINGY("Bad Input: Check file ")			&& "with names of node states"			&& ", line "			&& istream.cur_line()			&& ". " 		);		file_is_ok = false;#ifdef   _ansi_app //''''''''''''''''''''''''''''''''''''''''''''\\.			exit(1);#endif //_ansi_app \\............................................//	}#ifdef   _ansi_app //''''''''''''''''''''''''''''''''''''''''''''\\.		//In ansi-app case, exit if the list is partial		if(nd_counter!=its_num_of_nds){			cerr << "You forgot some nodes in your list of names of node states."; 			exit(1);		}#endif //_ansi_app \\............................................//	//stops istream from throwing any more exceptions 	istream.exceptions(ios::goodbit);	//rewinds istream.	//istream.seekg_(0, ios::beg); // dpo 	istream.seekg_(0, ios::in); 	// clears eof bit flag	istream.clear();	return  file_is_ok;		 }//******************************************BOOLEAN		QB_NET::read_nd_sts_file(MY_IFSTREAM  & istream)		//i-o{	STRINGY 	nd_name, st_name;	USHORT 		nd_id, degen;	USHORT 		nd_counter = 0;	CHAR 		ch;	//this function assumes that a node name dictionary is currently available	if(!good_nd_sts_file(istream)){		return false;	}	try{		ch = my_endline;		while( ch!='#' ){ istream.my_get(ch); }		while(ch =='#'){			istream>>nd_name>>degen;			nd_counter++;			nd_id = its_nd_name_dict_p->get_id_of_this_stringy(nd_name);			set_degen_of_a_nd(nd_id, degen);			for(USHORT r=0; r<degen; r++){				istream>>st_name;				set_state_name(nd_id, r, st_name);			}			istream.my_get(ch);			while(ch!='#'){istream.my_get(ch);}		}	}	catch(END_OF_FILE){}	return true; }//******************************************BOOLEAN		QB_NET::good_amps_file(MY_IFSTREAM  &  istream)		//i-o{	CHAR  ch;	USHORT in_nd_loc;	USHORT nd_id, in_nd_id, in_nd_st_id, nd_st_id;	STRINGY nd_name, in_nd_name, in_nd_st_name, nd_st_name;	DOUBLE x, y;	NODE  *  nd_p;	VECTOR<USHORT> in_st_vec;	TM_COL_NUM	in_st;	Boolean 	more_in_sts;	//this function assumes that node and nd_st dictionaries are available!!	BOOLEAN 	file_is_ok = true;	istream.exceptions(ios::badbit | ios::failbit);	//RP = reading position	try{		//skip header:		ch = my_endline;		while( ch!='#' ){ istream.my_get(ch); }		//AT THIS POINT, RP = ch = #		while(ch =='#'){			istream >> nd_name;			nd_id = its_nd_name_dict_p->get_id_of_this_stringy(nd_name);			if(nd_id==max_ushort)throw UNLISTED_NODE(nd_name);			nd_p= its_nds_p_p[nd_id];			if(nd_p->get_num_of_in_nds()==0){ //deal with root nodes				for(USHORT s=0; s<nd_p->get_degen(); s++){					istream>> nd_st_name>> x>> y;					nd_st_id = nd_p->get_dict().get_id_of_this_stringy(nd_st_name);					if(nd_st_id==max_ushort)throw UNLISTED_STATE(nd_name, nd_st_name);					//if(norm(COMPLEX(x, y))>1)throw ILLEGAL_AMP(x, y);					//norm = abs**2								}				//AT THIS POINT, RP is on last character of y				istream.my_get(ch);				//AT THIS POINT, RP = ch = first character after y					//go to #:				while(ch!='#'){					if( !isspace(ch) )throw WRONG_PATTERN();					istream.my_get(ch);				}				//AT THIS POINT, RP = ch = #			}else{				in_st_vec.set_to_default_vec(0, nd_p->get_num_of_in_nds());				more_in_sts=true;											while(more_in_sts){					for(USHORT r=0; r<nd_p->get_num_of_in_nds(); r++){						istream >> in_nd_name>>in_nd_st_name;						in_nd_id = its_nd_name_dict_p->get_id_of_this_stringy(in_nd_name);						if(in_nd_id==max_ushort)throw UNLISTED_NODE(in_nd_name);												in_nd_loc = nd_p->get_in_nds().loc_of_target(in_nd_id);											if(in_nd_loc==max_ushort)throw UNLISTED_IN_NODE(nd_name, in_nd_name);												in_nd_st_id = its_nds_p_p[in_nd_id]->get_dict().get_id_of_this_stringy(in_nd_st_name);						if(in_nd_st_id==max_ushort)throw UNLISTED_STATE(in_nd_name, in_nd_st_name);												in_st_vec[in_nd_loc]=in_nd_st_id;					}					in_st = nd_p->get_in_nd_sof().int_label(in_st_vec);					for(USHORT s=0; s<nd_p->get_degen(); s++){						istream>> nd_st_name>> x>> y;						nd_st_id = nd_p->get_dict().get_id_of_this_stringy(nd_st_name);										if(nd_st_id==max_ushort)throw UNLISTED_STATE(nd_name, nd_st_name);						//if(norm(COMPLEX(x, y))>1)throw ILLEGAL_AMP(x, y);					}						//AT THIS POINT, RP is on last character of y					istream.my_get(ch);					//AT THIS POINT, RP = ch = first character after y						//go to end of line:					while(ch!=my_endline){						if( !isspace(ch) )throw WRONG_PATTERN();						istream.my_get(ch);					}					//AT THIS POINT, RP = ch = my_endline					//file may end before this reaches a non-blank space:					while(isspace(ch)){istream.my_get(ch);}					//AT THIS POINT, RP = ch = first non-white ch after last my_endline.					if(ch=='#'){						more_in_sts = false;					}else{						more_in_sts = true;						istream.putback(ch);					}				}//end of loop over in_sts			}//endif  (root node or not)			//AT THIS POINT, RP = ch = #		}//end of loop over nodes	}//end of try{}		catch(END_OF_FILE){}	catch(const IO_EXCEPTION  &  exc){		exc.print_error("with amplitudes", istream.cur_line());		file_is_ok = false;#ifdef   _ansi_app //''''''''''''''''''''''''''''''''''''''''''''\\.			exit(1);#endif //_ansi_app \\............................................//	}	//The class failure is defined INSIDE the class ios so	//one must use "ios::failure" to access it.	catch(const ios::failure  &  io_exc){		//STRINGY   stringy = io_exc.what();//pretty useless		my_gen_alert(			STRINGY("Bad Input: Check file ")			&& "with amplitudes"			&& ", line "			&& istream.cur_line()			&& ". " 		);		file_is_ok = false;#ifdef   _ansi_app //''''''''''''''''''''''''''''''''''''''''''''\\.			exit(1);#endif //_ansi_app \\............................................//	}	//stops istream from throwing any more exceptions 	istream.exceptions(ios::goodbit);	//rewinds istream. 	//istream.seekg_(0, ios::beg); //dpo	istream.seekg_(0, ios::in); 	// clears eof bit flag	istream.clear();	return  file_is_ok;		}//******************************************BOOLEAN		QB_NET::read_amps_file(MY_IFSTREAM  &  istream)		//i-o{	CHAR  ch;	USHORT in_nd_loc;	USHORT nd_id, in_nd_id, in_nd_st_id, nd_st_id;	STRINGY nd_name, in_nd_name, in_nd_st_name, nd_st_name;	DOUBLE x, y;	NODE  *  nd_p;	VECTOR<USHORT> in_st_vec;	Boolean 	more_in_sts;	TM_COL_NUM	in_st;	//this function assumes that node and nd_st dictionaries are available!!	if( !good_amps_file(istream) ){			return false;	}		try{		ch = my_endline;		while(ch!='#'){ istream.my_get(ch); }		while(ch =='#'){			istream >> nd_name;			nd_id = its_nd_name_dict_p->get_id_of_this_stringy(nd_name);			nd_p= its_nds_p_p[nd_id];						nd_p->empty_trans_mat();			if(nd_p->get_num_of_in_nds()==0){ //deal with root nodes				for(USHORT s=0; s<nd_p->get_degen(); s++){					istream>> nd_st_name>> x>> y;					nd_st_id = nd_p->get_dict().get_id_of_this_stringy(nd_st_name);									nd_p->set_tm_amp(nd_st_id, 0, COMPLEX(x, y));				}				istream.my_get(ch);				while(ch!='#'){istream.my_get(ch);}			}else{				in_st_vec.set_to_default_vec(0, nd_p->get_num_of_in_nds());				more_in_sts=true;											while(more_in_sts){					for(USHORT r=0; r<nd_p->get_num_of_in_nds(); r++){						istream >> in_nd_name>>in_nd_st_name;						in_nd_id = its_nd_name_dict_p->get_id_of_this_stringy(in_nd_name);						in_nd_loc = nd_p->get_in_nds().loc_of_target(in_nd_id);						in_nd_st_id = its_nds_p_p[in_nd_id]->get_dict().get_id_of_this_stringy(in_nd_st_name);						in_st_vec[in_nd_loc]=in_nd_st_id;					}					in_st = nd_p->get_in_nd_sof().int_label(in_st_vec);					for(USHORT s=0; s<nd_p->get_degen(); s++){						istream>> nd_st_name>> x>> y;						nd_st_id = nd_p->get_dict().get_id_of_this_stringy(nd_st_name);										nd_p->set_tm_amp(nd_st_id, in_st, COMPLEX(x, y));					}					istream.my_get(ch);					while(isspace(ch)){istream.my_get(ch);}					if(ch=='#'){						more_in_sts = false;					}else{						more_in_sts = true;						istream.putback(ch);					}				}			}		}	}	catch(END_OF_FILE){}		return true;}#pragma mark --TEXT files use during run--//******************************************BOOLEAN		QB_NET::good_ecases_file(MY_IFSTREAM  &  istream)		//i-o{	CHAR   		ecase_name_cstr[64];	STRINGY   	nd_name;	STRINGY   	nd_st_name;	USHORT  	nd_id;	USHORT		nd_st_id; 	CHAR  		ch;	BOOLEAN 	more_nodes;	//this function assumes that node and nd_st dictionaries are available!!	BOOLEAN 	file_is_ok = true;	BOOLEAN 	know_cur_ecase_name = false;	istream.exceptions(ios::badbit | ios::failbit);			//RP = reading position		try{		//skip header:		ch=my_endline;		while( ch!='#' ){ istream.my_get(ch); }		//AT THIS POINT, RP = ch= #		while(ch=='#'){//loop over ecases			istream >> ecase_name_cstr;			if(!STRINGY(ecase_name_cstr).is_legal_name())throw ILLEGAL_NAME(ecase_name_cstr);			know_cur_ecase_name = true;			//AT THIS POINT, RP is on last character of ecase name			istream.my_get(ch);			//AT THIS POINT, RP = ch = first character after ecase name			//go to end of ecase_name line:			while(ch!=my_endline){				if( !isspace(ch) )throw WRONG_PATTERN();				istream.my_get(ch);			}			//AT THIS POINT, RP = ch = my_endline			//file may end before this reaches a non-blank space:			while(isspace(ch)){istream.my_get(ch);}			//AT THIS POINT, RP = ch = first non-white ch after last my_endline.			if(ch=='#'){				more_nodes = false;			}else{				more_nodes = true;				istream.putback(ch);			}								while(more_nodes){ //loop over nodes with non default active-state set				istream >> nd_name;				nd_id = get_dict().get_id_of_this_stringy(nd_name);				if(nd_id==max_ushort)throw UNLISTED_NODE(nd_name);				//AT THIS POINT, RP is on last character of nd_name				istream.my_get(ch);				//AT THIS POINT, RP = ch = first character after nd_name				//go to end of nd_name line:					while(ch!=my_endline){ //loop over the active-state names of a single node					if(isspace(ch)){ //if ch is blank, advance carefully, just one character at a time						istream.my_get(ch);					}else{//if ch is not blank, advance less carefully, gobble up a whole name						istream.putback(ch);						istream >> nd_st_name;						nd_st_id = get_nd_ptr(nd_id)->get_dict().get_id_of_this_stringy(nd_st_name);						if(nd_st_id==max_ushort)throw UNLISTED_STATE(nd_name, nd_st_name);						//AT THIS POINT, RP is on last character of nd_st_name						istream.my_get(ch);						//AT THIS POINT, RP = ch = first character after nd_st_name					}				}//end of loop over state names				// AT THIS POINT, RP = ch = my_endline				//file may end before this reaches a non-blank space:				while(isspace(ch)){istream.my_get(ch);}				//AT THIS POINT, RP = ch = first non-white ch after last my_endline.				if(ch=='#'){					more_nodes = false;				}else{					more_nodes = true;					istream.putback(ch);				}								}//end of loop over nodes with non default active-state set			//AT THIS POINT, RP = ch = #			know_cur_ecase_name = false;		}//end of loop over ecases	}// end of try{}		catch(END_OF_FILE){		if(!know_cur_ecase_name){			my_gen_alert(				STRINGY("Bad Input: Check file ")				&& "with ecases"				&& ", line " 				&& istream.cur_line()				&& ". "				&& "File should not end here. Something is missing."			);			file_is_ok = false;#ifdef   _ansi_app //''''''''''''''''''''''''''''''''''''''''''''\\.				exit(1);#endif //_ansi_app \\............................................//		}	}		catch(const IO_EXCEPTION  &  exc){		exc.print_error("with ecases", istream.cur_line());		file_is_ok = false;#ifdef   _ansi_app //''''''''''''''''''''''''''''''''''''''''''''\\.			exit(1);#endif //_ansi_app \\............................................//	}	//The class failure is defined INSIDE the class ios so	//one must use "ios::failure" to access it.	catch(const ios::failure  &  io_exc){		//STRINGY   stringy = io_exc.what();//pretty useless		my_gen_alert(			STRINGY("Bad Input: Check file ")			&& "with ecases"			&& ", line "			&& istream.cur_line()			&& ". " 		);		file_is_ok = false;#ifdef   _ansi_app //''''''''''''''''''''''''''''''''''''''''''''\\.			exit(1);#endif //_ansi_app \\............................................//	}			//stops istream from throwing any more exceptions 	istream.exceptions(ios::goodbit);	//rewinds istream. 	istream.seekg_(0, ios::in); 	//clears eof bit flag	istream.clear();	return  file_is_ok;		}//******************************************VOID	QB_NET::write_one_story_into_file(MY_OFSTREAM  *  fstream_p,		//i-o USHORT net_story_count,			//inUSHORT ending)					//in{	*fstream_p<<setiosflags( ios::showpoint | ios::fixed );// net_story_count and ending are both one based.		*fstream_p		<< "story number = " 		<< net_story_count		<<",  \t"		<< "story amplitude (rect. coords.) = " 		<< "(" << real(its_dyn_amp) << "," << imag(its_dyn_amp) << ")" 		<<",  \t"		<< "ending = " 		<< ending		<< my_endline;	USHORT i;	for(i=0; i <(its_num_of_nds -1) ; i++){		*fstream_p			<< its_nds_p_p[i]->get_name()			<<" = "			<< its_nds_p_p[i]->get_st_name(its_dyn_story[i])			<<",  \t";	}	i = its_num_of_nds - 1;	*fstream_p		<< its_nds_p_p[i]->get_name()		<<" = "		<< its_nds_p_p[i]->get_st_name(its_dyn_story[i])		<< my_endline	;}//******************************************VOID	QB_NET::write_header_of_nd_probs_file(MY_OFSTREAM  *  nd_probs_stream_p)		//i-o{	*nd_probs_stream_p 		<<"node: its states"<<my_endline;			NODE  * nd_p=0;	#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	USHORT		num = its_mview_p->get_num_of_sel_nds();	Boolean 	do_all = (num==0||num==its_num_of_nds);#endif //_mac_gui_app \\............................................//	for(USHORT nd_id=0;nd_id<its_num_of_nds; nd_id++){		nd_p = its_nds_p_p[nd_id];#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.		if(!(do_all || nd_p->is_selected())) goto next_nd;#endif //_mac_gui_app \\............................................//		*nd_probs_stream_p 			<<nd_p->get_name()			<<":  \t";		for(USHORT st=0; st<nd_p->get_degen(); st++){			*nd_probs_stream_p				<<(st+1)				<<'#'				<<nd_p->get_st_name(st)				<<"  \t";		}		*nd_probs_stream_p << my_endline;		next_nd:;	}}		//******************************************VOID	QB_NET::write_nd_probs_into_file(const CHAR  * ecase_name_cstr,				//in MY_OFSTREAM  * 	nd_probs_stream_p)			//i-o{	*nd_probs_stream_p<<setprecision(6)<<setiosflags( ios::showpoint | ios::fixed | ios::left);	*nd_probs_stream_p 		<<"**********ecase = " 		<<ecase_name_cstr<<my_endline;	USHORT	x = get_len_of_longest_nd_name();	USHORT	len_of_col_1 = 11;	if(len_of_col_1<x) len_of_col_1 = x;	*nd_probs_stream_p 		<<setw(len_of_col_1)		<<"Prob(nd\\st)" //need two \s because first \ signals to take second \ literally		<<"  \t";	USHORT st;	USHORT	max = get_max_degen();	for(st=0; st<max; st++){		*nd_probs_stream_p			<<setw(8)			<<(st+1)			<<"  \t";	}	*nd_probs_stream_p << my_endline;		NODE  * 	nd_p=0;#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	USHORT		num = its_mview_p->get_num_of_sel_nds();	Boolean 	do_all = (num==0||num==its_num_of_nds);#endif //_mac_gui_app \\............................................//	for(USHORT nd_id=0;nd_id<its_num_of_nds; nd_id++){		nd_p = its_nds_p_p[nd_id];#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.		if(!(do_all || nd_p->is_selected())) goto next_nd;#endif //_mac_gui_app \\............................................//		*nd_probs_stream_p 			<<setw(len_of_col_1)			<<nd_p->get_name()			<<"  \t";		for(st=0; st<nd_p->get_degen(); st++){			*nd_probs_stream_p				<<setw(8)				<<nd_p->get_cum_prob(st)				<<"  \t";		}		*nd_probs_stream_p << my_endline;		next_nd:;	}}//******************************************VOID	QB_NET::write_bi_nd_probs_into_file(const CHAR  * 	ecase_name_cstr,			//inMY_OFSTREAM  * 	bi_nd_probs_stream_p)		//i-o{	*bi_nd_probs_stream_p<<setprecision(6)<<setiosflags( ios::showpoint | ios::fixed | ios::left );	*bi_nd_probs_stream_p 		<<"**********ecase = " 		<<ecase_name_cstr			<< my_endline;			USHORT nd1, nd2, nd1_st, nd2_st;	const DIR_DATA<BI_NODE>  *  dir_bi_nd_p = its_bi_nds.get_first_p();	const BI_NODE  * 	bi_nd_p;	USHORT 	len_of_col_1, col_len;	USHORT	x, y;	STRINGY top_str;	while(dir_bi_nd_p){		bi_nd_p = &(dir_bi_nd_p->its_data);		nd1 = bi_nd_p->get_nd1();		nd2 = bi_nd_p->get_nd2();		//Need two \s. First \ signals that second \ should be taken literally		top_str= (STRINGY)its_nds_p_p[nd1]->get_name() && "\\" && its_nds_p_p[nd2]->get_name();		x = top_str.get_len();		y = get_len_of_longest_st_name(nd1);		len_of_col_1 = 15;		if( len_of_col_1 < x) len_of_col_1 = x;		if( len_of_col_1 < y) len_of_col_1 = y; 		*bi_nd_probs_stream_p 			<<setw(len_of_col_1)			<<top_str			<<"  \t";		for(nd2_st=0; nd2_st< its_nds_p_p[nd2]->get_degen();nd2_st++){			top_str = its_nds_p_p[nd2]->get_st_name(nd2_st);			x = top_str.get_len();			col_len= 8;			if(col_len<x)col_len = x;			*bi_nd_probs_stream_p 				<<setw(col_len)				<<top_str				<<"  \t";		}		*bi_nd_probs_stream_p << my_endline;		for(nd1_st=0; nd1_st< its_nds_p_p[nd1]->get_degen();nd1_st++){			*bi_nd_probs_stream_p 				<<setw(len_of_col_1)				<<its_nds_p_p[nd1]->get_st_name(nd1_st)				<<"  \t";			for(nd2_st=0; nd2_st< its_nds_p_p[nd2]->get_degen();nd2_st++){				x = its_nds_p_p[nd2]->get_st_name(nd2_st).get_len();				col_len= 8;				if(col_len<x)col_len = x;				*bi_nd_probs_stream_p 					<<setw(col_len)					<<bi_nd_p->get_cum_prob(nd1_st, nd2_st)					<<"  \t";			}			*bi_nd_probs_stream_p <<my_endline;		}		*bi_nd_probs_stream_p <<my_endline;		dir_bi_nd_p = dir_bi_nd_p->its_next_p;	}}		