#pragma once   #include "QFog_constants.h"#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	class  C_DOC;	class  C_MAIN_VIEW;	#include "C_ARROW.h"	#include "C_ANTHOLOGY_ITEM.h"	// a run is composed of one or more go_forward()'s	enum RUN_STATE{bef_run, dur_run, aft_run}; //dur= during#endif //_mac_gui_app \\............................................//#include <stdlib.h>#include <typeinfo.h>#include "NODE.h"#include "VECTOR.h"#include "STRINGY.h"#include "L_LIST.h"#include "UI_MAP.h"#include "BI_NODE.h"#include "MY_FSTREAMS.h"//QB_NET = quantum bayesian net//******************************************class QB_NET{private:	NODE  *  *   			its_nds_p_p; // nds = nodes	// a NODE object X will have id-number nd_id if its_nds_p_p[nd_id] points to X	 // num = number, ptrs = pointers		USHORT  				its_num_of_nd_ptrs; 	USHORT  				its_num_of_nds;  	L_LIST<BI_NODE> 		its_bi_nds;		const STRINGY  *  *   	its_nd_names_p_p;		DICTIONARY  * 			its_nd_name_dict_p;		VECTOR<USHORT> 			its_nd_chronology;	USHORT 					its_final_era_len;	//dynamic	COMPLEX					its_dyn_amp;	VECTOR<USHORT>			its_dyn_story;#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	C_DOC  *				its_doc_p;	C_MAIN_VIEW  *   		its_mview_p;	L_LIST<C_ARROW>	 		its_arrows;	L_LIST<C_ANTHOLOGY_ITEM>	its_anthology;		RUN_STATE	its_run_state; 			#endif //_mac_gui_app \\............................................//	public:		VOID	clear_nds();	VOID    clear();	VOID 	init();		QB_NET();	virtual ~QB_NET();		NODE  * get_nd_ptr(USHORT nd_id);			USHORT	get_num_of_nds() const;		const STRINGY  &   get_nd_name(USHORT nd_id) const;	VOID  	set_nd_name(USHORT nd_id, const STRINGY  &  name);	USHORT	get_len_of_longest_nd_name();			USHORT	get_len_of_longest_st_name(USHORT nd_id);	VOID 	set_state_name(USHORT nd_id, USHORT row_num, const STRINGY  & new_name);	const USHORT	get_cur_finesse_of_amps() const;	VOID	filter_out_small_amps(USHORT	finesse );		VOID 	set_act_sts_of_a_nd(USHORT nd_id, const SET  &  act_sts); 	VOID  	activate_a_nd_state(USHORT nd_id, USHORT st_id);	VOID 	empty_act_st_sets_of_all_nds();	VOID  	fill_act_st_sets_of_all_nds();	VOID 	preserve_act_st_sets_of_all_nds();	VOID 	restore_act_st_sets_of_all_nds();	BOOLEAN	sort_into_layers_of_external_nds(VECTOR<USHORT>  &  era_of, USHORT  & num_of_eras);//	BOOLEAN	sort_into_layers_of_parents(VECTOR<USHORT>  &  era_of, USHORT  & num_of_eras);		BOOLEAN chrono_sort();		VOID  	grow_num_of_nd_ptrs();	VOID  	warn_user_about_cycle();	BOOLEAN add_int_arrow(USHORT s, USHORT d, BOOLEAN try_to_sort);	USHORT  add_nd(const STRINGY  & nd_class_str, BOOLEAN try_to_sort);	VOID  	set_degen_of_a_nd(USHORT nd_id, USHORT degen);	USHORT  get_degen_of_a_nd(USHORT nd_id);	USHORT  get_max_degen();	USHORT  	get_num_of_bi_nds();	BI_NODE  *  get_bi_nd_ptr(USHORT loc);	STRINGY 	get_bi_nd_name(USHORT loc);	VOID  		get_bi_nd(USHORT loc,  USHORT  & nd1,  USHORT  & nd2);	BOOLEAN  	add_bi_nd(USHORT nd1, USHORT nd2);	VOID 	 	warn_user_about_repeated_bi_nd();	VOID 	 	warn_user_about_degenerate_bi_nd();	const DICTIONARY  &  get_dict() const;	VOID  	create_nd_name_dictionary();			VOID  	create_nd_st_dictionaries();	VOID	create_dictionaries();	VOID  	kill_nd_name_dictionary();				VOID  	kill_nd_st_dictionaries();	VOID	kill_dictionaries();	VOID		read_topology_file(MY_IFSTREAM  &  istream);	BOOLEAN  	good_nd_sts_file(MY_IFSTREAM  & istream);		BOOLEAN		read_nd_sts_file(MY_IFSTREAM  &  istream);	BOOLEAN		good_amps_file(MY_IFSTREAM  &  istream);	BOOLEAN		read_amps_file(MY_IFSTREAM  &  istream);		BOOLEAN  	good_ecases_file(MY_IFSTREAM  &  istream);		VOID 		write_one_story_into_file(					MY_OFSTREAM  *  fstream_p,					USHORT net_story_count,					USHORT ending);	VOID 		write_header_of_nd_probs_file( MY_OFSTREAM  *  nd_probs_stream_p);	VOID 		write_nd_probs_into_file(					const CHAR  * ecase_name_cstr,					MY_OFSTREAM  * 	nd_probs_stream_p);	VOID 		write_bi_nd_probs_into_file(					const CHAR  * ecase_name_cstr,					MY_OFSTREAM  *  bi_nd_probs_stream_p);		VOID	set_cum_info_to_default();	VOID	fill_final_era_degens(VECTOR<USHORT>  & final_era_degens);	VOID	set_all_dyn_sts_to_max_ushort();	BOOLEAN external_nds_accept_ending(const VECTOR<USHORT>  & ending_vec);	BOOLEAN dyn_in_st_is_consistent(USHORT nd_id);	VOID	send_dyn_in_st_to_nds(USHORT nd_id);	VOID	use_dyn_in_sts_to_reconstruct_dyn_sts_for_times_larger_than(USHORT limit_time);	VOID	set_dyn_net_story_and_amp();	VOID	add_story_to_cum_amps();	VOID	prepare_cum_info_for_next_ending();	VOID	normalize_cum_probs();	VOID	add_story_to_anthology( USHORT ending);	VOID    multi_mode_go(		BOOLEAN			is_mini_run,		const CHAR  * 	ecase_name_cstr,		MY_OFSTREAM  * 	nd_probs_stream_p,		MY_OFSTREAM  *  bi_nd_probs_stream_p,		MY_OFSTREAM  * 	stories_stream_p, 		BOOLEAN  		illustrate_stories,		DOUBLE  &	out_prob,		USHORT	&	num_of_stories);		VOID    go_forward(		const CHAR  * ecase_name_cstr,		MY_OFSTREAM  * 	nd_probs_stream_p,		MY_OFSTREAM  *  bi_nd_probs_stream_p,		MY_OFSTREAM  * 	stories_stream_p, 		BOOLEAN  		illustrate_stories);	VOID 	do_mini_run(DOUBLE  & out_prob, USHORT	&	num_of_stories);			#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	ND_CLASS_ID			get_nd_class_id(USHORT 	nd_id) const;	STRINGY				get_nd_class_str(USHORT	nd_id) const;	VOID	set_doc_and_mview_ptrs(C_DOC  * doc_p, C_MAIN_VIEW   *  view_p);		DIR_DATA<C_ARROW>  * 	get_arrows_first_p();	USHORT					get_num_of_arrows();	VOID	reorder_nds(const UI_MAP  &	 map);	VOID	reorder_nd_sts(USHORT nd_id, const UI_MAP  &  map);			VOID  	del_int_arrow(USHORT s, USHORT d, BOOLEAN try_to_sort); 	VOID    del_nd(USHORT nd_id, BOOLEAN try_to_sort);	VOID	del_bi_nd(USHORT xed_position);	VOID  	del_all_bi_nds_with_this_nd(USHORT nd_id);		BOOLEAN  calc_closest_pts(		const C_CIRCLE  &  cir1,		const C_CIRCLE  &  cir2,		Point  &  pt1,		Point  &  pt2);	C_ARROW  *   mac_add_int_arrow(		const C_PORT_NAME  &  s_port_name,		const C_PORT_NAME  &  d_port_name,		BOOLEAN try_to_sort); 	USHORT   mac_add_nd(		ND_CLASS_ID  nd_class_id,		const Point  &  m_down_pt,		BOOLEAN try_to_sort);	BOOLEAN		nodes_have_same_state_set(USHORT nd1, USHORT nd2);	BOOLEAN		change_source_nd_of_ar(C_ARROW  *  ar_p, const C_PORT_NAME  &  new_s_port_name);	const RUN_STATE  get_run_state() const;	VOID	set_run_state( RUN_STATE  state);	DIR_DATA<C_ANTHOLOGY_ITEM>  * get_anthology_first_p();	USHORT 		get_anthology_len();	VOID		write_net_stream(LStream  &  net_stream, NET_STREAM_TYPE stream_type);				VOID		read_net_stream(LStream  &  net_stream, NET_STREAM_TYPE stream_type);		VOID		write_topology_file(MY_OFSTREAM  & strm);	VOID		write_nd_sts_file(MY_OFSTREAM  & strm);	VOID		write_amps_file(MY_OFSTREAM  & strm);			#endif //_mac_gui_app \\............................................//};#pragma mark -//******************************************inlineNODE  * 	QB_NET::get_nd_ptr(USHORT	nd_id)	//in{	return its_nds_p_p[nd_id];}//******************************************inlineUSHORT	QB_NET::get_num_of_nds() const{	return its_num_of_nds;}//******************************************inlineconst STRINGY  &   QB_NET::get_nd_name(USHORT		nd_id)	//inconst{	return its_nds_p_p[nd_id]->get_name();}//******************************************inlineVOID  QB_NET::set_nd_name(USHORT		nd_id,			//inconst STRINGY  &	name)	//in{	its_nds_p_p[nd_id]->set_name(name);}//******************************************inlineVOID	QB_NET::set_state_name(USHORT		nd_id,				//inUSHORT		row_num,			//inconst STRINGY  &	new_name)	//in{	its_nds_p_p[nd_id]->set_st_name(row_num, new_name);}//******************************************inlineVOID 	QB_NET::set_act_sts_of_a_nd(USHORT 		nd_id,			//inconst SET  &  act_sts)		//in{	its_nds_p_p[nd_id]->set_active_states(act_sts);}//******************************************inlineVOID  QB_NET::activate_a_nd_state(USHORT		nd_id,		//inUSHORT		st_id)		//in{	its_nds_p_p[nd_id]->activate_state(st_id);}//******************************************inlineUSHORT   QB_NET::get_degen_of_a_nd(USHORT 	nd_id)		//in{	return its_nds_p_p[nd_id]->get_degen();}//******************************************inlineUSHORT  	QB_NET::get_num_of_bi_nds(){	return its_bi_nds.get_len();}//******************************************inlineBI_NODE  *	QB_NET::get_bi_nd_ptr(USHORT loc){	return &(its_bi_nds[loc]);}		//******************************************inlineconst DICTIONARY  &  QB_NET::get_dict() const{	return *its_nd_name_dict_p;}//******************************************inlineVOID	QB_NET::do_mini_run(DOUBLE  &	out_prob,							//outUSHORT	&	num_of_stories)						//out		{	//Calculates total probability of all stories and 	//number of stories, assuming all states are active.	multi_mode_go(		true,//is_mini_run		0,//ecase_name_cstr		0,//nd_probs_stream_p		0,//bi_nd_probs_stream_p		0,//stories_stream_p 		false,//illustrate_stories		out_prob,		num_of_stories);}#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.//******************************************inlineND_CLASS_ID		QB_NET::get_nd_class_id(USHORT 	nd_id)		//inconst{	return	its_nds_p_p[nd_id]->get_class_id();}//******************************************inlineSTRINGY		QB_NET::get_nd_class_str(USHORT	nd_id)	//inconst{	return  its_nds_p_p[nd_id]->get_class_str();}//******************************************inlineDIR_DATA<C_ARROW>  *	QB_NET::get_arrows_first_p(){	return  its_arrows.get_first_p();}//******************************************inlineUSHORT	QB_NET::get_num_of_arrows(){	return  its_arrows.get_len();}//******************************************inlineconst RUN_STATE  QB_NET::get_run_state() const{	return its_run_state;}//******************************************inlineVOID	QB_NET::set_run_state( RUN_STATE  state){  // used by C_DOC	its_run_state = state;}//******************************************inlineDIR_DATA<C_ANTHOLOGY_ITEM>  * 	QB_NET::get_anthology_first_p(){	return  its_anthology.get_first_p();}//******************************************inlineUSHORT QB_NET::get_anthology_len(){	return its_anthology.get_len();}#endif //_mac_gui_app \\............................................//