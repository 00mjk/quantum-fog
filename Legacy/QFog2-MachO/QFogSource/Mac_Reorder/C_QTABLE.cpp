#include  	"C_QTABLE.h"#include 	"STRINGY.h"#include 	"StCPTstate.h"//******************************************C_QTABLE::C_QTABLE(LStream 	 *	inStream )		//in	:LTable(inStream){	// Add a single column.	InsertCols( 1, 0, nil );}//******************************************C_QTABLE::~C_QTABLE(){}//******************************************VOID	C_QTABLE::set_num_of_rows(USHORT	num_of_rows)		//in{		InsertRows(num_of_rows, 0, nil );		its_map.set_to_default_map(mRows);}#pragma mark --reordering process(including visual cues)--//******************************************/*row				boundary(1 based)		(0 based)-				01							-				1												2				-				23				-				34				-				45				*///******************************************USHORT 	C_QTABLE::get_boundary(const Point	 &  local_pt) 	 //in{	DOUBLE	full = local_pt.v/ DOUBLE(mRowHeight);	SInt32	integral_part = local_pt.v/mRowHeight;	DOUBLE	remainder = full - integral_part;	SInt32	boundary = (remainder < 0.5 ? integral_part: integral_part+1);		// Constrain it to the range of cells.	// Note: zero is used to mean "insert at the beginning".	if ( boundary < 0 )boundary = 0;	if ( boundary > mRows )boundary = mRows;		return boundary;}//******************************************VOID	C_QTABLE::draw_boundary(USHORT		boundary)		//in{//drawer	// Focus the pane and get the table frame.	FocusDraw();	Rect	table_frame;	CalcLocalFrameRect(table_frame);	//save cpt state and normalize	StCPTstate		saved_st(true, true, false);	saved_st.Normalize();	// Setup the color and pen state.	::ForeColor( blackColor );	::PenMode( patXor );	::PenSize( 2, 2 );	// Save the clip region state and clip the table frame.	StClipRgnState	saved_clip_state( table_frame );	// Calculate the boundary's left end point.			Point	end_point;	end_point.v = boundary * mRowHeight;	end_point.h = 0;	// Draw the line.	::MoveTo( end_point.h, end_point.v );	::LineTo( end_point.h + mColWidth, end_point.v );	}//******************************************VOID	C_QTABLE::ClickCell(const TableCellT	 &		inCell,			//inconst SMouseDownEvent	 & 	inMouseDown )	//in{	//MONITOR_THE_CHANGE_HERE		LTable::ClickCell( inCell, inMouseDown );	FocusDraw();		Point	old_pt = inMouseDown.whereLocal;	Point 	new_pt = old_pt;		USHORT	old_boundary, new_boundary;	old_boundary = get_boundary(old_pt);	draw_boundary(old_boundary);		while(::StillDown()) {		::GetMouse(&new_pt);		new_boundary = get_boundary(new_pt);		old_boundary = get_boundary(old_pt);		if(new_boundary!=old_boundary){			undraw_boundary(old_boundary);			AutoScrollImage(new_pt);			draw_boundary(new_boundary);		}		old_pt =new_pt;	}		::GetMouse(&new_pt);	new_boundary = get_boundary(new_pt);	undraw_boundary(new_boundary);/*example: init_nd_list	row				boundary	fin_nd_list(0 based)		(1 based)		(0 based)	(0 based)					-				00				1							0							-				1												1				2=click (int_sel)			2							-				22				3 							3 							-				33				4 (fin_sel)					1							-				4=fin_bound4				5							4			*/			TableCellT		init_sel_cell;	GetSelectedCell(init_sel_cell);	USHORT	init_sel_row = init_sel_cell.row;	USHORT	fin_sel_row = (new_boundary +1 > init_sel_row?new_boundary:new_boundary+1);	mSelectedCell.row = fin_sel_row;	// in the example init_sel_row = 2, fin_sel_row = 4;	VECTOR<USHORT>	saved_oldfn_map(its_map.its_oldfn);	USHORT	i;		if(init_sel_row<fin_sel_row){		for( i=0; i< (init_sel_row -1) ; i++){			its_map.its_oldfn[i] = saved_oldfn_map[i];		}			for(i= (init_sel_row -1) ; i< (fin_sel_row -1) ; i++){			its_map.its_oldfn[i] = saved_oldfn_map[i+1];		}		its_map.its_oldfn[fin_sel_row -1] = saved_oldfn_map[init_sel_row - 1];				for(i = fin_sel_row; i<mRows; i++){			its_map.its_oldfn[i] = saved_oldfn_map[i];		}		its_map.set_newfo();		Refresh();	}else if(init_sel_row>fin_sel_row){		for( i=0; i< (fin_sel_row -1) ; i++){			its_map.its_oldfn[i] = saved_oldfn_map[i];		}		its_map.its_oldfn[fin_sel_row -1] = saved_oldfn_map[init_sel_row - 1];					for(i= fin_sel_row ; i<init_sel_row ; i++){			its_map.its_oldfn[i] = saved_oldfn_map[i-1];		}		for(i = init_sel_row; i<mRows; i++){			its_map.its_oldfn[i] = saved_oldfn_map[i];		}		its_map.set_newfo();		Refresh();	}	}#pragma mark --alphabetize--//******************************************VOID	C_QTABLE::alphabetize_q(){	get_alphabetic_map(its_map);	Refresh();}#pragma mark --drawing that is independent of user actions--//******************************************VOID	 C_QTABLE::DrawCell(const TableCellT  &		inCell)		//in{//drawer	StCPTstate	saved_st(true, false, true);	saved_st.Normalize();		::TextFont(systemFont);	::TextSize(9);	Rect	cell_frame;	FetchLocalCellFrame(inCell, cell_frame);		LStr255	 str;	get_cell_data(inCell, str);		::MoveTo( cell_frame.left + 4, cell_frame.bottom - 4 );	::DrawString(str);	}