#include "POLARIZER.h"#include "GLOBAL_FUN.h"#include "TWO_MODE_FUN.h"#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	#include "StCPTstate.h"	#include "C_PHASOR_YZER_AMP_GEN.h"#endif //_mac_gui_app \\............................................//#pragma mark --creation/destruction--//******************************************POLARIZER::POLARIZER(){}//******************************************POLARIZER::~POLARIZER(){}#pragma mark ----used only with macgui----#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.#pragma mark --creation/destruction--//******************************************POLARIZER::POLARIZER(const Point  &  	m_down_pt)		//in	:NODE(m_down_pt){ }#pragma mark --drawing--//******************************************VOID	POLARIZER::draw(){//drawer	its_efield_p->Draw(0);	if(!its_efield_p->GetSuperView()->FocusDraw())return;	if(its_state_num_for_cap!=max_ushort) draw_state_cap();	StCPTstate		saved_st(true, true, false);	saved_st.Normalize();	 	//first fill circular region with pattern: 	Rect r; 	::SetRect(&r, 	its_center.h -default_mask_rad, its_center.v -default_mask_rad, 					its_center.h +default_mask_rad, its_center.v +default_mask_rad);		PixPatHandle 	pat_h = ::GetPixPat(pol_pat_rid);	//destroy_h: in this method	ThrowIfNil_(pat_h);	::FillCOval(&r, pat_h );		::DisposePixPat(pat_h);		//now draw black rim:	::RGBForeColor(&C_COLORS::its_black);	::FrameOval(&r);}#pragma mark --amp gen--//******************************************VOID	POLARIZER::call_amp_gen(QB_NET *  net_p, 		//inC_PI_WIND * pi_wind_p)	//in{	if(its_amp_gen_p==0){//set to nil in NODE::NODE() and NODE::NODE(const Point  & center)		its_amp_gen_p = new C_PHASOR_YZER_AMP_GEN(k_pol, this, net_p, pi_wind_p);		//delete:  by NODE::~NODE()								ThrowIfNil_(its_amp_gen_p );		//Created first time it is used,	}	its_amp_gen_p->talk();}//******************************************VOID	POLARIZER::obey_amp_gen(const DOUBLE & 	theta,		//inUSHORT 			max_m_sum,	//inconst USHORT  * 	mx_p,	//inconst USHORT  * 	my_p)	//in{	empty_trans_mat();		TWO_MODE_FUN  two_fun(theta);		SHORT 	row = -1;	COMPLEX	z(0, 0);	BOOLEAN 	tm_row_starting;	for(USHORT 	nloss=0; nloss<= max_m_sum; nloss++){	for(USHORT 	n_sum=0; n_sum<=max_m_sum - nloss; n_sum++){ //n_sum = nx + ny	for(USHORT  ny=0; ny<= n_sum ; ny++){		USHORT nx = n_sum - ny;		tm_row_starting = true;		for(TM_COL_NUM in_st=0; in_st<its_num_of_in_sts; in_st++){						z = two_fun.get_pol_amp(nx, ny, nloss, mx_p[in_st], my_p[in_st]);			if(abs(z)>=amps_floor){				if(tm_row_starting){					row++;					its_st_names[row] =  STRINGY("(" ) &&  nx  && "," && ny && ")" && nloss;					tm_row_starting=false;				}				its_tm_amps.set_ele( row, in_st, z);			}		}	}}}}// *********************************************#endif //_mac_gui_app \\............................................//