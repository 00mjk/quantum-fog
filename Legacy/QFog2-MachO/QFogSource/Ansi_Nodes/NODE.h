#pragma once#include "QFog_constants.h"#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	#include "C_PORT_RELATED.h"	#include "C_COLORS.h"	class C_MAIN_VIEW;	#include "C_ND_EFIELD.h"	#include "MY_FSTREAMS.h"	#include "C_AMP_GEN.h"#endif //_mac_gui_app \\............................................//#include "STRINGY.h"#include "VECTOR.h"#include "TRANS_MAT.h"#include "STRETCH_OR_FOLD.h"//#include "L_LIST.h"#include "DICTIONARY.h"#include "SET.h"#include "UI_MAP.h"//******************************************class  ST_NAMES_GENERATOR_DATA{public:	USHORT		its_num_of_comps;	CHAR		its_min_char;	CHAR		its_max_char;	BOOLEAN		its_has_commas;		ST_NAMES_GENERATOR_DATA();};enum ND_CLASS_ID {NO_NODE_id=0,BEAM_SPL_id,CUSTOM_ND_id,DET_ND_id,POL_ROTATOR_id,POLARIZER_id,QBIT_ROT_id,SG_MAGNET_id};//keep in mind that if you add a new id type//to this list, and you don't add it to the end of the list,//the values of successive ids in the list will change.//******************************************class NODE{protected:	STRINGY  its_name;	USHORT   its_degen;			VECTOR<STRINGY> its_st_names;     // st = state	DICTIONARY  *  	its_st_name_dict_p;	        VECTOR<USHORT>  	its_in_nds; // nds = nodes, in = incoming	VECTOR<USHORT>  	its_in_nd_degens;  // degens = numbers of states	STRETCH_OR_FOLD		its_in_nd_sof;	TM_COL_NUM          its_num_of_in_sts; 	 		VECTOR<USHORT>  its_out_nds;        // out = outgoing  	TRANS_MAT       its_tm_amps;         // amps = amplitudes		SET   its_active_states;	SET   its_tempo_active_states;			// The previous data members are the static info.	// The next data members are the dynamic info.	// By a dynamic(static) data member we mean one that 	// changes repeatedly (does not change) 	// when we call the function QB_NET::go_forward().		// NOTE that cum_probs are not necessarily normalized,	// so they are not probabilities in the strict sense.	// One might call them quasi probabilities.	USHORT					its_dyn_st;	VECTOR<USHORT>			its_dyn_in_st;	const DIR_NZ_ELE  * 	its_dyn_dir_ele_p;		VECTOR<COMPLEX>  its_cum_amps; //cum = cummulative 	VECTOR<DOUBLE>   its_cum_probs;public:	NODE();	virtual ~NODE();		const STRINGY  &  	get_name() const;	VOID 				set_name(const STRINGY  & name);				USHORT  get_degen() const;	VOID 	set_degen(USHORT degen);	const STRINGY  &  		get_st_name(USHORT loc) const;	VOID 					set_st_name(USHORT row_num, const STRINGY  & new_name);	virtual VOID			set_st_names_to_default();	VOID 					set_st_names_to_monotone_seq(USHORT starting_point);	VOID	 				set_st_names(const ST_NAMES_GENERATOR_DATA  &  v);	const DICTIONARY  &  	get_dict() const;	VOID  					create_dict();	VOID  					kill_dict();						TRANS_MAT  &  		get_tm_amps();	VOID  				set_tm_amp(USHORT row, TM_COL_NUM col, const COMPLEX  & z );	DOUBLE 	get_col_prob(TM_COL_NUM col);	VOID  				empty_trans_mat();														TM_COL_NUM  				get_num_of_in_sts();	virtual VOID  				set_num_of_in_sts();	const VECTOR<USHORT>  &  	get_in_nds() const;	const STRETCH_OR_FOLD  &  	get_in_nd_sof() const;	USHORT  					get_num_of_in_nds() const;							virtual VOID  				add_in_nd(USHORT nd_id, USHORT nd_degen);	virtual VOID  				del_in_nd(USHORT nd_id);		const VECTOR<USHORT>  &  	get_in_nd_degens() const;	virtual VOID  				set_in_nd_degen(USHORT nd_id, USHORT new_degen);	virtual VOID				renumber_in_nds(const UI_MAP  &	 map);	virtual VOID				reorder_in_nds(const UI_MAP  &  map, BOOLEAN touch_tm);	virtual VOID				change_in_nd_to_compatible_one(USHORT old_nd, USHORT new_nd);	const VECTOR<USHORT>  &  	get_out_nds() const;	VOID  						add_out_nd(USHORT nd_id);	VOID  						del_out_nd(USHORT nd_id);	VOID						renumber_out_nds(const UI_MAP  &  map);	VOID	reorder_sts(const UI_MAP  &   map);	VOID	change_tm_as_part_of_reordering_nd_sts_of_a_pa(USHORT  pa_id, const UI_MAP  &  map);				const SET  & 	get_active_states() const;	VOID  			set_active_states(const SET  & act_sts);	VOID 			empty_act_st_set();	VOID 			fill_act_st_set();	USHORT			get_num_of_active_states();			BOOLEAN 		is_active_state(USHORT state);	VOID 			activate_state(USHORT state);	VOID 			deactivate_state(USHORT state);	VOID 			preserve_act_st_set();	VOID 			restore_act_st_set();	USHORT	get_dyn_st() const;	VOID	set_dyn_st(USHORT dyn_st);	VOID 	set_dyn_st_and_dir_ele_ptr(USHORT dyn_st);		VOID	advance_dyn_dir_ele_ptr();	VOID	move_dyn_dir_ele_ptr_to_first_col();	BOOLEAN has_dyn_in_st() const;	const  VECTOR<USHORT>  &  	get_dyn_in_st() const;	VOID	reset_dyn_in_st();	const COMPLEX  &			get_dyn_amp() const;	DOUBLE	get_cum_prob(USHORT state) const;	VOID 	normalize_cum_probs();	VOID 	set_cum_info_to_default();	VOID 	add_to_dyn_st_entry_of_cum_amps(const COMPLEX  & net_amp);	VOID 	prepare_cum_info_for_next_ending();		#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.protected:	Point			its_center;	BOOLEAN  		its_is_selected;	C_ND_EFIELD  *  its_efield_p;  	// Equals max_ushort if no caption and number of state if there is:	 	USHORT		its_state_num_for_cap;	Rect 		its_state_cap_frame;	enum {default_sel_rad=16, default_mask_rad=16};		C_AMP_GEN * 	its_amp_gen_p;public:	NODE( const Point  &  center);	virtual const STRINGY	get_class_str()=0;	virtual ND_CLASS_ID		get_class_id()=0;		virtual VOID	call_amp_gen(QB_NET *  net_p, C_PI_WIND * pi_wind_p)=0;			C_ND_EFIELD  *  get_efield_ptr() const;	VOID  			set_efield_ptr(C_ND_EFIELD  * efield_p);		const Point  & 			get_center() const;	//override if different from default	virtual USHORT			get_sel_rad() const;	virtual USHORT			get_mask_rad() const;	virtual C_CIRCLE   		get_docking_cir(USHORT sub_nd_id);		virtual  BOOLEAN 		pt_is_in_greeting_cir_of_avail_s_port(const Point  &  pt, USHORT  &  sub_nd_id);			virtual  BOOLEAN 		pt_is_in_greeting_cir_of_avail_d_port(const Point  &  pt, USHORT  &  sub_nd_id);	virtual  VOID  			add_nd_to_port_glist(USHORT g_nd_id, USHORT sub_nd_id);//glist = guest list	virtual  VOID  			remove_nd_from_all_port_glists(USHORT g_nd_id);	virtual  VOID			renumber_nds_of_port_glists(const UI_MAP  &	map);	BOOLEAN 				is_selected() const;		virtual BOOLEAN  		pt_is_in_sel_cir(const Point  &  pt);		virtual C_CIRCLE   		get_selection_cir();			virtual Boolean			select(C_MAIN_VIEW *  mview_p);		virtual Boolean 		unselect(C_MAIN_VIEW *  mview_p);	virtual VOID 			toggle_select(C_MAIN_VIEW *  mview_p);		 		VOID  			draw_sel_handles_wkr();		virtual VOID 	draw_sel_handles();		virtual VOID 	undraw_sel_handles();		VOID 	draw_state_cap();	VOID  	undraw_state_cap();	VOID 	set_state_num_for_cap(USHORT state);		virtual const RGBColor  & 	get_color() const;	virtual 	VOID			set_color(const RGBColor  &  color);	virtual BOOLEAN 			has_color();		virtual VOID 	draw();	VOID  			undraw(SInt16 radius);	virtual VOID  	undraw();		virtual VOID move_by(const Point  &  delta);		virtual VOID 		rotate();	virtual SInt16 		get_icon_dir() const;	virtual VOID 		set_icon_dir(SInt16 icon_dir);	virtual BOOLEAN 	has_icon_dir();	VOID	write_net_stream(LStream  &  net_stream);					VOID	read_net_stream(LStream  &  net_stream);		#endif //_mac_gui_app \\............................................//};#pragma mark -//******************************************inlineconst STRINGY  & 	 NODE::get_name() const{	return its_name;}//******************************************inlineVOID 	NODE::set_name(const STRINGY  &	name)	//in{	its_name = name;}//******************************************inlineUSHORT  	NODE::get_degen() const{	return its_degen;}//******************************************inlineconst STRINGY  &  	NODE::get_st_name(USHORT	loc)	//inconst{	return its_st_names[loc];}//******************************************inlineVOID 	NODE::set_st_name(USHORT 				row_num,	//inconst STRINGY  & 	new_name)	//in{	its_st_names[row_num]=new_name;}//******************************************inlineVOID 	NODE::set_st_names_to_default(){}//******************************************inlineconst DICTIONARY  &  	NODE::get_dict() const{	return *its_st_name_dict_p;}//******************************************inlineTRANS_MAT  &  	NODE::get_tm_amps(){	return its_tm_amps;}//******************************************inlineVOID  	NODE::set_tm_amp(USHORT			row,			//inTM_COL_NUM		col,			//inconst COMPLEX  &	 z )		//in{	its_tm_amps.set_ele(row, col, z);}//******************************************inlineDOUBLE 	NODE::get_col_prob(TM_COL_NUM		col) 	//in{	return its_tm_amps.get_col_prob(col);}//******************************************inlineVOID  	NODE::empty_trans_mat(){	its_tm_amps.set_to_zero_mat(its_degen, its_num_of_in_sts);} //******************************************inlineTM_COL_NUM  	NODE::get_num_of_in_sts(){	return its_num_of_in_sts;}//******************************************inlineconst VECTOR<USHORT>  &  	NODE::get_in_nds() const{	return its_in_nds;}//******************************************inlineconst STRETCH_OR_FOLD  &  	NODE::get_in_nd_sof() const{	return its_in_nd_sof;}//******************************************inlineUSHORT  	NODE::get_num_of_in_nds() const{	return its_in_nds.get_len();}						//******************************************inlineconst VECTOR<USHORT>  &  	NODE::get_in_nd_degens() const{	return its_in_nd_degens;}				//******************************************inlineconst VECTOR<USHORT>  &  	NODE::get_out_nds() const{	return its_out_nds;}	//******************************************inlineVOID  	NODE::add_out_nd(USHORT		nd_id)	//in{ 	its_out_nds.insert_last(nd_id);}//******************************************inlineVOID  	NODE::del_out_nd(USHORT		nd_id)	//in{	its_out_nds.extract_at(its_out_nds.loc_of_target(nd_id));}//******************************************inlineconst SET  & 	NODE::get_active_states() const{	return its_active_states;}//******************************************inlineVOID  		NODE::set_active_states(const SET  &	act_sts)	//in{	its_active_states = act_sts;}//******************************************inlineVOID 		NODE::empty_act_st_set(){	its_active_states.empty();}//******************************************inlineUSHORT		NODE::get_num_of_active_states(){	return its_active_states.get_num_of_elems();}//******************************************inlineBOOLEAN 	NODE::is_active_state(USHORT	state)	//in{	return its_active_states.contains(state);}//******************************************inlineVOID 		NODE::activate_state(USHORT	state)	//in{	its_active_states.insert(state);}//******************************************inlineVOID 		NODE::deactivate_state(USHORT	state)	//in{	its_active_states.extract(state);}//******************************************inlineVOID 	NODE::preserve_act_st_set(){ 	its_tempo_active_states = its_active_states;}//******************************************inlineUSHORT	NODE::get_dyn_st() const{	return its_dyn_st;}//******************************************inlineVOID	NODE::set_dyn_st(USHORT 	dyn_st)		//in{	its_dyn_st = dyn_st;}//******************************************inlineconst  VECTOR<USHORT>  &  NODE::get_dyn_in_st()const{	return its_dyn_in_st;}//******************************************inlineconst COMPLEX  & 	NODE::get_dyn_amp()const{	ThrowIfNil_(its_dyn_dir_ele_p);	return its_dyn_dir_ele_p->its_ele;}//******************************************inlineDOUBLE		NODE::get_cum_prob(USHORT		state)	//inconst{	return its_cum_probs[state];}//******************************************inlineVOID	NODE::add_to_dyn_st_entry_of_cum_amps(const COMPLEX  &	net_amp)	//in{	its_cum_amps[its_dyn_st] += net_amp;}#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.//******************************************inlineC_ND_EFIELD  *		NODE::get_efield_ptr() const{	return its_efield_p;}//******************************************inlineVOID	NODE::set_efield_ptr(C_ND_EFIELD  *		efield_p)	//in{	its_efield_p = efield_p;}//******************************************inlineconst Point  &		NODE::get_center() const {	return its_center;}		//******************************************inlineUSHORT		NODE::get_sel_rad()  const{	return default_sel_rad;}//******************************************inlineUSHORT		NODE::get_mask_rad() const{	return default_mask_rad;}//******************************************inlineC_CIRCLE  	NODE::get_docking_cir(USHORT 	sub_nd_id)		//in{	#pragma unused(sub_nd_id)		return C_CIRCLE(its_center, get_sel_rad());;	}//******************************************inlineVOID  	NODE::add_nd_to_port_glist(USHORT		g_nd_id,		//inUSHORT		sub_nd_id)		//in{#pragma unused(g_nd_id, sub_nd_id)}//******************************************inlineVOID  	NODE::remove_nd_from_all_port_glists(USHORT		g_nd_id)	//in{#pragma unused (g_nd_id)}//******************************************inlineVOID  	NODE::renumber_nds_of_port_glists(const UI_MAP  &		map)	//in{}//******************************************inlineBOOLEAN 	NODE::is_selected() const{	return its_is_selected;}//******************************************inlineBOOLEAN  	NODE::pt_is_in_sel_cir(const Point  &  pt)		//in{ 	// sel_cir = selection circle	return  C_CIRCLE(its_center, get_sel_rad()).pt_is_in(pt);}//******************************************inlineC_CIRCLE	NODE::get_selection_cir(){		return C_CIRCLE(its_center, get_sel_rad());	}//******************************************inlineVOID 	NODE::set_state_num_for_cap(USHORT	state)	//in{	its_state_num_for_cap = state;}	//******************************************inlineconst RGBColor  &	NODE::get_color() const{	return C_COLORS::its_white;}//******************************************inlineVOID	NODE::set_color(const RGBColor  &  color)	//in{}//******************************************inlineBOOLEAN 	NODE::has_color(){	return false;}//******************************************inlineVOID	NODE::draw(){	// this draws circle, efield and state_cap but not sel_handles}//******************************************inlineVOID	NODE::undraw(){	undraw(default_mask_rad);}//******************************************inlineVOID	NODE::rotate(){}//******************************************inlineSInt16	NODE::get_icon_dir() const{	return 0;}//******************************************inlineVOID	NODE::set_icon_dir(SInt16	icon_dir)	//in{}//******************************************inlineBOOLEAN		NODE::has_icon_dir(){	return false;}//******************************************inlineVOID	NODE::write_net_stream(LStream  &  net_stream)	 //i-o{	its_tm_amps.write_net_stream(net_stream);}//******************************************inlineVOID	NODE::read_net_stream(LStream  &  net_stream)	 //i-o{	its_tm_amps.read_net_stream(net_stream);//this assumes that the Dimensions of trans mat already correct}#endif //_mac_gui_app \\............................................//