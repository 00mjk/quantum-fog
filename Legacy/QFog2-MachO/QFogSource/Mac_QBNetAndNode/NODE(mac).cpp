#include "NODE.h"#include "C_MAIN_VIEW.h"#include "StCPTstate.h"#pragma mark ----used only with macgui----#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.//******************************************// nomenclature:// Keep your radii straight!:// sel_rad= selection radius = the radius within which the node will consider // 		itself selected or unselected.// mask_rad = mask radius =  node picture's outern radius. Equals // 		16 pixs for custom nodes but is less for marginalizer nodes.// 		Must have sel_rad >= mask_rad.//		Both sel_rad and mask_rad will be taken to be class constants of //		the specific classes derived from NODE.// docking_rad =  data member of C_DOCK.// greeting_rad = data member of C_DOCK.//******************************************#pragma mark --creation/destruction--NODE::NODE(const Point  & 	center)		//in	:its_degen(1),	its_st_names("x", 1),	its_st_name_dict_p(0),	its_num_of_in_sts(1),	its_center(center),	its_is_selected(false),	its_efield_p(0),	its_state_num_for_cap(max_ushort),	its_amp_gen_p(0){	its_active_states.insert(0);// note that the default TRANS_MAT constructor creates a 1 X 1 zero matrix ; //due to bug in LEditField constructor, the nd_efield is created and destroyed by the main view}#pragma mark --port related--//******************************************BOOLEAN 	NODE::pt_is_in_greeting_cir_of_avail_s_port(const Point  &  	pt,				//inUSHORT  &  			sub_nd_id)		//out{ 	C_CIRCLE	cir(its_center, get_sel_rad());	sub_nd_id=0;	return  cir.pt_is_in(pt);}//******************************************BOOLEAN 	NODE::pt_is_in_greeting_cir_of_avail_d_port(const Point  &  	pt,				//inUSHORT  &  			sub_nd_id)		//out{	C_CIRCLE	cir(its_center, get_sel_rad());	sub_nd_id=0;	return  cir.pt_is_in(pt);}#pragma mark --selection--//******************************************Boolean		NODE::select(C_MAIN_VIEW *  	mview_p)	//in{	// This function is used inside the select() method of	// the classes derived from NODE. 	// It draws the four node handles in a specified color	// and sets the selection status to true.	if(its_is_selected) return false;	its_is_selected = true;	draw_sel_handles( );	mview_p->num_of_sel_nds_pp();	return true;}//******************************************Boolean		NODE::unselect(C_MAIN_VIEW *  	mview_p)	//in{	// This function is used inside the unselect() method of	// the classes derived from NODE. 	// It draws the four node handles in white	// and sets the selection status to false.	if(!its_is_selected) return false;	its_is_selected = false;	undraw_sel_handles();	mview_p->num_of_sel_nds_mm();	return	true;}//******************************************VOID	NODE::toggle_select(C_MAIN_VIEW *  	mview_p)	//in{	if(its_is_selected){		unselect(mview_p);	}else{		select(mview_p);	}}#pragma mark --sel handles--//******************************************VOID	NODE::draw_sel_handles_wkr(){ //drawer	//wkr = weaker. If had an even weaker method, would suffix it _wkr_wkr, etc.//This is a private function used only by//NODE::draw_sel_handles() and NODE::undraw_sel_handles()//These 2 functions call//if(!its_efield_p->GetSuperView()->FocusDraw())return;//They also preserve the CTP state	Rect   nw, ne, se, sw; //nw = northwest, ...	SInt16  cx = its_center.h, cy = its_center.v; //cx = center's x	SInt16  radius = get_sel_rad() -2;	SInt16  d = 2; // handles are squares of side length = 2d+1	::SetRect(&nw,	cx -radius -d, cy - radius -d,					cx -radius +d, cy - radius +d);	::SetRect(&ne,	cx +radius -d, cy - radius -d,					cx +radius +d, cy - radius +d);	::SetRect(&se,	cx +radius -d, cy + radius -d,					cx +radius +d, cy + radius +d);	::SetRect(&sw,	cx -radius -d, cy + radius -d,					cx -radius +d, cy + radius +d);		::PaintRect(&nw);	::PaintRect(&ne);	::PaintRect(&se);	::PaintRect(&sw);	}//******************************************VOID	NODE::draw_sel_handles(){ //drawer	if(!its_efield_p->GetSuperView()->FocusDraw())return;	StCPTstate		saved_st(true, true, false);	saved_st.Normalize();			::RGBForeColor(&C_COLORS::its_red);		draw_sel_handles_wkr();}//******************************************VOID	NODE::undraw_sel_handles(){ //drawer	if(!its_efield_p->GetSuperView()->FocusDraw())return;	StCPTstate		saved_st(true, true, false);	saved_st.Normalize();		::RGBForeColor(&C_COLORS::its_white);		draw_sel_handles_wkr();}#pragma mark --state caption--//******************************************VOID	NODE::draw_state_cap(){ //drawer	if(!its_efield_p->GetSuperView()->FocusDraw())return;		StCPTstate	saved_st(true, true, true);	saved_st.Normalize();		::TextFont(its_efield_p->get_fnum());	::TextSize(its_efield_p->get_font_size());	LStr255  pstr;	its_st_names[its_state_num_for_cap].fill_LStr255(pstr);	SInt16   box_width = ::StringWidth(pstr) + 4;	its_efield_p->calc_state_cap_frame(its_state_cap_frame);	its_state_cap_frame.left = its_state_cap_frame.left - box_width/2;	its_state_cap_frame.right = its_state_cap_frame.right + box_width/2;	its_state_cap_frame.top = its_state_cap_frame.top +2;	 	its_state_cap_frame.bottom = its_state_cap_frame.bottom +2;	::TETextBox( StringPtr(pstr) +1, pstr[0], &its_state_cap_frame, teJustCenter);	its_state_cap_frame.top = its_state_cap_frame.top -2;	its_state_cap_frame.bottom = its_state_cap_frame.bottom -2;	::FrameRect(&its_state_cap_frame); }//******************************************VOID	NODE::undraw_state_cap(){ //drawer	if(!its_efield_p->GetSuperView()->FocusDraw())return;	::EraseRect(&its_state_cap_frame); 		}#pragma mark --draw all except sel handles--//******************************************VOID	NODE::undraw(SInt16	radius){//drawer	its_efield_p->undraw();	if(!its_efield_p->GetSuperView()->FocusDraw())return;	if(its_state_num_for_cap!=max_ushort) undraw_state_cap();		StCPTstate		saved_st(true, true, false);	saved_st.Normalize();	::RGBForeColor(&C_COLORS::its_white);	Rect r;	::SetRect(&r,	its_center.h -radius, its_center.v -radius,					its_center.h +radius, its_center.v +radius);			::PaintOval(&r);}#pragma mark --move--//******************************************VOID	NODE::move_by(const Point  &  delta)		//in{	undraw();// this undraws circle, efield and state_cap but not sel_handles	if(its_is_selected) undraw_sel_handles();	its_center.h += delta.h;	its_center.v += delta.v;	its_efield_p->MoveBy(SInt32(delta.h), SInt32(delta.v), false);	draw();// this draws circle, efield and state_cap but not sel_handles	if(its_is_selected) draw_sel_handles();}#endif //_mac_gui_app \\............................................//	