#include "GLOBAL_FUN.h"#include "STRINGY.h"#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	#include "StCPTstate.h"#endif //_mac_gui_app \\............................................////******************************************DOUBLE  my_factorial(USHORT n)	//in{	DOUBLE	x;	switch(n){		case 0: x= 1; break;		case 1: x= 1; break;		case 2: x= 2; break;		case 3: x= 6; break;		case 4: x= 2.4e1; break;		case 5: x= 1.2e2; break;		case 6: x= 7.2e2; break;		case 7: x= 5.04e3; break;		case 8: x= 4.032e4; break;		case 9: x= 3.6288e5; break;		case 10: x= 3.6288e6; break;		case 11: x= 3.99168e7; break;		case 12: x= 4.790016e8; break;		default:			x= 4.790016e8;			for(USHORT i=13; i<=n; i++){				x *=i;			}					break;	}	return x;}//******************************************VOID  	limited_degrees(SHORT  &  ang)		//i-o{//(io)	// nan = not a number. See fp.h. isnan(x) is a macro.//	if(isnan(ang))return;	shorts can never be NAN // dpo	while(ang<0){ang +=360;}	while(ang>=360){ang -=360;}}//******************************************VOID 	limited_degrees(DOUBLE  &  ang)		//i-o{//(io)	// nan = not a number. See fp.h. isnan(x) is a macro.	if(isnan(ang))return;	while(ang<0){ang +=360;}	while(ang>=360){ang -=360;}}#pragma mark ----used only with macgui----#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.//******************************************SInt16  nearest_int16(DOUBLE x)		//in{	SInt16	x_int = SInt16(x);	return  (x- x_int > .5)? x_int + 1: x_int;}//******************************************VOID	draw_cell_frame(const Rect  & rect)			//in{	StCPTstate		saved_st(true, true, false);	saved_st.Normalize();//	::PenPat(&qd.ltGray);	RGBColor  my_gray = {56000, 56000, 56000};	::RGBForeColor(&my_gray);	// lines are clipped and don't show up without offsets -1, -2 :	::MoveTo(rect.left, rect.bottom-1);	::LineTo(rect.right-2, rect.bottom-1);	::LineTo(rect.right-2, rect.top);}/*//******************************************VOID	my_set_cursor(SHORT id)		//in{	//id = a rid or watchCursor	//use UCursor::InitTheCursor() to get arrow back	CursHandle	cursor_h = ::GetCursor(id);	//destroy_h: in this method	ThrowIfNil_(cursor_h);	::HLock((Handle)cursor_h);//no need to save handle state as will be destroying handle soon	::SetCursor(*cursor_h);	ReleaseResource_((Handle)cursor_h);}*///******************************************VOID	trunc_pstr_so_it_fits(Str255  pstr,				//i-oUSHORT box_width,			//inUSHORT pixs_for_margins)	//in{		if((::StringWidth(pstr) + pixs_for_margins)>box_width){		while((::StringWidth(pstr) + pixs_for_margins)>box_width){			pstr[0]--;		}		//replace the last character by a hyphen		if(pstr[0]>2){ pstr[pstr[0]] = '-';}	}}//******************************************BOOLEAN 	get_TEXT_scrap(Handle   content_h)	//out{	//content_h: creation and destruction is done outside this function.	//The input content_h has zero length.	//The output content_h has null terminator and length >0.	//This method returns false if no item of that type was found.	//To use this method, you must:	//(1)create a zero length handle before calling this method	//(2)destroy the handle eventually after calling this method		//Refs.	//(1)Think Ref. under String.h	//(2)Dave Oster	//(3)PP	SignalIf_(::GetHandleSize(content_h)!=0);	//this grows content_h to scrap_len	if( not UScrap::HasData('TEXT')){		 //no item of that type was found		return false;	}		UScrap::GetData('TEXT', content_h);	SInt32 scrap_len = ::GetHandleSize(content_h);	//Grow content_h size by one byte to add null terminator.	//Add a null terminator even if you always add a	//null terminator to TEXT you put in the scrap.	//After all, an extra null terminator does not hurt, and 	//the one you add here will be the only one if the	//'TEXT' clipping created by another applications doesn't have it.	 	StHandleState  saved_h(content_h);//preserve handle state	 	//always unlock handle before growing its size	::HUnlock(content_h);//saved handle state	::SetHandleSize(content_h, scrap_len+1);	ThrowIfMemFail_(content_h);	::HLock(content_h);//saved handle state	(*content_h)[scrap_len] = '\0';		return true;	}#endif //_mac_gui_app \\............................................//