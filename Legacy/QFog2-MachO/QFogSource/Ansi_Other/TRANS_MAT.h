//******************************************// Purpose: To define a sparse transition matrix. // The matrix will be stored as an array of pointers to linked-lists.// The matrix dwell in the heap.//******************************************#pragma once#include "VECTOR.h"//#include "COL_LABEL_TRANSLATOR.h"#include "UI_MAP.h"class  	STRETCH_OR_FOLD;typedef  long 	TM_COL_NUM;//IMP: For the transition matrix,//We assume //num_of_cols<=max_ushort and//num_of_cols<=max_long.//However, we assume that//the number of non-zero elements in any row is <= max_ushort//******************************************class DIR_NZ_ELE // dir_nz_ele = directed non-zero element{public: 	// data 	TM_COL_NUM     	its_col_num;     // col = column, num = number	COMPLEX       	its_ele; 	DIR_NZ_ELE  *  	its_next_p;	 	DIR_NZ_ELE();	DIR_NZ_ELE (TM_COL_NUM col_num, const COMPLEX  & ele, DIR_NZ_ELE  * next_p);	DIR_NZ_ELE (const DIR_NZ_ELE  &  s);			const TM_COL_NUM 		get_col_num() const;	const COMPLEX  &  		get_ele() const;	const DIR_NZ_ELE  *  	get_next_p() const;};// Except for the gets, the class DIR_NZ_ELE// will be used only by the class TRANS_MAT. Thus, it// has only those four horsemen that will be used// by the class TRANS_MAT. In particular, the assigner not will be used.// Also, there is no need for an explicit destructor as // DIR_NZ_ELE never calls "new".//******************************************class TRANS_MAT  //trans_mat = transition matrix{private:	USHORT	        	its_num_of_rows; 	TM_COL_NUM         	its_num_of_cols;   // cols = columns	DIR_NZ_ELE  *  *    its_elements_p_p;public:		VOID 	clear_row(USHORT r);	VOID 	clear_row(DIR_NZ_ELE  *  x_p); 	VOID 	clear();		VOID 	copy(const TRANS_MAT  & mat);	VOID 	set_to_zero_mat(USHORT num_of_rows, TM_COL_NUM num_of_cols);	VOID 	resize(USHORT new_nr, TM_COL_NUM new_nc);	VOID 	set_num_of_rows(USHORT nr);		VOID 	set_num_of_cols(TM_COL_NUM nc);	TRANS_MAT();	TRANS_MAT(USHORT num_of_rows, TM_COL_NUM num_of_cols);	TRANS_MAT(const TRANS_MAT  & mat);	TRANS_MAT  & operator=(const TRANS_MAT  &  rhs);			virtual ~TRANS_MAT();		VOID	set_ele(USHORT row, TM_COL_NUM col, const COMPLEX  & ele);		COMPLEX read_ele(USHORT row, TM_COL_NUM col) const;		BOOLEAN  		is_col_valid(TM_COL_NUM c) const;	DOUBLE 			get_col_prob(TM_COL_NUM  col);	VECTOR<COMPLEX> get_col(TM_COL_NUM  col);	 	BOOLEAN  				is_row_valid(USHORT r) const;	USHORT					get_num_of_nz_elems(USHORT row);		const DIR_NZ_ELE  * 	get_row_ptr(USHORT row) const;			TM_COL_NUM 	get_num_of_cols() const;		USHORT 		get_num_of_rows() const;		//	VOID 		relabel_cols( const COL_LABEL_TRANSLATOR  &  ator);		const USHORT	get_cur_finesse_of_amps() const;		VOID			filter_out_small_amps(USHORT	finesse );	VOID	reorder_rows(const	UI_MAP  &   map);	VOID	reorder_cols_as_part_of_reordering_in_nds(		const STRETCH_OR_FOLD  &   old_sof,		const STRETCH_OR_FOLD  &   new_sof,		const UI_MAP  &		map);	VOID	reorder_cols_as_part_of_reordering_nd_sts_of_a_pa(		USHORT		pa_pos,			const STRETCH_OR_FOLD  &   sof,			const UI_MAP  &		map);		VOID	order_row_elems_by_increasing_col_num(); #ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\. 	VOID	write_net_stream(LStream  & net_stream);	VOID	read_net_stream(LStream  & net_stream);#endif //_mac_gui_app \\............................................//};#pragma mark -#pragma mark ----DIR_NZ_ELE----//******************************************inlineconst TM_COL_NUM 	DIR_NZ_ELE::get_col_num() const{	return its_col_num;}//******************************************inlineconst COMPLEX  &  	DIR_NZ_ELE::get_ele() const{	return its_ele;}//******************************************inlineconst DIR_NZ_ELE  *  	DIR_NZ_ELE::get_next_p() const{	return its_next_p;}#pragma mark ----TRANS_MAT----//******************************************inlineVOID	TRANS_MAT::set_num_of_cols(TM_COL_NUM	nc)		//in{	resize(its_num_of_rows, nc);}//******************************************inlineVOID	TRANS_MAT::set_num_of_rows(USHORT	nr)		//in{	resize(nr, its_num_of_cols);}//******************************************inlineBOOLEAN  	TRANS_MAT::is_col_valid(TM_COL_NUM	c)	//inconst{	return (  (0<=c)&&(c<=its_num_of_cols)   );}//******************************************inlineBOOLEAN  	TRANS_MAT::is_row_valid(USHORT	r)	//inconst{	return ( (0<=r)&&(r<=its_num_of_rows)  );}//******************************************inlineconst DIR_NZ_ELE  *  	TRANS_MAT::get_row_ptr(USHORT	row)const{	return its_elements_p_p[row];}//******************************************inlineTM_COL_NUM	TRANS_MAT::get_num_of_cols() const {	return its_num_of_cols;}//******************************************inlineUSHORT	TRANS_MAT::get_num_of_rows() const {	return its_num_of_rows;}