#include "STRETCH_OR_FOLD.h"// We say component vec[0] has a lower location (0) in vec than vec[1] does.// Two conventions for vec are possible:// (1)the higher the location, the more valuable the component// or (2) the lower the location, the more valuable the component// We will use (2), opposite to the decimal system: // In the decimal number 101, the left-most 1 has// a higher value than the right-most one.#pragma mark --creation/destruction--//******************************************VOID	STRETCH_OR_FOLD::copy(const STRETCH_OR_FOLD  &  	s)		//in{	its_degens = s.its_degens;	its_len = s.its_len;	its_num_of_vecs = s.its_num_of_vecs;}//******************************************VOID	STRETCH_OR_FOLD::init(const VECTOR<USHORT>  & 	degens)		//in{	its_degens = degens;	its_len = its_degens.get_len();	its_num_of_vecs = 1;	for(USHORT i =0; i < its_len ; i++){		its_num_of_vecs *= its_degens[i];	}}//******************************************STRETCH_OR_FOLD::STRETCH_OR_FOLD()	:its_len(0),	its_num_of_vecs(0){}//******************************************STRETCH_OR_FOLD::STRETCH_OR_FOLD(const VECTOR<USHORT>  & 	degens)		//in{	init(degens);}//******************************************STRETCH_OR_FOLD::STRETCH_OR_FOLD(const STRETCH_OR_FOLD  &  s)		//in{	copy(s);}//******************************************STRETCH_OR_FOLD::~STRETCH_OR_FOLD(){}#pragma mark --const functions--//******************************************LONG	STRETCH_OR_FOLD::int_label(const VECTOR<USHORT>  & 	vec_label)		//inconst{// i= v[0] + pi[0]*v[1] + pi[1]*v[2] +...+ pi[L-2]*v[L-1]//where pi[x]= d[0]*d[1]*...*d[x]//i=int_label, d[]=its_degens[], v[]= vec_label[], L = its_len// Note: (d[0]-1) + pi[0]*(d[1]-1) = d[0]*d[1] - 1	LONG i = vec_label[0]; 	LONG pi = its_degens[0];	for(USHORT loc=1; loc < its_len ; loc++){		i = i + pi*vec_label[loc];		pi *= its_degens[loc];	}	return i;}//******************************************VECTOR<USHORT>		STRETCH_OR_FOLD::vec_label(LONG 		int_label)	//inconst{// let 	pi[x] = d[0]*d[1]*...*d[x].// 	i /pi[L-2] 			= v[L-1],  	i %pi[L-2]			= r[L-1]// 	r[L-1] /pi[L-3] 	= v[L-2],  	r[L-1] %pi[L-3]		= r[L-2]// 	r[L-2] /pi[L-4] 	= v[L-3],  	r[L-2] %pi[L-4]		= r[L-3]// ...// 	r[2] /pi[0] 		= v[1],  	r[2] %pi[0]		= r[1]// 	r[1] /1 			= v[0],  	r[1] %1	 		= r[0]	LONG remainder=int_label;	LONG pi = its_num_of_vecs;	VECTOR<USHORT> vec(0, its_len);	USHORT loc;	LONG s_loc; // s= signed	for(s_loc = (LONG(its_len) - 1); 0<=s_loc; s_loc--){ 		//"comp" has a special meaning!		loc = USHORT(s_loc);		pi /= its_degens[loc];		vec[loc]  =  remainder/pi; 		remainder %= pi;  //remainder = remainder%pi;	}	return vec;}#pragma mark --reordering--//******************************************VOID	STRETCH_OR_FOLD::reorder_degens(const UI_MAP  &		map)	//in{	if(map.is_identity_map())return;	VECTOR<USHORT>	saved_degens(its_degens);	for(USHORT i=0; i< its_len; i++){		its_degens[i] = saved_degens[map.its_oldfn[i]];	}}	