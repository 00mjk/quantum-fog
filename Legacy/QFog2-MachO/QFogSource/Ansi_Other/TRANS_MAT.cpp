#include "TRANS_MAT.h"#include "QFog_constants.h"#include "UI_MAP.h"#include "STRETCH_OR_FOLD.h"#pragma mark ----DIR_NZ_ELE----#pragma mark --creation/destruction--//******************************************DIR_NZ_ELE::DIR_NZ_ELE()	:its_next_p(0){}//******************************************DIR_NZ_ELE::DIR_NZ_ELE(TM_COL_NUM		col_num,	//inconst COMPLEX  &	ele,	//inDIR_NZ_ELE  *		next_p)	//in	:its_col_num(col_num),	its_ele(ele),	its_next_p(next_p){} //******************************************DIR_NZ_ELE::DIR_NZ_ELE(const DIR_NZ_ELE  &		s)	//in	:its_col_num(s.its_col_num),	its_ele(s.its_ele),	its_next_p(0){}#pragma mark ----TRANS_MAT----#pragma mark --creation/destruction--//******************************************VOID   TRANS_MAT::clear_row(USHORT 	r) 		//in{// Deletes all elements in row r// and sets its_elements_p_p[r]=0.	if(its_elements_p_p[r]==0) return;	DIR_NZ_ELE  *  x_p = its_elements_p_p[r];	its_elements_p_p[r]=0;	DIR_NZ_ELE  * chaser_p = x_p;	while(x_p){		x_p = x_p->its_next_p;		delete chaser_p;		chaser_p = x_p;	}}		//******************************************VOID   TRANS_MAT::clear_row(DIR_NZ_ELE  *  chaser_p)	//i-o {// For a given row, deletes any elements located after the// element pointed to by chaser_p, and sets chaser_p->its_next_p=0	if(chaser_p==0)return;	DIR_NZ_ELE  * x_p = chaser_p->its_next_p;	chaser_p->its_next_p = 0;	chaser_p = x_p;	while(x_p){		x_p = x_p->its_next_p;		delete chaser_p;		chaser_p = x_p;	}}//******************************************VOID   TRANS_MAT::clear() {// Deletes all heap memory and sets both Dimensions to zero.// Equivalent to resize(0, 0).  	for(USHORT row=0; row<its_num_of_rows ; row++){		clear_row(row);	}	delete []  its_elements_p_p;	its_elements_p_p = 0;	its_num_of_rows=0;	its_num_of_cols=0;}//******************************************VOID	TRANS_MAT::copy(const TRANS_MAT  & 	mat) 	//in	{ // builds a copy of mat. 	its_num_of_cols = mat.its_num_of_cols;	its_num_of_rows = mat.its_num_of_rows;	if(its_num_of_rows==0){		its_elements_p_p=0;		return;	}	its_elements_p_p = new DIR_NZ_ELE  * [its_num_of_rows];//new[]	//delete:	I delete its_elements_p_p and its_elements_p_p[row] 	//			in TRANS_MAT::clear(), and in many other TRANS_MAT methods.	ThrowIfNil_(its_elements_p_p);	DIR_NZ_ELE  * x_p=0;	DIR_NZ_ELE  * new_x_p=0;	DIR_NZ_ELE  * new_last_p=0;		for(USHORT r=0; r<its_num_of_rows; r++){			x_p = mat.its_elements_p_p[r];		if(x_p==0){			its_elements_p_p[r]=0;			goto next_row;		}		new_x_p = new DIR_NZ_ELE(x_p->its_col_num, x_p->its_ele, 0);		//delete:		ThrowIfNil_(new_x_p);		its_elements_p_p[r] =new_x_p;		new_last_p =new_x_p;		x_p = x_p->its_next_p;		while(x_p){			new_x_p = new DIR_NZ_ELE(x_p->its_col_num, x_p->its_ele, 0);			//delete:			ThrowIfNil_(new_x_p);			new_last_p->its_next_p  =  new_x_p;			new_last_p =new_x_p;			x_p = x_p->its_next_p;		}	next_row: ; 	}}//******************************************VOID	TRANS_MAT::set_to_zero_mat(USHORT 		num_of_rows,		//inTM_COL_NUM 	num_of_cols)		//in{// Deletes all heap memory and builds a (num_of_rows)X(num_of_cols) zero matrix.	resize(num_of_rows, 0);	its_num_of_cols = num_of_cols;}//******************************************VOID	TRANS_MAT::resize(USHORT 		new_nr,		//inTM_COL_NUM 	new_nc) 	//in		{  	//nr=number of rows, nc=number of columns	if(new_nr==0){		clear();		return;	}	if(new_nc < its_num_of_cols){		DIR_NZ_ELE  *  x_p=0;		DIR_NZ_ELE  *  chaser_p=0;		for (USHORT r= 0; r< its_num_of_rows; r++){			x_p = its_elements_p_p[r];			if(x_p==0) goto next_row;			if(new_nc <= x_p->its_col_num ){				clear_row(r);				goto next_row;			}						chaser_p = x_p;			x_p = x_p->its_next_p;			while(x_p){				if(   ( chaser_p->its_col_num < new_nc ) &&		      		(new_nc < x_p->its_col_num) ){		      		clear_row(chaser_p);					goto next_row;				}				if (new_nc == x_p->its_col_num ){					clear_row(chaser_p); 					goto next_row;				}				chaser_p = x_p;				x_p = x_p->its_next_p;							}			next_row: ;		}		}	if(new_nr == its_num_of_rows) return;	//if reach this point, new_nr != 0		DIR_NZ_ELE  *  *  new_mat_p_p = new DIR_NZ_ELE  * [new_nr]; //new[]	//delete:	ThrowIfNil_(new_mat_p_p);	USHORT r;	if(new_nr < its_num_of_rows){		for(r=0; r<new_nr; r++){			new_mat_p_p[r]= its_elements_p_p[r];		}		for(r=new_nr; r<its_num_of_rows; r++){			clear_row(r);		}	}else{ // if new_nr > its_num_of_rows		for(r=0; r<its_num_of_rows; r++){			new_mat_p_p[r]= its_elements_p_p[r];		}		for(r=its_num_of_rows; r<new_nr; r++){			new_mat_p_p[r]=0;		}	}	delete [] its_elements_p_p;	its_elements_p_p =new_mat_p_p;	its_num_of_rows =new_nr;	its_num_of_cols =new_nc;}//******************************************TRANS_MAT::TRANS_MAT()	:its_num_of_rows(0),	its_num_of_cols(0),	its_elements_p_p(0){	set_to_zero_mat(1, 1);}//******************************************TRANS_MAT::TRANS_MAT(USHORT			num_of_rows,	//inTM_COL_NUM		num_of_cols)	//in	:its_num_of_rows(0),	its_num_of_cols(0),	its_elements_p_p(0){	set_to_zero_mat(num_of_rows, num_of_cols);}	//******************************************TRANS_MAT::TRANS_MAT(const TRANS_MAT  &		mat){	copy(mat);}//******************************************TRANS_MAT  & 	TRANS_MAT::operator=(const TRANS_MAT  &		rhs)	//in{	if(this != &rhs){		clear();		copy(rhs);	}	return *this;}			//******************************************TRANS_MAT::~TRANS_MAT(){	clear();}#pragma mark --consider one element--//******************************************COMPLEX		TRANS_MAT::read_ele(USHORT 			row,		//inTM_COL_NUM 		col)		//inconst {// Returns the element at position (row, col). If there is// no nz-element at that position, then it returns COMPLEX(0, 0).// It is  assumed that row is >= 0 and <its_num_of_rows, and// col is >= O and <its_num_of_cols.	DIR_NZ_ELE  *   x_p = its_elements_p_p[row];	if(x_p==0) return COMPLEX(0, 0);	if(	col < x_p->its_col_num) return COMPLEX(0, 0);	if(col == x_p->its_col_num) return x_p->its_ele;	DIR_NZ_ELE  *   chaser_p = x_p;	x_p = x_p->its_next_p;	while(x_p){		if(col < x_p->its_col_num ) return COMPLEX(0, 0);		if(col == x_p->its_col_num ) return x_p->its_ele;				chaser_p = x_p;		x_p = x_p->its_next_p;		}	return COMPLEX(0, 0);	}//******************************************VOID   TRANS_MAT::set_ele(USHORT 			row,			//inTM_COL_NUM 		col,			//inconst COMPLEX  & 		ele)	//in{// Set element at (row, col) to ele. ele may be COMPLEX (0, 0).// The function set_ele can be used to either modify(nz->nz) or extract(nz->z) // an existing non-zero element, or else to insert(z->nz) a new nz element,// or to do nothing(z->z) // (If ele=COMPLEX (0, 0),// and there already exists a nz element at (row, col),// this function will extract that element).// It is  assumed that row is >= 0 and <its_num_of_rows, and// col is >= O and <its_num_of_cols.// Row elements are ordered by increasing column number.// Hence, if you have to insert more than one nz element in a given row, // it is more efficient to insert HIGHER column numbers FIRST.// Likewise, if you have to extract more than one nz element in a given row,// it is more efficient to extract LOWER column numbers FIRST.  	DIR_NZ_ELE  *  x_p = its_elements_p_p[row];	DIR_NZ_ELE  *  chaser_p=0;	DOUBLE	abs_ele = abs(ele);	if(x_p==0){		if(abs_ele>=amps_floor){ 			x_p = new DIR_NZ_ELE(col, ele, 0);			//delete:			ThrowIfNil_(x_p);			its_elements_p_p[row] = x_p;			return ;		}else{			return;		}	}	if(col < x_p->its_col_num ){		if(abs_ele>=amps_floor){ 			x_p = new DIR_NZ_ELE(col, ele, x_p);			//delete:				ThrowIfNil_(x_p);				its_elements_p_p[row] = x_p;			return ;		}else{			return;		}	}	if (col == x_p->its_col_num ){ 		if(abs_ele>=amps_floor){ 			x_p->its_ele = ele;			return ;		}else{			its_elements_p_p[row] = x_p->its_next_p;			delete x_p;			x_p = 0;			return;		}	}	chaser_p = x_p;	x_p = x_p->its_next_p;	while(x_p){		if( ( chaser_p->its_col_num  <  col) && (col  <   x_p->its_col_num) ){		    if(abs_ele>=amps_floor){				x_p = new DIR_NZ_ELE(col, ele, x_p);				//delete:				ThrowIfNil_(x_p);				chaser_p->its_next_p  =  x_p;				return;			}else{				return;			}		}		if (col == x_p->its_col_num ){			if(abs_ele>=amps_floor){ 				x_p->its_ele = ele;				return;			}else{				chaser_p->its_next_p = x_p->its_next_p;				delete x_p;				x_p=0;				return;			}		}		chaser_p = x_p;		x_p = x_p->its_next_p;	}	//if you get this far, then there is no nz-element in position	// (row, col), so add  ele if it's non-zero.	if(abs_ele>=amps_floor){		x_p = new DIR_NZ_ELE(col, ele, 0);		//delete:		ThrowIfNil_(x_p) ;		chaser_p->its_next_p  = x_p;		return;	}}#pragma mark --consider one col--//******************************************DOUBLE		TRANS_MAT::get_col_prob(TM_COL_NUM 	col) 	//in{// prob = probability // prob =  the sum of [the absolute value of a vec component]**2 .	DOUBLE sum = 0;	for(USHORT row =0; row< its_num_of_rows; row++){		sum += norm(read_ele(row, col)); 		//norm = modulus**2 = abs**2 = real**2 + imag**2	}	return sum;}//******************************************VECTOR<COMPLEX>		TRANS_MAT::get_col(TM_COL_NUM 	col) 	//in{	VECTOR<COMPLEX> vec(COMPLEX(0, 0), its_num_of_rows);	for(USHORT row =0; row< its_num_of_rows; row++){		vec[row] = read_ele(row, col);	}	return vec;}#pragma mark --consider one row--//******************************************USHORT		TRANS_MAT::get_num_of_nz_elems(USHORT 		row)	//in{ 	DIR_NZ_ELE  *  x_p = its_elements_p_p[row]; 	LONG num = 0; 	while(x_p){ 		num++; 		x_p = x_p->its_next_p; 	} 	ThrowIf_(num > max_ushort);		return num;}#pragma mark --consider all elements--/* COL_LABEL_TRANSLATOR no longer used//******************************************VOID   TRANS_MAT::relabel_cols(const COL_LABEL_TRANSLATOR  &  	ator)	//in{// Uses function ator.new_col_label to relabel the columns. // If ator.new_col_label says max_ushort, the element is deleted.// ator.new_col_label must have the property that:// The new elements, like the old, should be // in order of increasing column numbers. For some translators,// this ocurrs automatically. If it does not occur automatically,// you must use order_row_elems_by_increasing_col_num() // immediately after using this method.	DIR_NZ_ELE  *  x_p=0;	DIR_NZ_ELE  *  chaser_p=0;	USHORT num;	for (USHORT r= 0; r< its_num_of_rows; r++){		chaser_p =0;		x_p = its_elements_p_p[r];		while(x_p){			num = ator.new_col_label(x_p->its_col_num);			if( num != max_ushort){				x_p->its_col_num = num;				chaser_p = x_p;				x_p = x_p->its_next_p;				goto nz_chaser_p; // nz = non-zero			}else{ // num = max_ushort:				its_elements_p_p[r]= x_p->its_next_p;							delete x_p;				x_p = its_elements_p_p[r];			}		}		nz_chaser_p: ;				while(x_p){			num = ator.new_col_label(x_p->its_col_num);			if( num != max_ushort){				x_p->its_col_num = num;				chaser_p = x_p;				x_p = x_p->its_next_p;			}else{ // num = max_ushort:				chaser_p->its_next_p= x_p->its_next_p;						delete x_p;				x_p = chaser_p->its_next_p;						}		}	}	its_num_of_cols = ator.get_new_num_of_sts();			}*/#pragma mark --consider all elements: small amps--//******************************************const USHORT	TRANS_MAT::get_cur_finesse_of_amps()const{	DOUBLE	abs_lower_bd = 1; 	USHORT	exponent = 0;	DOUBLE	abs_of_ele;	DIR_NZ_ELE  *   x_p;		for(USHORT row =0; row< its_num_of_rows; row++){		x_p = its_elements_p_p[row];		while(x_p){			abs_of_ele = abs(x_p->its_ele);			ThrowIf_(abs_of_ele==0);			//norm = abs^2			//extra amps_floor summand to drown out noise			//When abs_of_ele=abs_lower_bd, get 0.1*amps_floor<0			while( (abs_of_ele + 0.1*amps_floor) <abs_lower_bd){				exponent++; 				abs_lower_bd *= 0.1; 			}			//at this point, 			// 10^(-exponent) <= abs(ele) < 10^(-exponent + 1) 			x_p = x_p->its_next_p;			}	}		return exponent;}//******************************************VOID	TRANS_MAT::filter_out_small_amps(USHORT	finesse )		//in{	DOUBLE	amps_admit_size = 1;	for(USHORT	i=0; i < finesse; i++){amps_admit_size *= .1;}		if(amps_admit_size < amps_floor) return;		for(USHORT row =0; row< its_num_of_rows; row++){		for(TM_COL_NUM	col = 0; col< its_num_of_cols; col++){			DOUBLE	a = abs(read_ele(row, col));			//extra amps_floor summand to drown out noise			//When a=amps_admit_size, get 0.1*amps_floor<0			if( (a + 0.1*amps_floor) < amps_admit_size)set_ele(row, col, 0);		}	}}#pragma mark --consider all elements: reorder--//******************************************VOID	TRANS_MAT::reorder_rows(const UI_MAP  &		map)	//in{	if(its_num_of_rows==0)return;	if(map.is_identity_map())return;	USHORT	i;	DIR_NZ_ELE  *  *    old_elements_p_p = new DIR_NZ_ELE  * [its_num_of_rows];//new[]	//delete: in this method	ThrowIfNil_(old_elements_p_p);	for(i=0; i<its_num_of_rows; i++){		old_elements_p_p[i] = its_elements_p_p[i];	}	for(i=0; i<its_num_of_rows; i++){		its_elements_p_p[i] = old_elements_p_p[map.its_oldfn[i]];	}		delete [] old_elements_p_p;	old_elements_p_p = 0;}//******************************************VOID	TRANS_MAT::reorder_cols_as_part_of_reordering_in_nds(const STRETCH_OR_FOLD  &   old_sof,			//inconst STRETCH_OR_FOLD  &   new_sof,			//inconst UI_MAP  &		map)					//in{	if(map.is_identity_map())return;	DIR_NZ_ELE  *  x_p=0;	USHORT	len = old_sof.get_len();	VECTOR<USHORT>  old_vec(0, len);	VECTOR<USHORT>  new_vec(0, len);	for (USHORT r= 0; r< its_num_of_rows; r++){		x_p = its_elements_p_p[r];		while(x_p){			old_vec = old_sof.vec_label(x_p->its_col_num);			for(USHORT i = 0; i<len; i++){				new_vec[i] = old_vec[map.its_oldfn[i]];			}			x_p->its_col_num =new_sof.int_label(new_vec);					x_p = x_p->its_next_p;		}	}	order_row_elems_by_increasing_col_num();}//******************************************VOID	TRANS_MAT::reorder_cols_as_part_of_reordering_nd_sts_of_a_pa(USHORT		pa_pos,							//inconst STRETCH_OR_FOLD  &   sof,				//inconst UI_MAP  &		map)					//in{	if(map.is_identity_map())return;	DIR_NZ_ELE  *  x_p=0;	VECTOR<USHORT>  vec(0, sof.get_len());	for (USHORT r= 0; r< its_num_of_rows; r++){		x_p = its_elements_p_p[r];		while(x_p){			vec = sof.vec_label(x_p->its_col_num);			vec[pa_pos] = map.its_newfo[vec[pa_pos]];			x_p->its_col_num = sof.int_label(vec);					x_p = x_p->its_next_p;		}	}	order_row_elems_by_increasing_col_num();}//******************************************VOID	TRANS_MAT::order_row_elems_by_increasing_col_num(){	TM_COL_NUM  *  			old_col_nums_p = 0;	DIR_NZ_ELE  *  *  		old_elems_p_p = 0;	DIR_NZ_ELE  *   		x_p = 0;	USHORT	i, len;	UI_MAP	map;	for(USHORT	r=0; r<its_num_of_rows; r++){		len = get_num_of_nz_elems(r);		if(len!=0){			old_col_nums_p = new TM_COL_NUM [len];//new[]			//delete: 	at the end of each iteration			ThrowIfNil_(old_col_nums_p);			old_elems_p_p = new DIR_NZ_ELE  * [len];//new[]			//delete: 	at the end of each iteration			ThrowIfNil_(old_elems_p_p);			x_p = its_elements_p_p[r];			for(i=0; i<len; i++){				old_elems_p_p[i] = x_p;				old_col_nums_p[i] = (*x_p).its_col_num;				x_p = x_p->its_next_p;			}			map.sort_vec_of_longs_by_size(old_col_nums_p, len);			its_elements_p_p[r]= old_elems_p_p[map.its_oldfn[0]];			x_p = its_elements_p_p[r];			for(i= 0; i + 1 <len; i++){ 				(*x_p).its_next_p = old_elems_p_p[map.its_oldfn[i+1]];				x_p = x_p->its_next_p;			}			(*x_p).its_next_p = 0;			delete [] old_col_nums_p;			old_col_nums_p=0;			delete [] old_elems_p_p;			old_elems_p_p=0;		}	}}#pragma mark ----------mac_gui_app only----------#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.#pragma mark --i/o--//******************************************VOID	TRANS_MAT::write_net_stream(LStream  &	net_stream)	//i-o{	COMPLEX  z;	for(USHORT row=0; row<its_num_of_rows; row++){		net_stream<<get_num_of_nz_elems(row);//write_net		DIR_NZ_ELE  * x_p = its_elements_p_p[row];		while(x_p){			net_stream<<x_p->get_col_num();//write_net			z = x_p->get_ele();			//store machine indep doubles			net_stream<<DOUBLE64(real(z))<<DOUBLE64(imag(z));//write_net			x_p = x_p->its_next_p;		}	}}		//******************************************VOID	TRANS_MAT::read_net_stream(LStream  &	net_stream)	//i-o{	//this assumes that the Dimensions of trans mat are already correct	set_to_zero_mat(its_num_of_rows, its_num_of_cols);	USHORT 		num_of_nz_elems_for_this_row;	TM_COL_NUM 	col;	COMPLEX  	z;	DOUBLE64 x, y;//store machine indep doubles	for(USHORT row=0; row<its_num_of_rows; row++){		net_stream>>num_of_nz_elems_for_this_row;//read_net		DIR_NZ_ELE  *  x_p = 0;		DIR_NZ_ELE  *  prev_p=0;		for(USHORT i=0; i<num_of_nz_elems_for_this_row; i++){			net_stream>>col;//read_net 			net_stream>>x>>y;//read_net			z = COMPLEX(x, y);			if(x_p==0){				x_p = new DIR_NZ_ELE(col, z, 0);				//delete:				ThrowIfNil_(x_p);				its_elements_p_p[row]= x_p;			}else{				prev_p = x_p;				x_p = new DIR_NZ_ELE(col, z, 0);				//delete:				ThrowIfNil_(x_p);				prev_p->its_next_p = x_p;				}		}	}}#endif //_mac_gui_app \\............................................//												