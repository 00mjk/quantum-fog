#include "DICTIONARY.h"#pragma mark --creation/destruction--//******************************************VOID 	DICTIONARY::sort_vec_of_ids_by_abc(){//Ascending indirect shell sort.//Comes from page 235 of Practical Algorithms in C++ by Flamig.  	USHORT 	stringy_id;  	USHORT  i, j, h;	for (h = its_num_of_stringies; h > 1;) {    		if(h<5){   			h= 1;   		}else{   			h = (5*h-1)/11;   		}    	// Perform insertion sort with increment h    	for(i = h; i < its_num_of_stringies; i++) {     	 	stringy_id = its_ids_p[i];      		j = i;      		while(j >= h && get_stringy(stringy_id) < get_stringy(its_ids_p[j-h]) ) {        		its_ids_p[j] = its_ids_p[j-h];        		j = j-h;      		}      		its_ids_p[j] = stringy_id;    	}  	}}//******************************************DICTIONARY::DICTIONARY(const STRINGY  *  *		stringies_p_p,		//inUSHORT 		num)							//in{	its_stringies_p = 0;	its_stringies_p_p = stringies_p_p;	its_num_of_stringies = num;	its_num_of_users = 1;	if(its_num_of_stringies==0){		its_ids_p = 0;	}else{		its_ids_p = new USHORT[its_num_of_stringies];//new[]		//delete:	in ~DICTIONARY().		ThrowIfNil_(its_ids_p);	}	for(USHORT i=0; i<its_num_of_stringies; i++){		its_ids_p[i] = i;	}	sort_vec_of_ids_by_abc();}//******************************************DICTIONARY::DICTIONARY(VECTOR<STRINGY>  *   stringies_p)		//in{	its_stringies_p = stringies_p;	its_stringies_p_p = 0;	its_num_of_stringies = stringies_p->get_len();	its_num_of_users = 1;	if(its_num_of_stringies==0){		its_ids_p = 0;	}else{		its_ids_p = new USHORT[its_num_of_stringies];//new[]		//delete:	in ~DICTIONARY().		ThrowIfNil_(its_ids_p);	}	for(USHORT i=0; i<its_num_of_stringies; i++){		its_ids_p[i] = i;	}	sort_vec_of_ids_by_abc();}//******************************************DICTIONARY::~DICTIONARY(){	delete [] its_ids_p;	its_ids_p = 0;}#pragma mark --map accessors--//******************************************const STRINGY  & 	DICTIONARY::get_stringy(USHORT 	id)		//inconst{	if(its_stringies_p==0){		return *its_stringies_p_p[id];	}else{		return (*its_stringies_p)[id];	}}//******************************************USHORT		DICTIONARY::get_id_of_this_stringy(const STRINGY  & 	stringy)	//inconst{	//does a binary search. 	//Reference: pg. 688 of  Adams, Leestma, Nyhoff book	SHORT	first_pos=0;	SHORT 	mid_pos, id_of_mid_pos;	SHORT  	last_pos = its_num_of_stringies-1;	while(first_pos<=last_pos){		mid_pos = (first_pos + last_pos)/2;		id_of_mid_pos = its_ids_p[mid_pos];		if(  stringy == get_stringy(id_of_mid_pos)  )return id_of_mid_pos;		if(  stringy < get_stringy(id_of_mid_pos)  ){			last_pos = mid_pos - 1;		}else{			first_pos = mid_pos + 1;		}	}	//if it can't find the stringy:	return max_ushort;}//******************************************VOID		DICTIONARY::get_map(UI_MAP  &	map)	//i-oconst{	ThrowIf_(map.its_oldfn.get_len()!=its_num_of_stringies);	for(USHORT i=0; i<its_num_of_stringies; i++){		map.its_oldfn[i] = its_ids_p[i];	}	map.set_newfo();}/*	I wasn't able to use the qsort() and bsearch() ANSI functions.	The following didn't work because my compare_p depends on this	and its not supposed to.	qsort(its_ids_p, num, sizeof(its_ids_p[0]), compare_p);//******************************************int DICTIONARY::compare_p(const USHORT  * id1_p, const USHORT  * id2_p) { //not used with shell sort	STRINGY  * 	x_p = its_stringies_p_p[*id1_p];	STRINGY  * 	y_p = its_stringies_p_p[*id2_p];	return (x_p->compare_with(*y_p) );}*/	 	